
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Salon
 * 
 */
export type Salon = $Result.DefaultSelection<Prisma.$SalonPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model CashCategory
 * 
 */
export type CashCategory = $Result.DefaultSelection<Prisma.$CashCategoryPayload>
/**
 * Model CashTransaction
 * 
 */
export type CashTransaction = $Result.DefaultSelection<Prisma.$CashTransactionPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model Delivery
 * 
 */
export type Delivery = $Result.DefaultSelection<Prisma.$DeliveryPayload>
/**
 * Model Receivable
 * 
 */
export type Receivable = $Result.DefaultSelection<Prisma.$ReceivablePayload>
/**
 * Model ReceivableInstallment
 * 
 */
export type ReceivableInstallment = $Result.DefaultSelection<Prisma.$ReceivableInstallmentPayload>
/**
 * Model Payable
 * 
 */
export type Payable = $Result.DefaultSelection<Prisma.$PayablePayload>
/**
 * Model PayableInstallment
 * 
 */
export type PayableInstallment = $Result.DefaultSelection<Prisma.$PayableInstallmentPayload>
/**
 * Model Cost
 * 
 */
export type Cost = $Result.DefaultSelection<Prisma.$CostPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClientType: {
  CLIENTE: 'CLIENTE',
  FORNECEDOR: 'FORNECEDOR',
  BOTH: 'BOTH'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const OrderStatus: {
  ORCAMENTO: 'ORCAMENTO',
  PEDIDO: 'PEDIDO',
  EM_PRODUCAO: 'EM_PRODUCAO',
  PRONTO: 'PRONTO',
  ENTREGUE: 'ENTREGUE',
  CANCELADO: 'CANCELADO'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const DeliveryStatus: {
  PENDENTE: 'PENDENTE',
  EM_ROTA: 'EM_ROTA',
  ENTREGUE: 'ENTREGUE',
  ATRASADA: 'ATRASADA',
  CANCELADA: 'CANCELADA'
};

export type DeliveryStatus = (typeof DeliveryStatus)[keyof typeof DeliveryStatus]


export const InstallmentStatus: {
  PENDENTE: 'PENDENTE',
  PAGO: 'PAGO',
  ATRASADO: 'ATRASADO',
  CANCELADO: 'CANCELADO'
};

export type InstallmentStatus = (typeof InstallmentStatus)[keyof typeof InstallmentStatus]


export const CostType: {
  FIXO: 'FIXO',
  VARIAVEL: 'VARIAVEL'
};

export type CostType = (typeof CostType)[keyof typeof CostType]


export const PaymentMethod: {
  PIX: 'PIX',
  CARTAO: 'CARTAO',
  DINHEIRO: 'DINHEIRO',
  BOLETO: 'BOLETO',
  TRANSFERENCIA: 'TRANSFERENCIA',
  OUTRO: 'OUTRO'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentMode: {
  AVISTA: 'AVISTA',
  PARCELADO: 'PARCELADO'
};

export type PaymentMode = (typeof PaymentMode)[keyof typeof PaymentMode]


export const CashType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE'
};

export type CashType = (typeof CashType)[keyof typeof CashType]


export const CashSource: {
  MANUAL: 'MANUAL',
  APPOINTMENT: 'APPOINTMENT'
};

export type CashSource = (typeof CashSource)[keyof typeof CashSource]

}

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type DeliveryStatus = $Enums.DeliveryStatus

export const DeliveryStatus: typeof $Enums.DeliveryStatus

export type InstallmentStatus = $Enums.InstallmentStatus

export const InstallmentStatus: typeof $Enums.InstallmentStatus

export type CostType = $Enums.CostType

export const CostType: typeof $Enums.CostType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentMode = $Enums.PaymentMode

export const PaymentMode: typeof $Enums.PaymentMode

export type CashType = $Enums.CashType

export const CashType: typeof $Enums.CashType

export type CashSource = $Enums.CashSource

export const CashSource: typeof $Enums.CashSource

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salon`: Exposes CRUD operations for the **Salon** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salons
    * const salons = await prisma.salon.findMany()
    * ```
    */
  get salon(): Prisma.SalonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashCategory`: Exposes CRUD operations for the **CashCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashCategories
    * const cashCategories = await prisma.cashCategory.findMany()
    * ```
    */
  get cashCategory(): Prisma.CashCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cashTransaction`: Exposes CRUD operations for the **CashTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CashTransactions
    * const cashTransactions = await prisma.cashTransaction.findMany()
    * ```
    */
  get cashTransaction(): Prisma.CashTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delivery`: Exposes CRUD operations for the **Delivery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.delivery.findMany()
    * ```
    */
  get delivery(): Prisma.DeliveryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receivable`: Exposes CRUD operations for the **Receivable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receivables
    * const receivables = await prisma.receivable.findMany()
    * ```
    */
  get receivable(): Prisma.ReceivableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receivableInstallment`: Exposes CRUD operations for the **ReceivableInstallment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReceivableInstallments
    * const receivableInstallments = await prisma.receivableInstallment.findMany()
    * ```
    */
  get receivableInstallment(): Prisma.ReceivableInstallmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payable`: Exposes CRUD operations for the **Payable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payables
    * const payables = await prisma.payable.findMany()
    * ```
    */
  get payable(): Prisma.PayableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payableInstallment`: Exposes CRUD operations for the **PayableInstallment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayableInstallments
    * const payableInstallments = await prisma.payableInstallment.findMany()
    * ```
    */
  get payableInstallment(): Prisma.PayableInstallmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cost`: Exposes CRUD operations for the **Cost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Costs
    * const costs = await prisma.cost.findMany()
    * ```
    */
  get cost(): Prisma.CostDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Salon: 'Salon',
    Service: 'Service',
    Client: 'Client',
    Appointment: 'Appointment',
    CashCategory: 'CashCategory',
    CashTransaction: 'CashTransaction',
    Order: 'Order',
    OrderItem: 'OrderItem',
    Delivery: 'Delivery',
    Receivable: 'Receivable',
    ReceivableInstallment: 'ReceivableInstallment',
    Payable: 'Payable',
    PayableInstallment: 'PayableInstallment',
    Cost: 'Cost'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "salon" | "service" | "client" | "appointment" | "cashCategory" | "cashTransaction" | "order" | "orderItem" | "delivery" | "receivable" | "receivableInstallment" | "payable" | "payableInstallment" | "cost"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Salon: {
        payload: Prisma.$SalonPayload<ExtArgs>
        fields: Prisma.SalonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>
          }
          findFirst: {
            args: Prisma.SalonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>
          }
          findMany: {
            args: Prisma.SalonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>[]
          }
          create: {
            args: Prisma.SalonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>
          }
          createMany: {
            args: Prisma.SalonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>[]
          }
          delete: {
            args: Prisma.SalonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>
          }
          update: {
            args: Prisma.SalonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>
          }
          deleteMany: {
            args: Prisma.SalonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>[]
          }
          upsert: {
            args: Prisma.SalonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalonPayload>
          }
          aggregate: {
            args: Prisma.SalonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalon>
          }
          groupBy: {
            args: Prisma.SalonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalonCountArgs<ExtArgs>
            result: $Utils.Optional<SalonCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      CashCategory: {
        payload: Prisma.$CashCategoryPayload<ExtArgs>
        fields: Prisma.CashCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>
          }
          findFirst: {
            args: Prisma.CashCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>
          }
          findMany: {
            args: Prisma.CashCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>[]
          }
          create: {
            args: Prisma.CashCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>
          }
          createMany: {
            args: Prisma.CashCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>[]
          }
          delete: {
            args: Prisma.CashCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>
          }
          update: {
            args: Prisma.CashCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CashCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>[]
          }
          upsert: {
            args: Prisma.CashCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashCategoryPayload>
          }
          aggregate: {
            args: Prisma.CashCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashCategory>
          }
          groupBy: {
            args: Prisma.CashCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CashCategoryCountAggregateOutputType> | number
          }
        }
      }
      CashTransaction: {
        payload: Prisma.$CashTransactionPayload<ExtArgs>
        fields: Prisma.CashTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CashTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CashTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findFirst: {
            args: Prisma.CashTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CashTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          findMany: {
            args: Prisma.CashTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          create: {
            args: Prisma.CashTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          createMany: {
            args: Prisma.CashTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CashTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          delete: {
            args: Prisma.CashTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          update: {
            args: Prisma.CashTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CashTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CashTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CashTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>[]
          }
          upsert: {
            args: Prisma.CashTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CashTransactionPayload>
          }
          aggregate: {
            args: Prisma.CashTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCashTransaction>
          }
          groupBy: {
            args: Prisma.CashTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CashTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CashTransactionCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      Delivery: {
        payload: Prisma.$DeliveryPayload<ExtArgs>
        fields: Prisma.DeliveryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findFirst: {
            args: Prisma.DeliveryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          findMany: {
            args: Prisma.DeliveryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          create: {
            args: Prisma.DeliveryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          createMany: {
            args: Prisma.DeliveryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          delete: {
            args: Prisma.DeliveryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          update: {
            args: Prisma.DeliveryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>[]
          }
          upsert: {
            args: Prisma.DeliveryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryPayload>
          }
          aggregate: {
            args: Prisma.DeliveryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelivery>
          }
          groupBy: {
            args: Prisma.DeliveryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryCountAggregateOutputType> | number
          }
        }
      }
      Receivable: {
        payload: Prisma.$ReceivablePayload<ExtArgs>
        fields: Prisma.ReceivableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          findFirst: {
            args: Prisma.ReceivableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          findMany: {
            args: Prisma.ReceivableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
          }
          create: {
            args: Prisma.ReceivableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          createMany: {
            args: Prisma.ReceivableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceivableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
          }
          delete: {
            args: Prisma.ReceivableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          update: {
            args: Prisma.ReceivableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          deleteMany: {
            args: Prisma.ReceivableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceivableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>[]
          }
          upsert: {
            args: Prisma.ReceivableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivablePayload>
          }
          aggregate: {
            args: Prisma.ReceivableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceivable>
          }
          groupBy: {
            args: Prisma.ReceivableGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceivableGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivableCountArgs<ExtArgs>
            result: $Utils.Optional<ReceivableCountAggregateOutputType> | number
          }
        }
      }
      ReceivableInstallment: {
        payload: Prisma.$ReceivableInstallmentPayload<ExtArgs>
        fields: Prisma.ReceivableInstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReceivableInstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReceivableInstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>
          }
          findFirst: {
            args: Prisma.ReceivableInstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReceivableInstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>
          }
          findMany: {
            args: Prisma.ReceivableInstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>[]
          }
          create: {
            args: Prisma.ReceivableInstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>
          }
          createMany: {
            args: Prisma.ReceivableInstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReceivableInstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>[]
          }
          delete: {
            args: Prisma.ReceivableInstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>
          }
          update: {
            args: Prisma.ReceivableInstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>
          }
          deleteMany: {
            args: Prisma.ReceivableInstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReceivableInstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReceivableInstallmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>[]
          }
          upsert: {
            args: Prisma.ReceivableInstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReceivableInstallmentPayload>
          }
          aggregate: {
            args: Prisma.ReceivableInstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceivableInstallment>
          }
          groupBy: {
            args: Prisma.ReceivableInstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceivableInstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReceivableInstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<ReceivableInstallmentCountAggregateOutputType> | number
          }
        }
      }
      Payable: {
        payload: Prisma.$PayablePayload<ExtArgs>
        fields: Prisma.PayableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>
          }
          findFirst: {
            args: Prisma.PayableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>
          }
          findMany: {
            args: Prisma.PayableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>[]
          }
          create: {
            args: Prisma.PayableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>
          }
          createMany: {
            args: Prisma.PayableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>[]
          }
          delete: {
            args: Prisma.PayableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>
          }
          update: {
            args: Prisma.PayableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>
          }
          deleteMany: {
            args: Prisma.PayableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>[]
          }
          upsert: {
            args: Prisma.PayableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayablePayload>
          }
          aggregate: {
            args: Prisma.PayableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayable>
          }
          groupBy: {
            args: Prisma.PayableGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayableGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayableCountArgs<ExtArgs>
            result: $Utils.Optional<PayableCountAggregateOutputType> | number
          }
        }
      }
      PayableInstallment: {
        payload: Prisma.$PayableInstallmentPayload<ExtArgs>
        fields: Prisma.PayableInstallmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayableInstallmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayableInstallmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>
          }
          findFirst: {
            args: Prisma.PayableInstallmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayableInstallmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>
          }
          findMany: {
            args: Prisma.PayableInstallmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>[]
          }
          create: {
            args: Prisma.PayableInstallmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>
          }
          createMany: {
            args: Prisma.PayableInstallmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayableInstallmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>[]
          }
          delete: {
            args: Prisma.PayableInstallmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>
          }
          update: {
            args: Prisma.PayableInstallmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>
          }
          deleteMany: {
            args: Prisma.PayableInstallmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayableInstallmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayableInstallmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>[]
          }
          upsert: {
            args: Prisma.PayableInstallmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayableInstallmentPayload>
          }
          aggregate: {
            args: Prisma.PayableInstallmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayableInstallment>
          }
          groupBy: {
            args: Prisma.PayableInstallmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayableInstallmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayableInstallmentCountArgs<ExtArgs>
            result: $Utils.Optional<PayableInstallmentCountAggregateOutputType> | number
          }
        }
      }
      Cost: {
        payload: Prisma.$CostPayload<ExtArgs>
        fields: Prisma.CostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          findFirst: {
            args: Prisma.CostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          findMany: {
            args: Prisma.CostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          create: {
            args: Prisma.CostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          createMany: {
            args: Prisma.CostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          delete: {
            args: Prisma.CostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          update: {
            args: Prisma.CostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          deleteMany: {
            args: Prisma.CostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>[]
          }
          upsert: {
            args: Prisma.CostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostPayload>
          }
          aggregate: {
            args: Prisma.CostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCost>
          }
          groupBy: {
            args: Prisma.CostGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostCountArgs<ExtArgs>
            result: $Utils.Optional<CostCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    salon?: SalonOmit
    service?: ServiceOmit
    client?: ClientOmit
    appointment?: AppointmentOmit
    cashCategory?: CashCategoryOmit
    cashTransaction?: CashTransactionOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    delivery?: DeliveryOmit
    receivable?: ReceivableOmit
    receivableInstallment?: ReceivableInstallmentOmit
    payable?: PayableOmit
    payableInstallment?: PayableInstallmentOmit
    cost?: CostOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SalonCountOutputType
   */

  export type SalonCountOutputType = {
    services: number
    clients: number
    appointments: number
    cashCategories: number
    cashTransactions: number
    orders: number
    receivables: number
    payables: number
    costs: number
  }

  export type SalonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | SalonCountOutputTypeCountServicesArgs
    clients?: boolean | SalonCountOutputTypeCountClientsArgs
    appointments?: boolean | SalonCountOutputTypeCountAppointmentsArgs
    cashCategories?: boolean | SalonCountOutputTypeCountCashCategoriesArgs
    cashTransactions?: boolean | SalonCountOutputTypeCountCashTransactionsArgs
    orders?: boolean | SalonCountOutputTypeCountOrdersArgs
    receivables?: boolean | SalonCountOutputTypeCountReceivablesArgs
    payables?: boolean | SalonCountOutputTypeCountPayablesArgs
    costs?: boolean | SalonCountOutputTypeCountCostsArgs
  }

  // Custom InputTypes
  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalonCountOutputType
     */
    select?: SalonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountCashCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashCategoryWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountCashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountReceivablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountPayablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayableWhereInput
  }

  /**
   * SalonCountOutputType without action
   */
  export type SalonCountOutputTypeCountCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    appointments: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ServiceCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    appointments: number
    orders: number
    payables: number
    costs: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ClientCountOutputTypeCountAppointmentsArgs
    orders?: boolean | ClientCountOutputTypeCountOrdersArgs
    payables?: boolean | ClientCountOutputTypeCountPayablesArgs
    costs?: boolean | ClientCountOutputTypeCountCostsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountPayablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayableWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountCostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostWhereInput
  }


  /**
   * Count Type CashCategoryCountOutputType
   */

  export type CashCategoryCountOutputType = {
    transactions: number
  }

  export type CashCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | CashCategoryCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CashCategoryCountOutputType without action
   */
  export type CashCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategoryCountOutputType
     */
    select?: CashCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CashCategoryCountOutputType without action
   */
  export type CashCategoryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    items: number
    deliveries: number
    receivables: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | OrderCountOutputTypeCountItemsArgs
    deliveries?: boolean | OrderCountOutputTypeCountDeliveriesArgs
    receivables?: boolean | OrderCountOutputTypeCountReceivablesArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDeliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReceivablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableWhereInput
  }


  /**
   * Count Type ReceivableCountOutputType
   */

  export type ReceivableCountOutputType = {
    installments: number
  }

  export type ReceivableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | ReceivableCountOutputTypeCountInstallmentsArgs
  }

  // Custom InputTypes
  /**
   * ReceivableCountOutputType without action
   */
  export type ReceivableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableCountOutputType
     */
    select?: ReceivableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReceivableCountOutputType without action
   */
  export type ReceivableCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableInstallmentWhereInput
  }


  /**
   * Count Type PayableCountOutputType
   */

  export type PayableCountOutputType = {
    installments: number
  }

  export type PayableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installments?: boolean | PayableCountOutputTypeCountInstallmentsArgs
  }

  // Custom InputTypes
  /**
   * PayableCountOutputType without action
   */
  export type PayableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableCountOutputType
     */
    select?: PayableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayableCountOutputType without action
   */
  export type PayableCountOutputTypeCountInstallmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayableInstallmentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    password: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    password?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    password: string
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    createdAt?: boolean
    salon?: boolean | User$salonArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "password" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | User$salonArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      password: string
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends User$salonArgs<ExtArgs> = {}>(args?: Subset<T, User$salonArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.salon
   */
  export type User$salonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    where?: SalonWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Salon
   */

  export type AggregateSalon = {
    _count: SalonCountAggregateOutputType | null
    _min: SalonMinAggregateOutputType | null
    _max: SalonMaxAggregateOutputType | null
  }

  export type SalonMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    userId: string | null
    plan: string | null
    planStatus: string | null
    planEndsAt: Date | null
  }

  export type SalonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    userId: string | null
    plan: string | null
    planStatus: string | null
    planEndsAt: Date | null
  }

  export type SalonCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    userId: number
    plan: number
    planStatus: number
    planEndsAt: number
    _all: number
  }


  export type SalonMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    userId?: true
    plan?: true
    planStatus?: true
    planEndsAt?: true
  }

  export type SalonMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    userId?: true
    plan?: true
    planStatus?: true
    planEndsAt?: true
  }

  export type SalonCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    userId?: true
    plan?: true
    planStatus?: true
    planEndsAt?: true
    _all?: true
  }

  export type SalonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salon to aggregate.
     */
    where?: SalonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salons to fetch.
     */
    orderBy?: SalonOrderByWithRelationInput | SalonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salons
    **/
    _count?: true | SalonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalonMaxAggregateInputType
  }

  export type GetSalonAggregateType<T extends SalonAggregateArgs> = {
        [P in keyof T & keyof AggregateSalon]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalon[P]>
      : GetScalarType<T[P], AggregateSalon[P]>
  }




  export type SalonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalonWhereInput
    orderBy?: SalonOrderByWithAggregationInput | SalonOrderByWithAggregationInput[]
    by: SalonScalarFieldEnum[] | SalonScalarFieldEnum
    having?: SalonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalonCountAggregateInputType | true
    _min?: SalonMinAggregateInputType
    _max?: SalonMaxAggregateInputType
  }

  export type SalonGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    userId: string
    plan: string
    planStatus: string
    planEndsAt: Date | null
    _count: SalonCountAggregateOutputType | null
    _min: SalonMinAggregateOutputType | null
    _max: SalonMaxAggregateOutputType | null
  }

  type GetSalonGroupByPayload<T extends SalonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalonGroupByOutputType[P]>
            : GetScalarType<T[P], SalonGroupByOutputType[P]>
        }
      >
    >


  export type SalonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    userId?: boolean
    plan?: boolean
    planStatus?: boolean
    planEndsAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    services?: boolean | Salon$servicesArgs<ExtArgs>
    clients?: boolean | Salon$clientsArgs<ExtArgs>
    appointments?: boolean | Salon$appointmentsArgs<ExtArgs>
    cashCategories?: boolean | Salon$cashCategoriesArgs<ExtArgs>
    cashTransactions?: boolean | Salon$cashTransactionsArgs<ExtArgs>
    orders?: boolean | Salon$ordersArgs<ExtArgs>
    receivables?: boolean | Salon$receivablesArgs<ExtArgs>
    payables?: boolean | Salon$payablesArgs<ExtArgs>
    costs?: boolean | Salon$costsArgs<ExtArgs>
    _count?: boolean | SalonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salon"]>

  export type SalonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    userId?: boolean
    plan?: boolean
    planStatus?: boolean
    planEndsAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salon"]>

  export type SalonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    userId?: boolean
    plan?: boolean
    planStatus?: boolean
    planEndsAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salon"]>

  export type SalonSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    userId?: boolean
    plan?: boolean
    planStatus?: boolean
    planEndsAt?: boolean
  }

  export type SalonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "userId" | "plan" | "planStatus" | "planEndsAt", ExtArgs["result"]["salon"]>
  export type SalonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    services?: boolean | Salon$servicesArgs<ExtArgs>
    clients?: boolean | Salon$clientsArgs<ExtArgs>
    appointments?: boolean | Salon$appointmentsArgs<ExtArgs>
    cashCategories?: boolean | Salon$cashCategoriesArgs<ExtArgs>
    cashTransactions?: boolean | Salon$cashTransactionsArgs<ExtArgs>
    orders?: boolean | Salon$ordersArgs<ExtArgs>
    receivables?: boolean | Salon$receivablesArgs<ExtArgs>
    payables?: boolean | Salon$payablesArgs<ExtArgs>
    costs?: boolean | Salon$costsArgs<ExtArgs>
    _count?: boolean | SalonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SalonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Salon"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      services: Prisma.$ServicePayload<ExtArgs>[]
      clients: Prisma.$ClientPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      cashCategories: Prisma.$CashCategoryPayload<ExtArgs>[]
      cashTransactions: Prisma.$CashTransactionPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      receivables: Prisma.$ReceivablePayload<ExtArgs>[]
      payables: Prisma.$PayablePayload<ExtArgs>[]
      costs: Prisma.$CostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      userId: string
      plan: string
      planStatus: string
      planEndsAt: Date | null
    }, ExtArgs["result"]["salon"]>
    composites: {}
  }

  type SalonGetPayload<S extends boolean | null | undefined | SalonDefaultArgs> = $Result.GetResult<Prisma.$SalonPayload, S>

  type SalonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalonCountAggregateInputType | true
    }

  export interface SalonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Salon'], meta: { name: 'Salon' } }
    /**
     * Find zero or one Salon that matches the filter.
     * @param {SalonFindUniqueArgs} args - Arguments to find a Salon
     * @example
     * // Get one Salon
     * const salon = await prisma.salon.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalonFindUniqueArgs>(args: SelectSubset<T, SalonFindUniqueArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Salon that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalonFindUniqueOrThrowArgs} args - Arguments to find a Salon
     * @example
     * // Get one Salon
     * const salon = await prisma.salon.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalonFindUniqueOrThrowArgs>(args: SelectSubset<T, SalonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salon that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonFindFirstArgs} args - Arguments to find a Salon
     * @example
     * // Get one Salon
     * const salon = await prisma.salon.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalonFindFirstArgs>(args?: SelectSubset<T, SalonFindFirstArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Salon that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonFindFirstOrThrowArgs} args - Arguments to find a Salon
     * @example
     * // Get one Salon
     * const salon = await prisma.salon.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalonFindFirstOrThrowArgs>(args?: SelectSubset<T, SalonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salons
     * const salons = await prisma.salon.findMany()
     * 
     * // Get first 10 Salons
     * const salons = await prisma.salon.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salonWithIdOnly = await prisma.salon.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalonFindManyArgs>(args?: SelectSubset<T, SalonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Salon.
     * @param {SalonCreateArgs} args - Arguments to create a Salon.
     * @example
     * // Create one Salon
     * const Salon = await prisma.salon.create({
     *   data: {
     *     // ... data to create a Salon
     *   }
     * })
     * 
     */
    create<T extends SalonCreateArgs>(args: SelectSubset<T, SalonCreateArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salons.
     * @param {SalonCreateManyArgs} args - Arguments to create many Salons.
     * @example
     * // Create many Salons
     * const salon = await prisma.salon.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalonCreateManyArgs>(args?: SelectSubset<T, SalonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salons and returns the data saved in the database.
     * @param {SalonCreateManyAndReturnArgs} args - Arguments to create many Salons.
     * @example
     * // Create many Salons
     * const salon = await prisma.salon.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salons and only return the `id`
     * const salonWithIdOnly = await prisma.salon.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalonCreateManyAndReturnArgs>(args?: SelectSubset<T, SalonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Salon.
     * @param {SalonDeleteArgs} args - Arguments to delete one Salon.
     * @example
     * // Delete one Salon
     * const Salon = await prisma.salon.delete({
     *   where: {
     *     // ... filter to delete one Salon
     *   }
     * })
     * 
     */
    delete<T extends SalonDeleteArgs>(args: SelectSubset<T, SalonDeleteArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Salon.
     * @param {SalonUpdateArgs} args - Arguments to update one Salon.
     * @example
     * // Update one Salon
     * const salon = await prisma.salon.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalonUpdateArgs>(args: SelectSubset<T, SalonUpdateArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salons.
     * @param {SalonDeleteManyArgs} args - Arguments to filter Salons to delete.
     * @example
     * // Delete a few Salons
     * const { count } = await prisma.salon.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalonDeleteManyArgs>(args?: SelectSubset<T, SalonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salons
     * const salon = await prisma.salon.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalonUpdateManyArgs>(args: SelectSubset<T, SalonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salons and returns the data updated in the database.
     * @param {SalonUpdateManyAndReturnArgs} args - Arguments to update many Salons.
     * @example
     * // Update many Salons
     * const salon = await prisma.salon.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Salons and only return the `id`
     * const salonWithIdOnly = await prisma.salon.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalonUpdateManyAndReturnArgs>(args: SelectSubset<T, SalonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Salon.
     * @param {SalonUpsertArgs} args - Arguments to update or create a Salon.
     * @example
     * // Update or create a Salon
     * const salon = await prisma.salon.upsert({
     *   create: {
     *     // ... data to create a Salon
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salon we want to update
     *   }
     * })
     */
    upsert<T extends SalonUpsertArgs>(args: SelectSubset<T, SalonUpsertArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonCountArgs} args - Arguments to filter Salons to count.
     * @example
     * // Count the number of Salons
     * const count = await prisma.salon.count({
     *   where: {
     *     // ... the filter for the Salons we want to count
     *   }
     * })
    **/
    count<T extends SalonCountArgs>(
      args?: Subset<T, SalonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalonAggregateArgs>(args: Subset<T, SalonAggregateArgs>): Prisma.PrismaPromise<GetSalonAggregateType<T>>

    /**
     * Group by Salon.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalonGroupByArgs['orderBy'] }
        : { orderBy?: SalonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Salon model
   */
  readonly fields: SalonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salon.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    services<T extends Salon$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Salon$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clients<T extends Salon$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Salon$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Salon$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Salon$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashCategories<T extends Salon$cashCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Salon$cashCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cashTransactions<T extends Salon$cashTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Salon$cashTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Salon$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Salon$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivables<T extends Salon$receivablesArgs<ExtArgs> = {}>(args?: Subset<T, Salon$receivablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payables<T extends Salon$payablesArgs<ExtArgs> = {}>(args?: Subset<T, Salon$payablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    costs<T extends Salon$costsArgs<ExtArgs> = {}>(args?: Subset<T, Salon$costsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Salon model
   */
  interface SalonFieldRefs {
    readonly id: FieldRef<"Salon", 'String'>
    readonly name: FieldRef<"Salon", 'String'>
    readonly createdAt: FieldRef<"Salon", 'DateTime'>
    readonly userId: FieldRef<"Salon", 'String'>
    readonly plan: FieldRef<"Salon", 'String'>
    readonly planStatus: FieldRef<"Salon", 'String'>
    readonly planEndsAt: FieldRef<"Salon", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Salon findUnique
   */
  export type SalonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * Filter, which Salon to fetch.
     */
    where: SalonWhereUniqueInput
  }

  /**
   * Salon findUniqueOrThrow
   */
  export type SalonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * Filter, which Salon to fetch.
     */
    where: SalonWhereUniqueInput
  }

  /**
   * Salon findFirst
   */
  export type SalonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * Filter, which Salon to fetch.
     */
    where?: SalonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salons to fetch.
     */
    orderBy?: SalonOrderByWithRelationInput | SalonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salons.
     */
    cursor?: SalonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salons.
     */
    distinct?: SalonScalarFieldEnum | SalonScalarFieldEnum[]
  }

  /**
   * Salon findFirstOrThrow
   */
  export type SalonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * Filter, which Salon to fetch.
     */
    where?: SalonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salons to fetch.
     */
    orderBy?: SalonOrderByWithRelationInput | SalonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salons.
     */
    cursor?: SalonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salons.
     */
    distinct?: SalonScalarFieldEnum | SalonScalarFieldEnum[]
  }

  /**
   * Salon findMany
   */
  export type SalonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * Filter, which Salons to fetch.
     */
    where?: SalonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salons to fetch.
     */
    orderBy?: SalonOrderByWithRelationInput | SalonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salons.
     */
    cursor?: SalonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salons.
     */
    skip?: number
    distinct?: SalonScalarFieldEnum | SalonScalarFieldEnum[]
  }

  /**
   * Salon create
   */
  export type SalonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * The data needed to create a Salon.
     */
    data: XOR<SalonCreateInput, SalonUncheckedCreateInput>
  }

  /**
   * Salon createMany
   */
  export type SalonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salons.
     */
    data: SalonCreateManyInput | SalonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Salon createManyAndReturn
   */
  export type SalonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * The data used to create many Salons.
     */
    data: SalonCreateManyInput | SalonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salon update
   */
  export type SalonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * The data needed to update a Salon.
     */
    data: XOR<SalonUpdateInput, SalonUncheckedUpdateInput>
    /**
     * Choose, which Salon to update.
     */
    where: SalonWhereUniqueInput
  }

  /**
   * Salon updateMany
   */
  export type SalonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salons.
     */
    data: XOR<SalonUpdateManyMutationInput, SalonUncheckedUpdateManyInput>
    /**
     * Filter which Salons to update
     */
    where?: SalonWhereInput
    /**
     * Limit how many Salons to update.
     */
    limit?: number
  }

  /**
   * Salon updateManyAndReturn
   */
  export type SalonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * The data used to update Salons.
     */
    data: XOR<SalonUpdateManyMutationInput, SalonUncheckedUpdateManyInput>
    /**
     * Filter which Salons to update
     */
    where?: SalonWhereInput
    /**
     * Limit how many Salons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Salon upsert
   */
  export type SalonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * The filter to search for the Salon to update in case it exists.
     */
    where: SalonWhereUniqueInput
    /**
     * In case the Salon found by the `where` argument doesn't exist, create a new Salon with this data.
     */
    create: XOR<SalonCreateInput, SalonUncheckedCreateInput>
    /**
     * In case the Salon was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalonUpdateInput, SalonUncheckedUpdateInput>
  }

  /**
   * Salon delete
   */
  export type SalonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
    /**
     * Filter which Salon to delete.
     */
    where: SalonWhereUniqueInput
  }

  /**
   * Salon deleteMany
   */
  export type SalonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salons to delete
     */
    where?: SalonWhereInput
    /**
     * Limit how many Salons to delete.
     */
    limit?: number
  }

  /**
   * Salon.services
   */
  export type Salon$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Salon.clients
   */
  export type Salon$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    cursor?: ClientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Salon.appointments
   */
  export type Salon$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Salon.cashCategories
   */
  export type Salon$cashCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    where?: CashCategoryWhereInput
    orderBy?: CashCategoryOrderByWithRelationInput | CashCategoryOrderByWithRelationInput[]
    cursor?: CashCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashCategoryScalarFieldEnum | CashCategoryScalarFieldEnum[]
  }

  /**
   * Salon.cashTransactions
   */
  export type Salon$cashTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * Salon.orders
   */
  export type Salon$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Salon.receivables
   */
  export type Salon$receivablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    where?: ReceivableWhereInput
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    cursor?: ReceivableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Salon.payables
   */
  export type Salon$payablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    where?: PayableWhereInput
    orderBy?: PayableOrderByWithRelationInput | PayableOrderByWithRelationInput[]
    cursor?: PayableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayableScalarFieldEnum | PayableScalarFieldEnum[]
  }

  /**
   * Salon.costs
   */
  export type Salon$costsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    where?: CostWhereInput
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    cursor?: CostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Salon without action
   */
  export type SalonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Salon
     */
    select?: SalonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Salon
     */
    omit?: SalonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalonInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceSumAggregateOutputType = {
    price: number | null
    duration: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    price: number | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    salonId: string | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    price: number | null
    duration: number | null
    isActive: boolean | null
    createdAt: Date | null
    salonId: string | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    price: number
    duration: number
    isActive: number
    createdAt: number
    salonId: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceSumAggregateInputType = {
    price?: true
    duration?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    salonId?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    salonId?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    price?: true
    duration?: true
    isActive?: true
    createdAt?: true
    salonId?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    category: string | null
    price: number
    duration: number
    isActive: boolean
    createdAt: Date
    salonId: string
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    appointments?: boolean | Service$appointmentsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    duration?: boolean
    isActive?: boolean
    createdAt?: boolean
    salonId?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "price" | "duration" | "isActive" | "createdAt" | "salonId", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    appointments?: boolean | Service$appointmentsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      price: number
      duration: number
      isActive: boolean
      createdAt: Date
      salonId: string
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Service$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Service$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'String'>
    readonly price: FieldRef<"Service", 'Int'>
    readonly duration: FieldRef<"Service", 'Int'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly salonId: FieldRef<"Service", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.appointments
   */
  export type Service$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    instagram: string | null
    notes: string | null
    createdAt: Date | null
    type: $Enums.ClientType | null
    salonId: string | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    instagram: string | null
    notes: string | null
    createdAt: Date | null
    type: $Enums.ClientType | null
    salonId: string | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    instagram: number
    notes: number
    createdAt: number
    type: number
    salonId: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    instagram?: true
    notes?: true
    createdAt?: true
    type?: true
    salonId?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    instagram?: true
    notes?: true
    createdAt?: true
    type?: true
    salonId?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    instagram?: true
    notes?: true
    createdAt?: true
    type?: true
    salonId?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    phone: string
    instagram: string | null
    notes: string | null
    createdAt: Date
    type: $Enums.ClientType
    salonId: string
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    instagram?: boolean
    notes?: boolean
    createdAt?: boolean
    type?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    appointments?: boolean | Client$appointmentsArgs<ExtArgs>
    orders?: boolean | Client$ordersArgs<ExtArgs>
    payables?: boolean | Client$payablesArgs<ExtArgs>
    costs?: boolean | Client$costsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    instagram?: boolean
    notes?: boolean
    createdAt?: boolean
    type?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    instagram?: boolean
    notes?: boolean
    createdAt?: boolean
    type?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    instagram?: boolean
    notes?: boolean
    createdAt?: boolean
    type?: boolean
    salonId?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "instagram" | "notes" | "createdAt" | "type" | "salonId", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    appointments?: boolean | Client$appointmentsArgs<ExtArgs>
    orders?: boolean | Client$ordersArgs<ExtArgs>
    payables?: boolean | Client$payablesArgs<ExtArgs>
    costs?: boolean | Client$costsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      payables: Prisma.$PayablePayload<ExtArgs>[]
      costs: Prisma.$CostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string
      instagram: string | null
      notes: string | null
      createdAt: Date
      type: $Enums.ClientType
      salonId: string
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    appointments<T extends Client$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Client$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Client$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Client$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payables<T extends Client$payablesArgs<ExtArgs> = {}>(args?: Subset<T, Client$payablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    costs<T extends Client$costsArgs<ExtArgs> = {}>(args?: Subset<T, Client$costsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly instagram: FieldRef<"Client", 'String'>
    readonly notes: FieldRef<"Client", 'String'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly type: FieldRef<"Client", 'ClientType'>
    readonly salonId: FieldRef<"Client", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.appointments
   */
  export type Client$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Client.orders
   */
  export type Client$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Client.payables
   */
  export type Client$payablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    where?: PayableWhereInput
    orderBy?: PayableOrderByWithRelationInput | PayableOrderByWithRelationInput[]
    cursor?: PayableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayableScalarFieldEnum | PayableScalarFieldEnum[]
  }

  /**
   * Client.costs
   */
  export type Client$costsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    where?: CostWhereInput
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    cursor?: CostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    startAt: Date | null
    endAt: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    salonId: string | null
    clientId: string | null
    serviceId: string | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    startAt: Date | null
    endAt: Date | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    salonId: string | null
    clientId: string | null
    serviceId: string | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    startAt: number
    endAt: number
    status: number
    notes: number
    createdAt: number
    salonId: number
    clientId: number
    serviceId: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    startAt?: true
    endAt?: true
    status?: true
    notes?: true
    createdAt?: true
    salonId?: true
    clientId?: true
    serviceId?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    startAt?: true
    endAt?: true
    status?: true
    notes?: true
    createdAt?: true
    salonId?: true
    clientId?: true
    serviceId?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    startAt?: true
    endAt?: true
    status?: true
    notes?: true
    createdAt?: true
    salonId?: true
    clientId?: true
    serviceId?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    startAt: Date
    endAt: Date
    status: string
    notes: string | null
    createdAt: Date
    salonId: string
    clientId: string
    serviceId: string
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    salonId?: boolean
    clientId?: boolean
    serviceId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    cashTransaction?: boolean | Appointment$cashTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    salonId?: boolean
    clientId?: boolean
    serviceId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    salonId?: boolean
    clientId?: boolean
    serviceId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    salonId?: boolean
    clientId?: boolean
    serviceId?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "startAt" | "endAt" | "status" | "notes" | "createdAt" | "salonId" | "clientId" | "serviceId", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    cashTransaction?: boolean | Appointment$cashTransactionArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      cashTransaction: Prisma.$CashTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      startAt: Date
      endAt: Date
      status: string
      notes: string | null
      createdAt: Date
      salonId: string
      clientId: string
      serviceId: string
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cashTransaction<T extends Appointment$cashTransactionArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$cashTransactionArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly startAt: FieldRef<"Appointment", 'DateTime'>
    readonly endAt: FieldRef<"Appointment", 'DateTime'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly salonId: FieldRef<"Appointment", 'String'>
    readonly clientId: FieldRef<"Appointment", 'String'>
    readonly serviceId: FieldRef<"Appointment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.cashTransaction
   */
  export type Appointment$cashTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model CashCategory
   */

  export type AggregateCashCategory = {
    _count: CashCategoryCountAggregateOutputType | null
    _min: CashCategoryMinAggregateOutputType | null
    _max: CashCategoryMaxAggregateOutputType | null
  }

  export type CashCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.CashType | null
    createdAt: Date | null
    salonId: string | null
  }

  export type CashCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.CashType | null
    createdAt: Date | null
    salonId: string | null
  }

  export type CashCategoryCountAggregateOutputType = {
    id: number
    name: number
    type: number
    createdAt: number
    salonId: number
    _all: number
  }


  export type CashCategoryMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    salonId?: true
  }

  export type CashCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    salonId?: true
  }

  export type CashCategoryCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    createdAt?: true
    salonId?: true
    _all?: true
  }

  export type CashCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashCategory to aggregate.
     */
    where?: CashCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCategories to fetch.
     */
    orderBy?: CashCategoryOrderByWithRelationInput | CashCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashCategories
    **/
    _count?: true | CashCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashCategoryMaxAggregateInputType
  }

  export type GetCashCategoryAggregateType<T extends CashCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCashCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashCategory[P]>
      : GetScalarType<T[P], AggregateCashCategory[P]>
  }




  export type CashCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashCategoryWhereInput
    orderBy?: CashCategoryOrderByWithAggregationInput | CashCategoryOrderByWithAggregationInput[]
    by: CashCategoryScalarFieldEnum[] | CashCategoryScalarFieldEnum
    having?: CashCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashCategoryCountAggregateInputType | true
    _min?: CashCategoryMinAggregateInputType
    _max?: CashCategoryMaxAggregateInputType
  }

  export type CashCategoryGroupByOutputType = {
    id: string
    name: string
    type: $Enums.CashType
    createdAt: Date
    salonId: string
    _count: CashCategoryCountAggregateOutputType | null
    _min: CashCategoryMinAggregateOutputType | null
    _max: CashCategoryMaxAggregateOutputType | null
  }

  type GetCashCategoryGroupByPayload<T extends CashCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CashCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CashCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    transactions?: boolean | CashCategory$transactionsArgs<ExtArgs>
    _count?: boolean | CashCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashCategory"]>

  export type CashCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashCategory"]>

  export type CashCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    salonId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cashCategory"]>

  export type CashCategorySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    createdAt?: boolean
    salonId?: boolean
  }

  export type CashCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "createdAt" | "salonId", ExtArgs["result"]["cashCategory"]>
  export type CashCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    transactions?: boolean | CashCategory$transactionsArgs<ExtArgs>
    _count?: boolean | CashCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CashCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }
  export type CashCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }

  export type $CashCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashCategory"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs>
      transactions: Prisma.$CashTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.CashType
      createdAt: Date
      salonId: string
    }, ExtArgs["result"]["cashCategory"]>
    composites: {}
  }

  type CashCategoryGetPayload<S extends boolean | null | undefined | CashCategoryDefaultArgs> = $Result.GetResult<Prisma.$CashCategoryPayload, S>

  type CashCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashCategoryCountAggregateInputType | true
    }

  export interface CashCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashCategory'], meta: { name: 'CashCategory' } }
    /**
     * Find zero or one CashCategory that matches the filter.
     * @param {CashCategoryFindUniqueArgs} args - Arguments to find a CashCategory
     * @example
     * // Get one CashCategory
     * const cashCategory = await prisma.cashCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashCategoryFindUniqueArgs>(args: SelectSubset<T, CashCategoryFindUniqueArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashCategoryFindUniqueOrThrowArgs} args - Arguments to find a CashCategory
     * @example
     * // Get one CashCategory
     * const cashCategory = await prisma.cashCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CashCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryFindFirstArgs} args - Arguments to find a CashCategory
     * @example
     * // Get one CashCategory
     * const cashCategory = await prisma.cashCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashCategoryFindFirstArgs>(args?: SelectSubset<T, CashCategoryFindFirstArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryFindFirstOrThrowArgs} args - Arguments to find a CashCategory
     * @example
     * // Get one CashCategory
     * const cashCategory = await prisma.cashCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CashCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashCategories
     * const cashCategories = await prisma.cashCategory.findMany()
     * 
     * // Get first 10 CashCategories
     * const cashCategories = await prisma.cashCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashCategoryWithIdOnly = await prisma.cashCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashCategoryFindManyArgs>(args?: SelectSubset<T, CashCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashCategory.
     * @param {CashCategoryCreateArgs} args - Arguments to create a CashCategory.
     * @example
     * // Create one CashCategory
     * const CashCategory = await prisma.cashCategory.create({
     *   data: {
     *     // ... data to create a CashCategory
     *   }
     * })
     * 
     */
    create<T extends CashCategoryCreateArgs>(args: SelectSubset<T, CashCategoryCreateArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashCategories.
     * @param {CashCategoryCreateManyArgs} args - Arguments to create many CashCategories.
     * @example
     * // Create many CashCategories
     * const cashCategory = await prisma.cashCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashCategoryCreateManyArgs>(args?: SelectSubset<T, CashCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashCategories and returns the data saved in the database.
     * @param {CashCategoryCreateManyAndReturnArgs} args - Arguments to create many CashCategories.
     * @example
     * // Create many CashCategories
     * const cashCategory = await prisma.cashCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashCategories and only return the `id`
     * const cashCategoryWithIdOnly = await prisma.cashCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CashCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashCategory.
     * @param {CashCategoryDeleteArgs} args - Arguments to delete one CashCategory.
     * @example
     * // Delete one CashCategory
     * const CashCategory = await prisma.cashCategory.delete({
     *   where: {
     *     // ... filter to delete one CashCategory
     *   }
     * })
     * 
     */
    delete<T extends CashCategoryDeleteArgs>(args: SelectSubset<T, CashCategoryDeleteArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashCategory.
     * @param {CashCategoryUpdateArgs} args - Arguments to update one CashCategory.
     * @example
     * // Update one CashCategory
     * const cashCategory = await prisma.cashCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashCategoryUpdateArgs>(args: SelectSubset<T, CashCategoryUpdateArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashCategories.
     * @param {CashCategoryDeleteManyArgs} args - Arguments to filter CashCategories to delete.
     * @example
     * // Delete a few CashCategories
     * const { count } = await prisma.cashCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashCategoryDeleteManyArgs>(args?: SelectSubset<T, CashCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashCategories
     * const cashCategory = await prisma.cashCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashCategoryUpdateManyArgs>(args: SelectSubset<T, CashCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashCategories and returns the data updated in the database.
     * @param {CashCategoryUpdateManyAndReturnArgs} args - Arguments to update many CashCategories.
     * @example
     * // Update many CashCategories
     * const cashCategory = await prisma.cashCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashCategories and only return the `id`
     * const cashCategoryWithIdOnly = await prisma.cashCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CashCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashCategory.
     * @param {CashCategoryUpsertArgs} args - Arguments to update or create a CashCategory.
     * @example
     * // Update or create a CashCategory
     * const cashCategory = await prisma.cashCategory.upsert({
     *   create: {
     *     // ... data to create a CashCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashCategory we want to update
     *   }
     * })
     */
    upsert<T extends CashCategoryUpsertArgs>(args: SelectSubset<T, CashCategoryUpsertArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryCountArgs} args - Arguments to filter CashCategories to count.
     * @example
     * // Count the number of CashCategories
     * const count = await prisma.cashCategory.count({
     *   where: {
     *     // ... the filter for the CashCategories we want to count
     *   }
     * })
    **/
    count<T extends CashCategoryCountArgs>(
      args?: Subset<T, CashCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashCategoryAggregateArgs>(args: Subset<T, CashCategoryAggregateArgs>): Prisma.PrismaPromise<GetCashCategoryAggregateType<T>>

    /**
     * Group by CashCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CashCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashCategory model
   */
  readonly fields: CashCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transactions<T extends CashCategory$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, CashCategory$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashCategory model
   */
  interface CashCategoryFieldRefs {
    readonly id: FieldRef<"CashCategory", 'String'>
    readonly name: FieldRef<"CashCategory", 'String'>
    readonly type: FieldRef<"CashCategory", 'CashType'>
    readonly createdAt: FieldRef<"CashCategory", 'DateTime'>
    readonly salonId: FieldRef<"CashCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CashCategory findUnique
   */
  export type CashCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CashCategory to fetch.
     */
    where: CashCategoryWhereUniqueInput
  }

  /**
   * CashCategory findUniqueOrThrow
   */
  export type CashCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CashCategory to fetch.
     */
    where: CashCategoryWhereUniqueInput
  }

  /**
   * CashCategory findFirst
   */
  export type CashCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CashCategory to fetch.
     */
    where?: CashCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCategories to fetch.
     */
    orderBy?: CashCategoryOrderByWithRelationInput | CashCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashCategories.
     */
    cursor?: CashCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashCategories.
     */
    distinct?: CashCategoryScalarFieldEnum | CashCategoryScalarFieldEnum[]
  }

  /**
   * CashCategory findFirstOrThrow
   */
  export type CashCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CashCategory to fetch.
     */
    where?: CashCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCategories to fetch.
     */
    orderBy?: CashCategoryOrderByWithRelationInput | CashCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashCategories.
     */
    cursor?: CashCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashCategories.
     */
    distinct?: CashCategoryScalarFieldEnum | CashCategoryScalarFieldEnum[]
  }

  /**
   * CashCategory findMany
   */
  export type CashCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CashCategories to fetch.
     */
    where?: CashCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashCategories to fetch.
     */
    orderBy?: CashCategoryOrderByWithRelationInput | CashCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashCategories.
     */
    cursor?: CashCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashCategories.
     */
    skip?: number
    distinct?: CashCategoryScalarFieldEnum | CashCategoryScalarFieldEnum[]
  }

  /**
   * CashCategory create
   */
  export type CashCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CashCategory.
     */
    data: XOR<CashCategoryCreateInput, CashCategoryUncheckedCreateInput>
  }

  /**
   * CashCategory createMany
   */
  export type CashCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashCategories.
     */
    data: CashCategoryCreateManyInput | CashCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashCategory createManyAndReturn
   */
  export type CashCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many CashCategories.
     */
    data: CashCategoryCreateManyInput | CashCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashCategory update
   */
  export type CashCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CashCategory.
     */
    data: XOR<CashCategoryUpdateInput, CashCategoryUncheckedUpdateInput>
    /**
     * Choose, which CashCategory to update.
     */
    where: CashCategoryWhereUniqueInput
  }

  /**
   * CashCategory updateMany
   */
  export type CashCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashCategories.
     */
    data: XOR<CashCategoryUpdateManyMutationInput, CashCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CashCategories to update
     */
    where?: CashCategoryWhereInput
    /**
     * Limit how many CashCategories to update.
     */
    limit?: number
  }

  /**
   * CashCategory updateManyAndReturn
   */
  export type CashCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * The data used to update CashCategories.
     */
    data: XOR<CashCategoryUpdateManyMutationInput, CashCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CashCategories to update
     */
    where?: CashCategoryWhereInput
    /**
     * Limit how many CashCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashCategory upsert
   */
  export type CashCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CashCategory to update in case it exists.
     */
    where: CashCategoryWhereUniqueInput
    /**
     * In case the CashCategory found by the `where` argument doesn't exist, create a new CashCategory with this data.
     */
    create: XOR<CashCategoryCreateInput, CashCategoryUncheckedCreateInput>
    /**
     * In case the CashCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashCategoryUpdateInput, CashCategoryUncheckedUpdateInput>
  }

  /**
   * CashCategory delete
   */
  export type CashCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    /**
     * Filter which CashCategory to delete.
     */
    where: CashCategoryWhereUniqueInput
  }

  /**
   * CashCategory deleteMany
   */
  export type CashCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashCategories to delete
     */
    where?: CashCategoryWhereInput
    /**
     * Limit how many CashCategories to delete.
     */
    limit?: number
  }

  /**
   * CashCategory.transactions
   */
  export type CashCategory$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    cursor?: CashTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashCategory without action
   */
  export type CashCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
  }


  /**
   * Model CashTransaction
   */

  export type AggregateCashTransaction = {
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  export type CashTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type CashTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type CashTransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.CashType | null
    source: $Enums.CashSource | null
    amount: number | null
    occurredAt: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    salonId: string | null
    categoryId: string | null
    appointmentId: string | null
  }

  export type CashTransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.CashType | null
    source: $Enums.CashSource | null
    amount: number | null
    occurredAt: Date | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    salonId: string | null
    categoryId: string | null
    appointmentId: string | null
  }

  export type CashTransactionCountAggregateOutputType = {
    id: number
    type: number
    source: number
    amount: number
    occurredAt: number
    description: number
    createdAt: number
    updatedAt: number
    salonId: number
    categoryId: number
    appointmentId: number
    _all: number
  }


  export type CashTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type CashTransactionSumAggregateInputType = {
    amount?: true
  }

  export type CashTransactionMinAggregateInputType = {
    id?: true
    type?: true
    source?: true
    amount?: true
    occurredAt?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    salonId?: true
    categoryId?: true
    appointmentId?: true
  }

  export type CashTransactionMaxAggregateInputType = {
    id?: true
    type?: true
    source?: true
    amount?: true
    occurredAt?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    salonId?: true
    categoryId?: true
    appointmentId?: true
  }

  export type CashTransactionCountAggregateInputType = {
    id?: true
    type?: true
    source?: true
    amount?: true
    occurredAt?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    salonId?: true
    categoryId?: true
    appointmentId?: true
    _all?: true
  }

  export type CashTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransaction to aggregate.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CashTransactions
    **/
    _count?: true | CashTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CashTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CashTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CashTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CashTransactionMaxAggregateInputType
  }

  export type GetCashTransactionAggregateType<T extends CashTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCashTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCashTransaction[P]>
      : GetScalarType<T[P], AggregateCashTransaction[P]>
  }




  export type CashTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CashTransactionWhereInput
    orderBy?: CashTransactionOrderByWithAggregationInput | CashTransactionOrderByWithAggregationInput[]
    by: CashTransactionScalarFieldEnum[] | CashTransactionScalarFieldEnum
    having?: CashTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CashTransactionCountAggregateInputType | true
    _avg?: CashTransactionAvgAggregateInputType
    _sum?: CashTransactionSumAggregateInputType
    _min?: CashTransactionMinAggregateInputType
    _max?: CashTransactionMaxAggregateInputType
  }

  export type CashTransactionGroupByOutputType = {
    id: string
    type: $Enums.CashType
    source: $Enums.CashSource
    amount: number
    occurredAt: Date
    description: string | null
    createdAt: Date
    updatedAt: Date
    salonId: string
    categoryId: string | null
    appointmentId: string | null
    _count: CashTransactionCountAggregateOutputType | null
    _avg: CashTransactionAvgAggregateOutputType | null
    _sum: CashTransactionSumAggregateOutputType | null
    _min: CashTransactionMinAggregateOutputType | null
    _max: CashTransactionMaxAggregateOutputType | null
  }

  type GetCashTransactionGroupByPayload<T extends CashTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CashTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CashTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CashTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CashTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source?: boolean
    amount?: boolean
    occurredAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salonId?: boolean
    categoryId?: boolean
    appointmentId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    category?: boolean | CashTransaction$categoryArgs<ExtArgs>
    appointment?: boolean | CashTransaction$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source?: boolean
    amount?: boolean
    occurredAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salonId?: boolean
    categoryId?: boolean
    appointmentId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    category?: boolean | CashTransaction$categoryArgs<ExtArgs>
    appointment?: boolean | CashTransaction$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    source?: boolean
    amount?: boolean
    occurredAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salonId?: boolean
    categoryId?: boolean
    appointmentId?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    category?: boolean | CashTransaction$categoryArgs<ExtArgs>
    appointment?: boolean | CashTransaction$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["cashTransaction"]>

  export type CashTransactionSelectScalar = {
    id?: boolean
    type?: boolean
    source?: boolean
    amount?: boolean
    occurredAt?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salonId?: boolean
    categoryId?: boolean
    appointmentId?: boolean
  }

  export type CashTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "source" | "amount" | "occurredAt" | "description" | "createdAt" | "updatedAt" | "salonId" | "categoryId" | "appointmentId", ExtArgs["result"]["cashTransaction"]>
  export type CashTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    category?: boolean | CashTransaction$categoryArgs<ExtArgs>
    appointment?: boolean | CashTransaction$appointmentArgs<ExtArgs>
  }
  export type CashTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    category?: boolean | CashTransaction$categoryArgs<ExtArgs>
    appointment?: boolean | CashTransaction$appointmentArgs<ExtArgs>
  }
  export type CashTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    category?: boolean | CashTransaction$categoryArgs<ExtArgs>
    appointment?: boolean | CashTransaction$appointmentArgs<ExtArgs>
  }

  export type $CashTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CashTransaction"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs>
      category: Prisma.$CashCategoryPayload<ExtArgs> | null
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.CashType
      source: $Enums.CashSource
      amount: number
      occurredAt: Date
      description: string | null
      createdAt: Date
      updatedAt: Date
      salonId: string
      categoryId: string | null
      appointmentId: string | null
    }, ExtArgs["result"]["cashTransaction"]>
    composites: {}
  }

  type CashTransactionGetPayload<S extends boolean | null | undefined | CashTransactionDefaultArgs> = $Result.GetResult<Prisma.$CashTransactionPayload, S>

  type CashTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CashTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CashTransactionCountAggregateInputType | true
    }

  export interface CashTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CashTransaction'], meta: { name: 'CashTransaction' } }
    /**
     * Find zero or one CashTransaction that matches the filter.
     * @param {CashTransactionFindUniqueArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CashTransactionFindUniqueArgs>(args: SelectSubset<T, CashTransactionFindUniqueArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CashTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CashTransactionFindUniqueOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CashTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CashTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CashTransactionFindFirstArgs>(args?: SelectSubset<T, CashTransactionFindFirstArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CashTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindFirstOrThrowArgs} args - Arguments to find a CashTransaction
     * @example
     * // Get one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CashTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CashTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CashTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany()
     * 
     * // Get first 10 CashTransactions
     * const cashTransactions = await prisma.cashTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CashTransactionFindManyArgs>(args?: SelectSubset<T, CashTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CashTransaction.
     * @param {CashTransactionCreateArgs} args - Arguments to create a CashTransaction.
     * @example
     * // Create one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.create({
     *   data: {
     *     // ... data to create a CashTransaction
     *   }
     * })
     * 
     */
    create<T extends CashTransactionCreateArgs>(args: SelectSubset<T, CashTransactionCreateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CashTransactions.
     * @param {CashTransactionCreateManyArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CashTransactionCreateManyArgs>(args?: SelectSubset<T, CashTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CashTransactions and returns the data saved in the database.
     * @param {CashTransactionCreateManyAndReturnArgs} args - Arguments to create many CashTransactions.
     * @example
     * // Create many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CashTransactions and only return the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CashTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CashTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CashTransaction.
     * @param {CashTransactionDeleteArgs} args - Arguments to delete one CashTransaction.
     * @example
     * // Delete one CashTransaction
     * const CashTransaction = await prisma.cashTransaction.delete({
     *   where: {
     *     // ... filter to delete one CashTransaction
     *   }
     * })
     * 
     */
    delete<T extends CashTransactionDeleteArgs>(args: SelectSubset<T, CashTransactionDeleteArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CashTransaction.
     * @param {CashTransactionUpdateArgs} args - Arguments to update one CashTransaction.
     * @example
     * // Update one CashTransaction
     * const cashTransaction = await prisma.cashTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CashTransactionUpdateArgs>(args: SelectSubset<T, CashTransactionUpdateArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CashTransactions.
     * @param {CashTransactionDeleteManyArgs} args - Arguments to filter CashTransactions to delete.
     * @example
     * // Delete a few CashTransactions
     * const { count } = await prisma.cashTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CashTransactionDeleteManyArgs>(args?: SelectSubset<T, CashTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CashTransactionUpdateManyArgs>(args: SelectSubset<T, CashTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CashTransactions and returns the data updated in the database.
     * @param {CashTransactionUpdateManyAndReturnArgs} args - Arguments to update many CashTransactions.
     * @example
     * // Update many CashTransactions
     * const cashTransaction = await prisma.cashTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CashTransactions and only return the `id`
     * const cashTransactionWithIdOnly = await prisma.cashTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CashTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CashTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CashTransaction.
     * @param {CashTransactionUpsertArgs} args - Arguments to update or create a CashTransaction.
     * @example
     * // Update or create a CashTransaction
     * const cashTransaction = await prisma.cashTransaction.upsert({
     *   create: {
     *     // ... data to create a CashTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CashTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CashTransactionUpsertArgs>(args: SelectSubset<T, CashTransactionUpsertArgs<ExtArgs>>): Prisma__CashTransactionClient<$Result.GetResult<Prisma.$CashTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CashTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionCountArgs} args - Arguments to filter CashTransactions to count.
     * @example
     * // Count the number of CashTransactions
     * const count = await prisma.cashTransaction.count({
     *   where: {
     *     // ... the filter for the CashTransactions we want to count
     *   }
     * })
    **/
    count<T extends CashTransactionCountArgs>(
      args?: Subset<T, CashTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CashTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CashTransactionAggregateArgs>(args: Subset<T, CashTransactionAggregateArgs>): Prisma.PrismaPromise<GetCashTransactionAggregateType<T>>

    /**
     * Group by CashTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CashTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CashTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CashTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CashTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CashTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCashTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CashTransaction model
   */
  readonly fields: CashTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CashTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CashTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends CashTransaction$categoryArgs<ExtArgs> = {}>(args?: Subset<T, CashTransaction$categoryArgs<ExtArgs>>): Prisma__CashCategoryClient<$Result.GetResult<Prisma.$CashCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    appointment<T extends CashTransaction$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, CashTransaction$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CashTransaction model
   */
  interface CashTransactionFieldRefs {
    readonly id: FieldRef<"CashTransaction", 'String'>
    readonly type: FieldRef<"CashTransaction", 'CashType'>
    readonly source: FieldRef<"CashTransaction", 'CashSource'>
    readonly amount: FieldRef<"CashTransaction", 'Int'>
    readonly occurredAt: FieldRef<"CashTransaction", 'DateTime'>
    readonly description: FieldRef<"CashTransaction", 'String'>
    readonly createdAt: FieldRef<"CashTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"CashTransaction", 'DateTime'>
    readonly salonId: FieldRef<"CashTransaction", 'String'>
    readonly categoryId: FieldRef<"CashTransaction", 'String'>
    readonly appointmentId: FieldRef<"CashTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CashTransaction findUnique
   */
  export type CashTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findUniqueOrThrow
   */
  export type CashTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction findFirst
   */
  export type CashTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findFirstOrThrow
   */
  export type CashTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransaction to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CashTransactions.
     */
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction findMany
   */
  export type CashTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CashTransactions to fetch.
     */
    where?: CashTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CashTransactions to fetch.
     */
    orderBy?: CashTransactionOrderByWithRelationInput | CashTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CashTransactions.
     */
    cursor?: CashTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CashTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CashTransactions.
     */
    skip?: number
    distinct?: CashTransactionScalarFieldEnum | CashTransactionScalarFieldEnum[]
  }

  /**
   * CashTransaction create
   */
  export type CashTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CashTransaction.
     */
    data: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
  }

  /**
   * CashTransaction createMany
   */
  export type CashTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CashTransaction createManyAndReturn
   */
  export type CashTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many CashTransactions.
     */
    data: CashTransactionCreateManyInput | CashTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashTransaction update
   */
  export type CashTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CashTransaction.
     */
    data: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
    /**
     * Choose, which CashTransaction to update.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction updateMany
   */
  export type CashTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CashTransactions.
     */
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CashTransactions to update
     */
    where?: CashTransactionWhereInput
    /**
     * Limit how many CashTransactions to update.
     */
    limit?: number
  }

  /**
   * CashTransaction updateManyAndReturn
   */
  export type CashTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * The data used to update CashTransactions.
     */
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CashTransactions to update
     */
    where?: CashTransactionWhereInput
    /**
     * Limit how many CashTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CashTransaction upsert
   */
  export type CashTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CashTransaction to update in case it exists.
     */
    where: CashTransactionWhereUniqueInput
    /**
     * In case the CashTransaction found by the `where` argument doesn't exist, create a new CashTransaction with this data.
     */
    create: XOR<CashTransactionCreateInput, CashTransactionUncheckedCreateInput>
    /**
     * In case the CashTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CashTransactionUpdateInput, CashTransactionUncheckedUpdateInput>
  }

  /**
   * CashTransaction delete
   */
  export type CashTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
    /**
     * Filter which CashTransaction to delete.
     */
    where: CashTransactionWhereUniqueInput
  }

  /**
   * CashTransaction deleteMany
   */
  export type CashTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CashTransactions to delete
     */
    where?: CashTransactionWhereInput
    /**
     * Limit how many CashTransactions to delete.
     */
    limit?: number
  }

  /**
   * CashTransaction.category
   */
  export type CashTransaction$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashCategory
     */
    select?: CashCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashCategory
     */
    omit?: CashCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashCategoryInclude<ExtArgs> | null
    where?: CashCategoryWhereInput
  }

  /**
   * CashTransaction.appointment
   */
  export type CashTransaction$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * CashTransaction without action
   */
  export type CashTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CashTransaction
     */
    select?: CashTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CashTransaction
     */
    omit?: CashTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CashTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    subtotalCents: number | null
    discountCents: number | null
    totalCents: number | null
    installmentsCount: number | null
  }

  export type OrderSumAggregateOutputType = {
    subtotalCents: number | null
    discountCents: number | null
    totalCents: number | null
    installmentsCount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    salonId: string | null
    subtotalCents: number | null
    discountCents: number | null
    totalCents: number | null
    paymentMode: $Enums.PaymentMode | null
    paymentMethod: $Enums.PaymentMethod | null
    installmentsCount: number | null
    firstDueDate: Date | null
    expectedDeliveryAt: Date | null
    deliveredAt: Date | null
    notes: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    status: $Enums.OrderStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: string | null
    salonId: string | null
    subtotalCents: number | null
    discountCents: number | null
    totalCents: number | null
    paymentMode: $Enums.PaymentMode | null
    paymentMethod: $Enums.PaymentMethod | null
    installmentsCount: number | null
    firstDueDate: Date | null
    expectedDeliveryAt: Date | null
    deliveredAt: Date | null
    notes: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    status: number
    createdAt: number
    updatedAt: number
    clientId: number
    salonId: number
    subtotalCents: number
    discountCents: number
    totalCents: number
    paymentMode: number
    paymentMethod: number
    installmentsCount: number
    firstDueDate: number
    expectedDeliveryAt: number
    deliveredAt: number
    notes: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    subtotalCents?: true
    discountCents?: true
    totalCents?: true
    installmentsCount?: true
  }

  export type OrderSumAggregateInputType = {
    subtotalCents?: true
    discountCents?: true
    totalCents?: true
    installmentsCount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    salonId?: true
    subtotalCents?: true
    discountCents?: true
    totalCents?: true
    paymentMode?: true
    paymentMethod?: true
    installmentsCount?: true
    firstDueDate?: true
    expectedDeliveryAt?: true
    deliveredAt?: true
    notes?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    salonId?: true
    subtotalCents?: true
    discountCents?: true
    totalCents?: true
    paymentMode?: true
    paymentMethod?: true
    installmentsCount?: true
    firstDueDate?: true
    expectedDeliveryAt?: true
    deliveredAt?: true
    notes?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    salonId?: true
    subtotalCents?: true
    discountCents?: true
    totalCents?: true
    paymentMode?: true
    paymentMethod?: true
    installmentsCount?: true
    firstDueDate?: true
    expectedDeliveryAt?: true
    deliveredAt?: true
    notes?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    status: $Enums.OrderStatus
    createdAt: Date
    updatedAt: Date
    clientId: string
    salonId: string
    subtotalCents: number
    discountCents: number
    totalCents: number
    paymentMode: $Enums.PaymentMode
    paymentMethod: $Enums.PaymentMethod | null
    installmentsCount: number
    firstDueDate: Date | null
    expectedDeliveryAt: Date | null
    deliveredAt: Date | null
    notes: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    salonId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    totalCents?: boolean
    paymentMode?: boolean
    paymentMethod?: boolean
    installmentsCount?: boolean
    firstDueDate?: boolean
    expectedDeliveryAt?: boolean
    deliveredAt?: boolean
    notes?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    deliveries?: boolean | Order$deliveriesArgs<ExtArgs>
    receivables?: boolean | Order$receivablesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    salonId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    totalCents?: boolean
    paymentMode?: boolean
    paymentMethod?: boolean
    installmentsCount?: boolean
    firstDueDate?: boolean
    expectedDeliveryAt?: boolean
    deliveredAt?: boolean
    notes?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    salonId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    totalCents?: boolean
    paymentMode?: boolean
    paymentMethod?: boolean
    installmentsCount?: boolean
    firstDueDate?: boolean
    expectedDeliveryAt?: boolean
    deliveredAt?: boolean
    notes?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    salonId?: boolean
    subtotalCents?: boolean
    discountCents?: boolean
    totalCents?: boolean
    paymentMode?: boolean
    paymentMethod?: boolean
    installmentsCount?: boolean
    firstDueDate?: boolean
    expectedDeliveryAt?: boolean
    deliveredAt?: boolean
    notes?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "createdAt" | "updatedAt" | "clientId" | "salonId" | "subtotalCents" | "discountCents" | "totalCents" | "paymentMode" | "paymentMethod" | "installmentsCount" | "firstDueDate" | "expectedDeliveryAt" | "deliveredAt" | "notes", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    deliveries?: boolean | Order$deliveriesArgs<ExtArgs>
    receivables?: boolean | Order$receivablesArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      salon: Prisma.$SalonPayload<ExtArgs>
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      deliveries: Prisma.$DeliveryPayload<ExtArgs>[]
      receivables: Prisma.$ReceivablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.OrderStatus
      createdAt: Date
      updatedAt: Date
      clientId: string
      salonId: string
      subtotalCents: number
      discountCents: number
      totalCents: number
      paymentMode: $Enums.PaymentMode
      paymentMethod: $Enums.PaymentMethod | null
      installmentsCount: number
      firstDueDate: Date | null
      expectedDeliveryAt: Date | null
      deliveredAt: Date | null
      notes: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deliveries<T extends Order$deliveriesArgs<ExtArgs> = {}>(args?: Subset<T, Order$deliveriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivables<T extends Order$receivablesArgs<ExtArgs> = {}>(args?: Subset<T, Order$receivablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly clientId: FieldRef<"Order", 'String'>
    readonly salonId: FieldRef<"Order", 'String'>
    readonly subtotalCents: FieldRef<"Order", 'Int'>
    readonly discountCents: FieldRef<"Order", 'Int'>
    readonly totalCents: FieldRef<"Order", 'Int'>
    readonly paymentMode: FieldRef<"Order", 'PaymentMode'>
    readonly paymentMethod: FieldRef<"Order", 'PaymentMethod'>
    readonly installmentsCount: FieldRef<"Order", 'Int'>
    readonly firstDueDate: FieldRef<"Order", 'DateTime'>
    readonly expectedDeliveryAt: FieldRef<"Order", 'DateTime'>
    readonly deliveredAt: FieldRef<"Order", 'DateTime'>
    readonly notes: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.deliveries
   */
  export type Order$deliveriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    cursor?: DeliveryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Order.receivables
   */
  export type Order$receivablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    where?: ReceivableWhereInput
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    cursor?: ReceivableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPriceCents: number | null
    totalCents: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPriceCents: number | null
    totalCents: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    name: string | null
    description: string | null
    quantity: number | null
    unitPriceCents: number | null
    totalCents: number | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    name: string | null
    description: string | null
    quantity: number | null
    unitPriceCents: number | null
    totalCents: number | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    name: number
    description: number
    quantity: number
    unitPriceCents: number
    totalCents: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    unitPriceCents?: true
    totalCents?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    unitPriceCents?: true
    totalCents?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    name?: true
    description?: true
    quantity?: true
    unitPriceCents?: true
    totalCents?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    name?: true
    description?: true
    quantity?: true
    unitPriceCents?: true
    totalCents?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    name?: true
    description?: true
    quantity?: true
    unitPriceCents?: true
    totalCents?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    name: string
    description: string | null
    quantity: number
    unitPriceCents: number
    totalCents: number
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    totalCents?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    totalCents?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    totalCents?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    name?: boolean
    description?: boolean
    quantity?: boolean
    unitPriceCents?: boolean
    totalCents?: boolean
    createdAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "name" | "description" | "quantity" | "unitPriceCents" | "totalCents" | "createdAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      name: string
      description: string | null
      quantity: number
      unitPriceCents: number
      totalCents: number
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly name: FieldRef<"OrderItem", 'String'>
    readonly description: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPriceCents: FieldRef<"OrderItem", 'Int'>
    readonly totalCents: FieldRef<"OrderItem", 'Int'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model Delivery
   */

  export type AggregateDelivery = {
    _count: DeliveryCountAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  export type DeliveryMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    status: $Enums.DeliveryStatus | null
    expectedAt: Date | null
    deliveredAt: Date | null
    address: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    status: $Enums.DeliveryStatus | null
    expectedAt: Date | null
    deliveredAt: Date | null
    address: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeliveryCountAggregateOutputType = {
    id: number
    orderId: number
    status: number
    expectedAt: number
    deliveredAt: number
    address: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeliveryMinAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    expectedAt?: true
    deliveredAt?: true
    address?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryMaxAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    expectedAt?: true
    deliveredAt?: true
    address?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeliveryCountAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    expectedAt?: true
    deliveredAt?: true
    address?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeliveryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Delivery to aggregate.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deliveries
    **/
    _count?: true | DeliveryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryMaxAggregateInputType
  }

  export type GetDeliveryAggregateType<T extends DeliveryAggregateArgs> = {
        [P in keyof T & keyof AggregateDelivery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelivery[P]>
      : GetScalarType<T[P], AggregateDelivery[P]>
  }




  export type DeliveryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryWhereInput
    orderBy?: DeliveryOrderByWithAggregationInput | DeliveryOrderByWithAggregationInput[]
    by: DeliveryScalarFieldEnum[] | DeliveryScalarFieldEnum
    having?: DeliveryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryCountAggregateInputType | true
    _min?: DeliveryMinAggregateInputType
    _max?: DeliveryMaxAggregateInputType
  }

  export type DeliveryGroupByOutputType = {
    id: string
    orderId: string
    status: $Enums.DeliveryStatus
    expectedAt: Date | null
    deliveredAt: Date | null
    address: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DeliveryCountAggregateOutputType | null
    _min: DeliveryMinAggregateOutputType | null
    _max: DeliveryMaxAggregateOutputType | null
  }

  type GetDeliveryGroupByPayload<T extends DeliveryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryGroupByOutputType[P]>
        }
      >
    >


  export type DeliverySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    expectedAt?: boolean
    deliveredAt?: boolean
    address?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    expectedAt?: boolean
    deliveredAt?: boolean
    address?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    expectedAt?: boolean
    deliveredAt?: boolean
    address?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delivery"]>

  export type DeliverySelectScalar = {
    id?: boolean
    orderId?: boolean
    status?: boolean
    expectedAt?: boolean
    deliveredAt?: boolean
    address?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeliveryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "status" | "expectedAt" | "deliveredAt" | "address" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["delivery"]>
  export type DeliveryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type DeliveryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $DeliveryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Delivery"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      status: $Enums.DeliveryStatus
      expectedAt: Date | null
      deliveredAt: Date | null
      address: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["delivery"]>
    composites: {}
  }

  type DeliveryGetPayload<S extends boolean | null | undefined | DeliveryDefaultArgs> = $Result.GetResult<Prisma.$DeliveryPayload, S>

  type DeliveryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryCountAggregateInputType | true
    }

  export interface DeliveryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Delivery'], meta: { name: 'Delivery' } }
    /**
     * Find zero or one Delivery that matches the filter.
     * @param {DeliveryFindUniqueArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryFindUniqueArgs>(args: SelectSubset<T, DeliveryFindUniqueArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Delivery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryFindUniqueOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryFindFirstArgs>(args?: SelectSubset<T, DeliveryFindFirstArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Delivery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindFirstOrThrowArgs} args - Arguments to find a Delivery
     * @example
     * // Get one Delivery
     * const delivery = await prisma.delivery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deliveries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deliveries
     * const deliveries = await prisma.delivery.findMany()
     * 
     * // Get first 10 Deliveries
     * const deliveries = await prisma.delivery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryWithIdOnly = await prisma.delivery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryFindManyArgs>(args?: SelectSubset<T, DeliveryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Delivery.
     * @param {DeliveryCreateArgs} args - Arguments to create a Delivery.
     * @example
     * // Create one Delivery
     * const Delivery = await prisma.delivery.create({
     *   data: {
     *     // ... data to create a Delivery
     *   }
     * })
     * 
     */
    create<T extends DeliveryCreateArgs>(args: SelectSubset<T, DeliveryCreateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deliveries.
     * @param {DeliveryCreateManyArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryCreateManyArgs>(args?: SelectSubset<T, DeliveryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deliveries and returns the data saved in the database.
     * @param {DeliveryCreateManyAndReturnArgs} args - Arguments to create many Deliveries.
     * @example
     * // Create many Deliveries
     * const delivery = await prisma.delivery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Delivery.
     * @param {DeliveryDeleteArgs} args - Arguments to delete one Delivery.
     * @example
     * // Delete one Delivery
     * const Delivery = await prisma.delivery.delete({
     *   where: {
     *     // ... filter to delete one Delivery
     *   }
     * })
     * 
     */
    delete<T extends DeliveryDeleteArgs>(args: SelectSubset<T, DeliveryDeleteArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Delivery.
     * @param {DeliveryUpdateArgs} args - Arguments to update one Delivery.
     * @example
     * // Update one Delivery
     * const delivery = await prisma.delivery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryUpdateArgs>(args: SelectSubset<T, DeliveryUpdateArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deliveries.
     * @param {DeliveryDeleteManyArgs} args - Arguments to filter Deliveries to delete.
     * @example
     * // Delete a few Deliveries
     * const { count } = await prisma.delivery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryDeleteManyArgs>(args?: SelectSubset<T, DeliveryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryUpdateManyArgs>(args: SelectSubset<T, DeliveryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deliveries and returns the data updated in the database.
     * @param {DeliveryUpdateManyAndReturnArgs} args - Arguments to update many Deliveries.
     * @example
     * // Update many Deliveries
     * const delivery = await prisma.delivery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deliveries and only return the `id`
     * const deliveryWithIdOnly = await prisma.delivery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Delivery.
     * @param {DeliveryUpsertArgs} args - Arguments to update or create a Delivery.
     * @example
     * // Update or create a Delivery
     * const delivery = await prisma.delivery.upsert({
     *   create: {
     *     // ... data to create a Delivery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Delivery we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryUpsertArgs>(args: SelectSubset<T, DeliveryUpsertArgs<ExtArgs>>): Prisma__DeliveryClient<$Result.GetResult<Prisma.$DeliveryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deliveries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryCountArgs} args - Arguments to filter Deliveries to count.
     * @example
     * // Count the number of Deliveries
     * const count = await prisma.delivery.count({
     *   where: {
     *     // ... the filter for the Deliveries we want to count
     *   }
     * })
    **/
    count<T extends DeliveryCountArgs>(
      args?: Subset<T, DeliveryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryAggregateArgs>(args: Subset<T, DeliveryAggregateArgs>): Prisma.PrismaPromise<GetDeliveryAggregateType<T>>

    /**
     * Group by Delivery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Delivery model
   */
  readonly fields: DeliveryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Delivery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Delivery model
   */
  interface DeliveryFieldRefs {
    readonly id: FieldRef<"Delivery", 'String'>
    readonly orderId: FieldRef<"Delivery", 'String'>
    readonly status: FieldRef<"Delivery", 'DeliveryStatus'>
    readonly expectedAt: FieldRef<"Delivery", 'DateTime'>
    readonly deliveredAt: FieldRef<"Delivery", 'DateTime'>
    readonly address: FieldRef<"Delivery", 'String'>
    readonly notes: FieldRef<"Delivery", 'String'>
    readonly createdAt: FieldRef<"Delivery", 'DateTime'>
    readonly updatedAt: FieldRef<"Delivery", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Delivery findUnique
   */
  export type DeliveryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findUniqueOrThrow
   */
  export type DeliveryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery findFirst
   */
  export type DeliveryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findFirstOrThrow
   */
  export type DeliveryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Delivery to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deliveries.
     */
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery findMany
   */
  export type DeliveryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter, which Deliveries to fetch.
     */
    where?: DeliveryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deliveries to fetch.
     */
    orderBy?: DeliveryOrderByWithRelationInput | DeliveryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deliveries.
     */
    cursor?: DeliveryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deliveries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deliveries.
     */
    skip?: number
    distinct?: DeliveryScalarFieldEnum | DeliveryScalarFieldEnum[]
  }

  /**
   * Delivery create
   */
  export type DeliveryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to create a Delivery.
     */
    data: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
  }

  /**
   * Delivery createMany
   */
  export type DeliveryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Delivery createManyAndReturn
   */
  export type DeliveryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to create many Deliveries.
     */
    data: DeliveryCreateManyInput | DeliveryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery update
   */
  export type DeliveryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The data needed to update a Delivery.
     */
    data: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
    /**
     * Choose, which Delivery to update.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery updateMany
   */
  export type DeliveryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
  }

  /**
   * Delivery updateManyAndReturn
   */
  export type DeliveryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * The data used to update Deliveries.
     */
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyInput>
    /**
     * Filter which Deliveries to update
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Delivery upsert
   */
  export type DeliveryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * The filter to search for the Delivery to update in case it exists.
     */
    where: DeliveryWhereUniqueInput
    /**
     * In case the Delivery found by the `where` argument doesn't exist, create a new Delivery with this data.
     */
    create: XOR<DeliveryCreateInput, DeliveryUncheckedCreateInput>
    /**
     * In case the Delivery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryUpdateInput, DeliveryUncheckedUpdateInput>
  }

  /**
   * Delivery delete
   */
  export type DeliveryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
    /**
     * Filter which Delivery to delete.
     */
    where: DeliveryWhereUniqueInput
  }

  /**
   * Delivery deleteMany
   */
  export type DeliveryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deliveries to delete
     */
    where?: DeliveryWhereInput
    /**
     * Limit how many Deliveries to delete.
     */
    limit?: number
  }

  /**
   * Delivery without action
   */
  export type DeliveryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Delivery
     */
    select?: DeliverySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Delivery
     */
    omit?: DeliveryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryInclude<ExtArgs> | null
  }


  /**
   * Model Receivable
   */

  export type AggregateReceivable = {
    _count: ReceivableCountAggregateOutputType | null
    _avg: ReceivableAvgAggregateOutputType | null
    _sum: ReceivableSumAggregateOutputType | null
    _min: ReceivableMinAggregateOutputType | null
    _max: ReceivableMaxAggregateOutputType | null
  }

  export type ReceivableAvgAggregateOutputType = {
    totalCents: number | null
  }

  export type ReceivableSumAggregateOutputType = {
    totalCents: number | null
  }

  export type ReceivableMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    salonId: string | null
    totalCents: number | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceivableMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    salonId: string | null
    totalCents: number | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReceivableCountAggregateOutputType = {
    id: number
    orderId: number
    salonId: number
    totalCents: number
    method: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReceivableAvgAggregateInputType = {
    totalCents?: true
  }

  export type ReceivableSumAggregateInputType = {
    totalCents?: true
  }

  export type ReceivableMinAggregateInputType = {
    id?: true
    orderId?: true
    salonId?: true
    totalCents?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceivableMaxAggregateInputType = {
    id?: true
    orderId?: true
    salonId?: true
    totalCents?: true
    method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReceivableCountAggregateInputType = {
    id?: true
    orderId?: true
    salonId?: true
    totalCents?: true
    method?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReceivableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivable to aggregate.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Receivables
    **/
    _count?: true | ReceivableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivableMaxAggregateInputType
  }

  export type GetReceivableAggregateType<T extends ReceivableAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivable[P]>
      : GetScalarType<T[P], AggregateReceivable[P]>
  }




  export type ReceivableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableWhereInput
    orderBy?: ReceivableOrderByWithAggregationInput | ReceivableOrderByWithAggregationInput[]
    by: ReceivableScalarFieldEnum[] | ReceivableScalarFieldEnum
    having?: ReceivableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivableCountAggregateInputType | true
    _avg?: ReceivableAvgAggregateInputType
    _sum?: ReceivableSumAggregateInputType
    _min?: ReceivableMinAggregateInputType
    _max?: ReceivableMaxAggregateInputType
  }

  export type ReceivableGroupByOutputType = {
    id: string
    orderId: string
    salonId: string
    totalCents: number
    method: $Enums.PaymentMethod | null
    createdAt: Date
    updatedAt: Date
    _count: ReceivableCountAggregateOutputType | null
    _avg: ReceivableAvgAggregateOutputType | null
    _sum: ReceivableSumAggregateOutputType | null
    _min: ReceivableMinAggregateOutputType | null
    _max: ReceivableMaxAggregateOutputType | null
  }

  type GetReceivableGroupByPayload<T extends ReceivableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivableGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivableGroupByOutputType[P]>
        }
      >
    >


  export type ReceivableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    salonId?: boolean
    totalCents?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    installments?: boolean | Receivable$installmentsArgs<ExtArgs>
    _count?: boolean | ReceivableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivable"]>

  export type ReceivableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    salonId?: boolean
    totalCents?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivable"]>

  export type ReceivableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    salonId?: boolean
    totalCents?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivable"]>

  export type ReceivableSelectScalar = {
    id?: boolean
    orderId?: boolean
    salonId?: boolean
    totalCents?: boolean
    method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReceivableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "salonId" | "totalCents" | "method" | "createdAt" | "updatedAt", ExtArgs["result"]["receivable"]>
  export type ReceivableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    installments?: boolean | Receivable$installmentsArgs<ExtArgs>
    _count?: boolean | ReceivableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReceivableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }
  export type ReceivableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }

  export type $ReceivablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Receivable"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      salon: Prisma.$SalonPayload<ExtArgs>
      installments: Prisma.$ReceivableInstallmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      salonId: string
      totalCents: number
      method: $Enums.PaymentMethod | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["receivable"]>
    composites: {}
  }

  type ReceivableGetPayload<S extends boolean | null | undefined | ReceivableDefaultArgs> = $Result.GetResult<Prisma.$ReceivablePayload, S>

  type ReceivableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceivableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceivableCountAggregateInputType | true
    }

  export interface ReceivableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Receivable'], meta: { name: 'Receivable' } }
    /**
     * Find zero or one Receivable that matches the filter.
     * @param {ReceivableFindUniqueArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceivableFindUniqueArgs>(args: SelectSubset<T, ReceivableFindUniqueArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receivable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceivableFindUniqueOrThrowArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceivableFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceivableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receivable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableFindFirstArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceivableFindFirstArgs>(args?: SelectSubset<T, ReceivableFindFirstArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receivable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableFindFirstOrThrowArgs} args - Arguments to find a Receivable
     * @example
     * // Get one Receivable
     * const receivable = await prisma.receivable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceivableFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceivableFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receivables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receivables
     * const receivables = await prisma.receivable.findMany()
     * 
     * // Get first 10 Receivables
     * const receivables = await prisma.receivable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivableWithIdOnly = await prisma.receivable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceivableFindManyArgs>(args?: SelectSubset<T, ReceivableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receivable.
     * @param {ReceivableCreateArgs} args - Arguments to create a Receivable.
     * @example
     * // Create one Receivable
     * const Receivable = await prisma.receivable.create({
     *   data: {
     *     // ... data to create a Receivable
     *   }
     * })
     * 
     */
    create<T extends ReceivableCreateArgs>(args: SelectSubset<T, ReceivableCreateArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receivables.
     * @param {ReceivableCreateManyArgs} args - Arguments to create many Receivables.
     * @example
     * // Create many Receivables
     * const receivable = await prisma.receivable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceivableCreateManyArgs>(args?: SelectSubset<T, ReceivableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Receivables and returns the data saved in the database.
     * @param {ReceivableCreateManyAndReturnArgs} args - Arguments to create many Receivables.
     * @example
     * // Create many Receivables
     * const receivable = await prisma.receivable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Receivables and only return the `id`
     * const receivableWithIdOnly = await prisma.receivable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceivableCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceivableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Receivable.
     * @param {ReceivableDeleteArgs} args - Arguments to delete one Receivable.
     * @example
     * // Delete one Receivable
     * const Receivable = await prisma.receivable.delete({
     *   where: {
     *     // ... filter to delete one Receivable
     *   }
     * })
     * 
     */
    delete<T extends ReceivableDeleteArgs>(args: SelectSubset<T, ReceivableDeleteArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receivable.
     * @param {ReceivableUpdateArgs} args - Arguments to update one Receivable.
     * @example
     * // Update one Receivable
     * const receivable = await prisma.receivable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceivableUpdateArgs>(args: SelectSubset<T, ReceivableUpdateArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receivables.
     * @param {ReceivableDeleteManyArgs} args - Arguments to filter Receivables to delete.
     * @example
     * // Delete a few Receivables
     * const { count } = await prisma.receivable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceivableDeleteManyArgs>(args?: SelectSubset<T, ReceivableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receivables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receivables
     * const receivable = await prisma.receivable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceivableUpdateManyArgs>(args: SelectSubset<T, ReceivableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receivables and returns the data updated in the database.
     * @param {ReceivableUpdateManyAndReturnArgs} args - Arguments to update many Receivables.
     * @example
     * // Update many Receivables
     * const receivable = await prisma.receivable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Receivables and only return the `id`
     * const receivableWithIdOnly = await prisma.receivable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceivableUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceivableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Receivable.
     * @param {ReceivableUpsertArgs} args - Arguments to update or create a Receivable.
     * @example
     * // Update or create a Receivable
     * const receivable = await prisma.receivable.upsert({
     *   create: {
     *     // ... data to create a Receivable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receivable we want to update
     *   }
     * })
     */
    upsert<T extends ReceivableUpsertArgs>(args: SelectSubset<T, ReceivableUpsertArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receivables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableCountArgs} args - Arguments to filter Receivables to count.
     * @example
     * // Count the number of Receivables
     * const count = await prisma.receivable.count({
     *   where: {
     *     // ... the filter for the Receivables we want to count
     *   }
     * })
    **/
    count<T extends ReceivableCountArgs>(
      args?: Subset<T, ReceivableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receivable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivableAggregateArgs>(args: Subset<T, ReceivableAggregateArgs>): Prisma.PrismaPromise<GetReceivableAggregateType<T>>

    /**
     * Group by Receivable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivableGroupByArgs['orderBy'] }
        : { orderBy?: ReceivableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Receivable model
   */
  readonly fields: ReceivableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Receivable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    installments<T extends Receivable$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, Receivable$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Receivable model
   */
  interface ReceivableFieldRefs {
    readonly id: FieldRef<"Receivable", 'String'>
    readonly orderId: FieldRef<"Receivable", 'String'>
    readonly salonId: FieldRef<"Receivable", 'String'>
    readonly totalCents: FieldRef<"Receivable", 'Int'>
    readonly method: FieldRef<"Receivable", 'PaymentMethod'>
    readonly createdAt: FieldRef<"Receivable", 'DateTime'>
    readonly updatedAt: FieldRef<"Receivable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Receivable findUnique
   */
  export type ReceivableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable findUniqueOrThrow
   */
  export type ReceivableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable findFirst
   */
  export type ReceivableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivables.
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivables.
     */
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Receivable findFirstOrThrow
   */
  export type ReceivableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivable to fetch.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Receivables.
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Receivables.
     */
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Receivable findMany
   */
  export type ReceivableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter, which Receivables to fetch.
     */
    where?: ReceivableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Receivables to fetch.
     */
    orderBy?: ReceivableOrderByWithRelationInput | ReceivableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Receivables.
     */
    cursor?: ReceivableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Receivables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Receivables.
     */
    skip?: number
    distinct?: ReceivableScalarFieldEnum | ReceivableScalarFieldEnum[]
  }

  /**
   * Receivable create
   */
  export type ReceivableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * The data needed to create a Receivable.
     */
    data: XOR<ReceivableCreateInput, ReceivableUncheckedCreateInput>
  }

  /**
   * Receivable createMany
   */
  export type ReceivableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Receivables.
     */
    data: ReceivableCreateManyInput | ReceivableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Receivable createManyAndReturn
   */
  export type ReceivableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * The data used to create many Receivables.
     */
    data: ReceivableCreateManyInput | ReceivableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receivable update
   */
  export type ReceivableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * The data needed to update a Receivable.
     */
    data: XOR<ReceivableUpdateInput, ReceivableUncheckedUpdateInput>
    /**
     * Choose, which Receivable to update.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable updateMany
   */
  export type ReceivableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Receivables.
     */
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyInput>
    /**
     * Filter which Receivables to update
     */
    where?: ReceivableWhereInput
    /**
     * Limit how many Receivables to update.
     */
    limit?: number
  }

  /**
   * Receivable updateManyAndReturn
   */
  export type ReceivableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * The data used to update Receivables.
     */
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyInput>
    /**
     * Filter which Receivables to update
     */
    where?: ReceivableWhereInput
    /**
     * Limit how many Receivables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Receivable upsert
   */
  export type ReceivableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * The filter to search for the Receivable to update in case it exists.
     */
    where: ReceivableWhereUniqueInput
    /**
     * In case the Receivable found by the `where` argument doesn't exist, create a new Receivable with this data.
     */
    create: XOR<ReceivableCreateInput, ReceivableUncheckedCreateInput>
    /**
     * In case the Receivable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivableUpdateInput, ReceivableUncheckedUpdateInput>
  }

  /**
   * Receivable delete
   */
  export type ReceivableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
    /**
     * Filter which Receivable to delete.
     */
    where: ReceivableWhereUniqueInput
  }

  /**
   * Receivable deleteMany
   */
  export type ReceivableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Receivables to delete
     */
    where?: ReceivableWhereInput
    /**
     * Limit how many Receivables to delete.
     */
    limit?: number
  }

  /**
   * Receivable.installments
   */
  export type Receivable$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    where?: ReceivableInstallmentWhereInput
    orderBy?: ReceivableInstallmentOrderByWithRelationInput | ReceivableInstallmentOrderByWithRelationInput[]
    cursor?: ReceivableInstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReceivableInstallmentScalarFieldEnum | ReceivableInstallmentScalarFieldEnum[]
  }

  /**
   * Receivable without action
   */
  export type ReceivableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Receivable
     */
    select?: ReceivableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Receivable
     */
    omit?: ReceivableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInclude<ExtArgs> | null
  }


  /**
   * Model ReceivableInstallment
   */

  export type AggregateReceivableInstallment = {
    _count: ReceivableInstallmentCountAggregateOutputType | null
    _avg: ReceivableInstallmentAvgAggregateOutputType | null
    _sum: ReceivableInstallmentSumAggregateOutputType | null
    _min: ReceivableInstallmentMinAggregateOutputType | null
    _max: ReceivableInstallmentMaxAggregateOutputType | null
  }

  export type ReceivableInstallmentAvgAggregateOutputType = {
    number: number | null
    amountCents: number | null
  }

  export type ReceivableInstallmentSumAggregateOutputType = {
    number: number | null
    amountCents: number | null
  }

  export type ReceivableInstallmentMinAggregateOutputType = {
    id: string | null
    receivableId: string | null
    number: number | null
    dueDate: Date | null
    amountCents: number | null
    status: $Enums.InstallmentStatus | null
    paidAt: Date | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
  }

  export type ReceivableInstallmentMaxAggregateOutputType = {
    id: string | null
    receivableId: string | null
    number: number | null
    dueDate: Date | null
    amountCents: number | null
    status: $Enums.InstallmentStatus | null
    paidAt: Date | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
  }

  export type ReceivableInstallmentCountAggregateOutputType = {
    id: number
    receivableId: number
    number: number
    dueDate: number
    amountCents: number
    status: number
    paidAt: number
    method: number
    createdAt: number
    _all: number
  }


  export type ReceivableInstallmentAvgAggregateInputType = {
    number?: true
    amountCents?: true
  }

  export type ReceivableInstallmentSumAggregateInputType = {
    number?: true
    amountCents?: true
  }

  export type ReceivableInstallmentMinAggregateInputType = {
    id?: true
    receivableId?: true
    number?: true
    dueDate?: true
    amountCents?: true
    status?: true
    paidAt?: true
    method?: true
    createdAt?: true
  }

  export type ReceivableInstallmentMaxAggregateInputType = {
    id?: true
    receivableId?: true
    number?: true
    dueDate?: true
    amountCents?: true
    status?: true
    paidAt?: true
    method?: true
    createdAt?: true
  }

  export type ReceivableInstallmentCountAggregateInputType = {
    id?: true
    receivableId?: true
    number?: true
    dueDate?: true
    amountCents?: true
    status?: true
    paidAt?: true
    method?: true
    createdAt?: true
    _all?: true
  }

  export type ReceivableInstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceivableInstallment to aggregate.
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivableInstallments to fetch.
     */
    orderBy?: ReceivableInstallmentOrderByWithRelationInput | ReceivableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReceivableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivableInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReceivableInstallments
    **/
    _count?: true | ReceivableInstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceivableInstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceivableInstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceivableInstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceivableInstallmentMaxAggregateInputType
  }

  export type GetReceivableInstallmentAggregateType<T extends ReceivableInstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregateReceivableInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceivableInstallment[P]>
      : GetScalarType<T[P], AggregateReceivableInstallment[P]>
  }




  export type ReceivableInstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReceivableInstallmentWhereInput
    orderBy?: ReceivableInstallmentOrderByWithAggregationInput | ReceivableInstallmentOrderByWithAggregationInput[]
    by: ReceivableInstallmentScalarFieldEnum[] | ReceivableInstallmentScalarFieldEnum
    having?: ReceivableInstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceivableInstallmentCountAggregateInputType | true
    _avg?: ReceivableInstallmentAvgAggregateInputType
    _sum?: ReceivableInstallmentSumAggregateInputType
    _min?: ReceivableInstallmentMinAggregateInputType
    _max?: ReceivableInstallmentMaxAggregateInputType
  }

  export type ReceivableInstallmentGroupByOutputType = {
    id: string
    receivableId: string
    number: number
    dueDate: Date
    amountCents: number
    status: $Enums.InstallmentStatus
    paidAt: Date | null
    method: $Enums.PaymentMethod | null
    createdAt: Date
    _count: ReceivableInstallmentCountAggregateOutputType | null
    _avg: ReceivableInstallmentAvgAggregateOutputType | null
    _sum: ReceivableInstallmentSumAggregateOutputType | null
    _min: ReceivableInstallmentMinAggregateOutputType | null
    _max: ReceivableInstallmentMaxAggregateOutputType | null
  }

  type GetReceivableInstallmentGroupByPayload<T extends ReceivableInstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceivableInstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceivableInstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceivableInstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], ReceivableInstallmentGroupByOutputType[P]>
        }
      >
    >


  export type ReceivableInstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receivableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
    receivable?: boolean | ReceivableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivableInstallment"]>

  export type ReceivableInstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receivableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
    receivable?: boolean | ReceivableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivableInstallment"]>

  export type ReceivableInstallmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    receivableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
    receivable?: boolean | ReceivableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["receivableInstallment"]>

  export type ReceivableInstallmentSelectScalar = {
    id?: boolean
    receivableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
  }

  export type ReceivableInstallmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "receivableId" | "number" | "dueDate" | "amountCents" | "status" | "paidAt" | "method" | "createdAt", ExtArgs["result"]["receivableInstallment"]>
  export type ReceivableInstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receivable?: boolean | ReceivableDefaultArgs<ExtArgs>
  }
  export type ReceivableInstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receivable?: boolean | ReceivableDefaultArgs<ExtArgs>
  }
  export type ReceivableInstallmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    receivable?: boolean | ReceivableDefaultArgs<ExtArgs>
  }

  export type $ReceivableInstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReceivableInstallment"
    objects: {
      receivable: Prisma.$ReceivablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      receivableId: string
      number: number
      dueDate: Date
      amountCents: number
      status: $Enums.InstallmentStatus
      paidAt: Date | null
      method: $Enums.PaymentMethod | null
      createdAt: Date
    }, ExtArgs["result"]["receivableInstallment"]>
    composites: {}
  }

  type ReceivableInstallmentGetPayload<S extends boolean | null | undefined | ReceivableInstallmentDefaultArgs> = $Result.GetResult<Prisma.$ReceivableInstallmentPayload, S>

  type ReceivableInstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReceivableInstallmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceivableInstallmentCountAggregateInputType | true
    }

  export interface ReceivableInstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReceivableInstallment'], meta: { name: 'ReceivableInstallment' } }
    /**
     * Find zero or one ReceivableInstallment that matches the filter.
     * @param {ReceivableInstallmentFindUniqueArgs} args - Arguments to find a ReceivableInstallment
     * @example
     * // Get one ReceivableInstallment
     * const receivableInstallment = await prisma.receivableInstallment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReceivableInstallmentFindUniqueArgs>(args: SelectSubset<T, ReceivableInstallmentFindUniqueArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReceivableInstallment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReceivableInstallmentFindUniqueOrThrowArgs} args - Arguments to find a ReceivableInstallment
     * @example
     * // Get one ReceivableInstallment
     * const receivableInstallment = await prisma.receivableInstallment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReceivableInstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReceivableInstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceivableInstallment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentFindFirstArgs} args - Arguments to find a ReceivableInstallment
     * @example
     * // Get one ReceivableInstallment
     * const receivableInstallment = await prisma.receivableInstallment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReceivableInstallmentFindFirstArgs>(args?: SelectSubset<T, ReceivableInstallmentFindFirstArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReceivableInstallment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentFindFirstOrThrowArgs} args - Arguments to find a ReceivableInstallment
     * @example
     * // Get one ReceivableInstallment
     * const receivableInstallment = await prisma.receivableInstallment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReceivableInstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReceivableInstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReceivableInstallments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReceivableInstallments
     * const receivableInstallments = await prisma.receivableInstallment.findMany()
     * 
     * // Get first 10 ReceivableInstallments
     * const receivableInstallments = await prisma.receivableInstallment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receivableInstallmentWithIdOnly = await prisma.receivableInstallment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReceivableInstallmentFindManyArgs>(args?: SelectSubset<T, ReceivableInstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReceivableInstallment.
     * @param {ReceivableInstallmentCreateArgs} args - Arguments to create a ReceivableInstallment.
     * @example
     * // Create one ReceivableInstallment
     * const ReceivableInstallment = await prisma.receivableInstallment.create({
     *   data: {
     *     // ... data to create a ReceivableInstallment
     *   }
     * })
     * 
     */
    create<T extends ReceivableInstallmentCreateArgs>(args: SelectSubset<T, ReceivableInstallmentCreateArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReceivableInstallments.
     * @param {ReceivableInstallmentCreateManyArgs} args - Arguments to create many ReceivableInstallments.
     * @example
     * // Create many ReceivableInstallments
     * const receivableInstallment = await prisma.receivableInstallment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReceivableInstallmentCreateManyArgs>(args?: SelectSubset<T, ReceivableInstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReceivableInstallments and returns the data saved in the database.
     * @param {ReceivableInstallmentCreateManyAndReturnArgs} args - Arguments to create many ReceivableInstallments.
     * @example
     * // Create many ReceivableInstallments
     * const receivableInstallment = await prisma.receivableInstallment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReceivableInstallments and only return the `id`
     * const receivableInstallmentWithIdOnly = await prisma.receivableInstallment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReceivableInstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReceivableInstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReceivableInstallment.
     * @param {ReceivableInstallmentDeleteArgs} args - Arguments to delete one ReceivableInstallment.
     * @example
     * // Delete one ReceivableInstallment
     * const ReceivableInstallment = await prisma.receivableInstallment.delete({
     *   where: {
     *     // ... filter to delete one ReceivableInstallment
     *   }
     * })
     * 
     */
    delete<T extends ReceivableInstallmentDeleteArgs>(args: SelectSubset<T, ReceivableInstallmentDeleteArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReceivableInstallment.
     * @param {ReceivableInstallmentUpdateArgs} args - Arguments to update one ReceivableInstallment.
     * @example
     * // Update one ReceivableInstallment
     * const receivableInstallment = await prisma.receivableInstallment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReceivableInstallmentUpdateArgs>(args: SelectSubset<T, ReceivableInstallmentUpdateArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReceivableInstallments.
     * @param {ReceivableInstallmentDeleteManyArgs} args - Arguments to filter ReceivableInstallments to delete.
     * @example
     * // Delete a few ReceivableInstallments
     * const { count } = await prisma.receivableInstallment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReceivableInstallmentDeleteManyArgs>(args?: SelectSubset<T, ReceivableInstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceivableInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReceivableInstallments
     * const receivableInstallment = await prisma.receivableInstallment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReceivableInstallmentUpdateManyArgs>(args: SelectSubset<T, ReceivableInstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReceivableInstallments and returns the data updated in the database.
     * @param {ReceivableInstallmentUpdateManyAndReturnArgs} args - Arguments to update many ReceivableInstallments.
     * @example
     * // Update many ReceivableInstallments
     * const receivableInstallment = await prisma.receivableInstallment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReceivableInstallments and only return the `id`
     * const receivableInstallmentWithIdOnly = await prisma.receivableInstallment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReceivableInstallmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ReceivableInstallmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReceivableInstallment.
     * @param {ReceivableInstallmentUpsertArgs} args - Arguments to update or create a ReceivableInstallment.
     * @example
     * // Update or create a ReceivableInstallment
     * const receivableInstallment = await prisma.receivableInstallment.upsert({
     *   create: {
     *     // ... data to create a ReceivableInstallment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReceivableInstallment we want to update
     *   }
     * })
     */
    upsert<T extends ReceivableInstallmentUpsertArgs>(args: SelectSubset<T, ReceivableInstallmentUpsertArgs<ExtArgs>>): Prisma__ReceivableInstallmentClient<$Result.GetResult<Prisma.$ReceivableInstallmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReceivableInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentCountArgs} args - Arguments to filter ReceivableInstallments to count.
     * @example
     * // Count the number of ReceivableInstallments
     * const count = await prisma.receivableInstallment.count({
     *   where: {
     *     // ... the filter for the ReceivableInstallments we want to count
     *   }
     * })
    **/
    count<T extends ReceivableInstallmentCountArgs>(
      args?: Subset<T, ReceivableInstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceivableInstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReceivableInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceivableInstallmentAggregateArgs>(args: Subset<T, ReceivableInstallmentAggregateArgs>): Prisma.PrismaPromise<GetReceivableInstallmentAggregateType<T>>

    /**
     * Group by ReceivableInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceivableInstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReceivableInstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReceivableInstallmentGroupByArgs['orderBy'] }
        : { orderBy?: ReceivableInstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReceivableInstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceivableInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReceivableInstallment model
   */
  readonly fields: ReceivableInstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReceivableInstallment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReceivableInstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    receivable<T extends ReceivableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReceivableDefaultArgs<ExtArgs>>): Prisma__ReceivableClient<$Result.GetResult<Prisma.$ReceivablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReceivableInstallment model
   */
  interface ReceivableInstallmentFieldRefs {
    readonly id: FieldRef<"ReceivableInstallment", 'String'>
    readonly receivableId: FieldRef<"ReceivableInstallment", 'String'>
    readonly number: FieldRef<"ReceivableInstallment", 'Int'>
    readonly dueDate: FieldRef<"ReceivableInstallment", 'DateTime'>
    readonly amountCents: FieldRef<"ReceivableInstallment", 'Int'>
    readonly status: FieldRef<"ReceivableInstallment", 'InstallmentStatus'>
    readonly paidAt: FieldRef<"ReceivableInstallment", 'DateTime'>
    readonly method: FieldRef<"ReceivableInstallment", 'PaymentMethod'>
    readonly createdAt: FieldRef<"ReceivableInstallment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReceivableInstallment findUnique
   */
  export type ReceivableInstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which ReceivableInstallment to fetch.
     */
    where: ReceivableInstallmentWhereUniqueInput
  }

  /**
   * ReceivableInstallment findUniqueOrThrow
   */
  export type ReceivableInstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which ReceivableInstallment to fetch.
     */
    where: ReceivableInstallmentWhereUniqueInput
  }

  /**
   * ReceivableInstallment findFirst
   */
  export type ReceivableInstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which ReceivableInstallment to fetch.
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivableInstallments to fetch.
     */
    orderBy?: ReceivableInstallmentOrderByWithRelationInput | ReceivableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceivableInstallments.
     */
    cursor?: ReceivableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivableInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceivableInstallments.
     */
    distinct?: ReceivableInstallmentScalarFieldEnum | ReceivableInstallmentScalarFieldEnum[]
  }

  /**
   * ReceivableInstallment findFirstOrThrow
   */
  export type ReceivableInstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which ReceivableInstallment to fetch.
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivableInstallments to fetch.
     */
    orderBy?: ReceivableInstallmentOrderByWithRelationInput | ReceivableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReceivableInstallments.
     */
    cursor?: ReceivableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivableInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReceivableInstallments.
     */
    distinct?: ReceivableInstallmentScalarFieldEnum | ReceivableInstallmentScalarFieldEnum[]
  }

  /**
   * ReceivableInstallment findMany
   */
  export type ReceivableInstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which ReceivableInstallments to fetch.
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReceivableInstallments to fetch.
     */
    orderBy?: ReceivableInstallmentOrderByWithRelationInput | ReceivableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReceivableInstallments.
     */
    cursor?: ReceivableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReceivableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReceivableInstallments.
     */
    skip?: number
    distinct?: ReceivableInstallmentScalarFieldEnum | ReceivableInstallmentScalarFieldEnum[]
  }

  /**
   * ReceivableInstallment create
   */
  export type ReceivableInstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReceivableInstallment.
     */
    data: XOR<ReceivableInstallmentCreateInput, ReceivableInstallmentUncheckedCreateInput>
  }

  /**
   * ReceivableInstallment createMany
   */
  export type ReceivableInstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReceivableInstallments.
     */
    data: ReceivableInstallmentCreateManyInput | ReceivableInstallmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReceivableInstallment createManyAndReturn
   */
  export type ReceivableInstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * The data used to create many ReceivableInstallments.
     */
    data: ReceivableInstallmentCreateManyInput | ReceivableInstallmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceivableInstallment update
   */
  export type ReceivableInstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReceivableInstallment.
     */
    data: XOR<ReceivableInstallmentUpdateInput, ReceivableInstallmentUncheckedUpdateInput>
    /**
     * Choose, which ReceivableInstallment to update.
     */
    where: ReceivableInstallmentWhereUniqueInput
  }

  /**
   * ReceivableInstallment updateMany
   */
  export type ReceivableInstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReceivableInstallments.
     */
    data: XOR<ReceivableInstallmentUpdateManyMutationInput, ReceivableInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which ReceivableInstallments to update
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * Limit how many ReceivableInstallments to update.
     */
    limit?: number
  }

  /**
   * ReceivableInstallment updateManyAndReturn
   */
  export type ReceivableInstallmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * The data used to update ReceivableInstallments.
     */
    data: XOR<ReceivableInstallmentUpdateManyMutationInput, ReceivableInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which ReceivableInstallments to update
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * Limit how many ReceivableInstallments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReceivableInstallment upsert
   */
  export type ReceivableInstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReceivableInstallment to update in case it exists.
     */
    where: ReceivableInstallmentWhereUniqueInput
    /**
     * In case the ReceivableInstallment found by the `where` argument doesn't exist, create a new ReceivableInstallment with this data.
     */
    create: XOR<ReceivableInstallmentCreateInput, ReceivableInstallmentUncheckedCreateInput>
    /**
     * In case the ReceivableInstallment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReceivableInstallmentUpdateInput, ReceivableInstallmentUncheckedUpdateInput>
  }

  /**
   * ReceivableInstallment delete
   */
  export type ReceivableInstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
    /**
     * Filter which ReceivableInstallment to delete.
     */
    where: ReceivableInstallmentWhereUniqueInput
  }

  /**
   * ReceivableInstallment deleteMany
   */
  export type ReceivableInstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReceivableInstallments to delete
     */
    where?: ReceivableInstallmentWhereInput
    /**
     * Limit how many ReceivableInstallments to delete.
     */
    limit?: number
  }

  /**
   * ReceivableInstallment without action
   */
  export type ReceivableInstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReceivableInstallment
     */
    select?: ReceivableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReceivableInstallment
     */
    omit?: ReceivableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReceivableInstallmentInclude<ExtArgs> | null
  }


  /**
   * Model Payable
   */

  export type AggregatePayable = {
    _count: PayableCountAggregateOutputType | null
    _avg: PayableAvgAggregateOutputType | null
    _sum: PayableSumAggregateOutputType | null
    _min: PayableMinAggregateOutputType | null
    _max: PayableMaxAggregateOutputType | null
  }

  export type PayableAvgAggregateOutputType = {
    totalCents: number | null
  }

  export type PayableSumAggregateOutputType = {
    totalCents: number | null
  }

  export type PayableMinAggregateOutputType = {
    id: string | null
    supplierId: string | null
    salonId: string | null
    description: string | null
    totalCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayableMaxAggregateOutputType = {
    id: string | null
    supplierId: string | null
    salonId: string | null
    description: string | null
    totalCents: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayableCountAggregateOutputType = {
    id: number
    supplierId: number
    salonId: number
    description: number
    totalCents: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayableAvgAggregateInputType = {
    totalCents?: true
  }

  export type PayableSumAggregateInputType = {
    totalCents?: true
  }

  export type PayableMinAggregateInputType = {
    id?: true
    supplierId?: true
    salonId?: true
    description?: true
    totalCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayableMaxAggregateInputType = {
    id?: true
    supplierId?: true
    salonId?: true
    description?: true
    totalCents?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayableCountAggregateInputType = {
    id?: true
    supplierId?: true
    salonId?: true
    description?: true
    totalCents?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payable to aggregate.
     */
    where?: PayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payables to fetch.
     */
    orderBy?: PayableOrderByWithRelationInput | PayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payables
    **/
    _count?: true | PayableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayableMaxAggregateInputType
  }

  export type GetPayableAggregateType<T extends PayableAggregateArgs> = {
        [P in keyof T & keyof AggregatePayable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayable[P]>
      : GetScalarType<T[P], AggregatePayable[P]>
  }




  export type PayableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayableWhereInput
    orderBy?: PayableOrderByWithAggregationInput | PayableOrderByWithAggregationInput[]
    by: PayableScalarFieldEnum[] | PayableScalarFieldEnum
    having?: PayableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayableCountAggregateInputType | true
    _avg?: PayableAvgAggregateInputType
    _sum?: PayableSumAggregateInputType
    _min?: PayableMinAggregateInputType
    _max?: PayableMaxAggregateInputType
  }

  export type PayableGroupByOutputType = {
    id: string
    supplierId: string | null
    salonId: string
    description: string
    totalCents: number
    createdAt: Date
    updatedAt: Date
    _count: PayableCountAggregateOutputType | null
    _avg: PayableAvgAggregateOutputType | null
    _sum: PayableSumAggregateOutputType | null
    _min: PayableMinAggregateOutputType | null
    _max: PayableMaxAggregateOutputType | null
  }

  type GetPayableGroupByPayload<T extends PayableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayableGroupByOutputType[P]>
            : GetScalarType<T[P], PayableGroupByOutputType[P]>
        }
      >
    >


  export type PayableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    salonId?: boolean
    description?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Payable$supplierArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    installments?: boolean | Payable$installmentsArgs<ExtArgs>
    _count?: boolean | PayableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payable"]>

  export type PayableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    salonId?: boolean
    description?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Payable$supplierArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payable"]>

  export type PayableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierId?: boolean
    salonId?: boolean
    description?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    supplier?: boolean | Payable$supplierArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payable"]>

  export type PayableSelectScalar = {
    id?: boolean
    supplierId?: boolean
    salonId?: boolean
    description?: boolean
    totalCents?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierId" | "salonId" | "description" | "totalCents" | "createdAt" | "updatedAt", ExtArgs["result"]["payable"]>
  export type PayableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Payable$supplierArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    installments?: boolean | Payable$installmentsArgs<ExtArgs>
    _count?: boolean | PayableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Payable$supplierArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }
  export type PayableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    supplier?: boolean | Payable$supplierArgs<ExtArgs>
    salon?: boolean | SalonDefaultArgs<ExtArgs>
  }

  export type $PayablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payable"
    objects: {
      supplier: Prisma.$ClientPayload<ExtArgs> | null
      salon: Prisma.$SalonPayload<ExtArgs>
      installments: Prisma.$PayableInstallmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supplierId: string | null
      salonId: string
      description: string
      totalCents: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payable"]>
    composites: {}
  }

  type PayableGetPayload<S extends boolean | null | undefined | PayableDefaultArgs> = $Result.GetResult<Prisma.$PayablePayload, S>

  type PayableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayableCountAggregateInputType | true
    }

  export interface PayableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payable'], meta: { name: 'Payable' } }
    /**
     * Find zero or one Payable that matches the filter.
     * @param {PayableFindUniqueArgs} args - Arguments to find a Payable
     * @example
     * // Get one Payable
     * const payable = await prisma.payable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayableFindUniqueArgs>(args: SelectSubset<T, PayableFindUniqueArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayableFindUniqueOrThrowArgs} args - Arguments to find a Payable
     * @example
     * // Get one Payable
     * const payable = await prisma.payable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayableFindUniqueOrThrowArgs>(args: SelectSubset<T, PayableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableFindFirstArgs} args - Arguments to find a Payable
     * @example
     * // Get one Payable
     * const payable = await prisma.payable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayableFindFirstArgs>(args?: SelectSubset<T, PayableFindFirstArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableFindFirstOrThrowArgs} args - Arguments to find a Payable
     * @example
     * // Get one Payable
     * const payable = await prisma.payable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayableFindFirstOrThrowArgs>(args?: SelectSubset<T, PayableFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payables
     * const payables = await prisma.payable.findMany()
     * 
     * // Get first 10 Payables
     * const payables = await prisma.payable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payableWithIdOnly = await prisma.payable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayableFindManyArgs>(args?: SelectSubset<T, PayableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payable.
     * @param {PayableCreateArgs} args - Arguments to create a Payable.
     * @example
     * // Create one Payable
     * const Payable = await prisma.payable.create({
     *   data: {
     *     // ... data to create a Payable
     *   }
     * })
     * 
     */
    create<T extends PayableCreateArgs>(args: SelectSubset<T, PayableCreateArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payables.
     * @param {PayableCreateManyArgs} args - Arguments to create many Payables.
     * @example
     * // Create many Payables
     * const payable = await prisma.payable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayableCreateManyArgs>(args?: SelectSubset<T, PayableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payables and returns the data saved in the database.
     * @param {PayableCreateManyAndReturnArgs} args - Arguments to create many Payables.
     * @example
     * // Create many Payables
     * const payable = await prisma.payable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payables and only return the `id`
     * const payableWithIdOnly = await prisma.payable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayableCreateManyAndReturnArgs>(args?: SelectSubset<T, PayableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payable.
     * @param {PayableDeleteArgs} args - Arguments to delete one Payable.
     * @example
     * // Delete one Payable
     * const Payable = await prisma.payable.delete({
     *   where: {
     *     // ... filter to delete one Payable
     *   }
     * })
     * 
     */
    delete<T extends PayableDeleteArgs>(args: SelectSubset<T, PayableDeleteArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payable.
     * @param {PayableUpdateArgs} args - Arguments to update one Payable.
     * @example
     * // Update one Payable
     * const payable = await prisma.payable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayableUpdateArgs>(args: SelectSubset<T, PayableUpdateArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payables.
     * @param {PayableDeleteManyArgs} args - Arguments to filter Payables to delete.
     * @example
     * // Delete a few Payables
     * const { count } = await prisma.payable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayableDeleteManyArgs>(args?: SelectSubset<T, PayableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payables
     * const payable = await prisma.payable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayableUpdateManyArgs>(args: SelectSubset<T, PayableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payables and returns the data updated in the database.
     * @param {PayableUpdateManyAndReturnArgs} args - Arguments to update many Payables.
     * @example
     * // Update many Payables
     * const payable = await prisma.payable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payables and only return the `id`
     * const payableWithIdOnly = await prisma.payable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayableUpdateManyAndReturnArgs>(args: SelectSubset<T, PayableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payable.
     * @param {PayableUpsertArgs} args - Arguments to update or create a Payable.
     * @example
     * // Update or create a Payable
     * const payable = await prisma.payable.upsert({
     *   create: {
     *     // ... data to create a Payable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payable we want to update
     *   }
     * })
     */
    upsert<T extends PayableUpsertArgs>(args: SelectSubset<T, PayableUpsertArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableCountArgs} args - Arguments to filter Payables to count.
     * @example
     * // Count the number of Payables
     * const count = await prisma.payable.count({
     *   where: {
     *     // ... the filter for the Payables we want to count
     *   }
     * })
    **/
    count<T extends PayableCountArgs>(
      args?: Subset<T, PayableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayableAggregateArgs>(args: Subset<T, PayableAggregateArgs>): Prisma.PrismaPromise<GetPayableAggregateType<T>>

    /**
     * Group by Payable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayableGroupByArgs['orderBy'] }
        : { orderBy?: PayableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payable model
   */
  readonly fields: PayableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    supplier<T extends Payable$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Payable$supplierArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    installments<T extends Payable$installmentsArgs<ExtArgs> = {}>(args?: Subset<T, Payable$installmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payable model
   */
  interface PayableFieldRefs {
    readonly id: FieldRef<"Payable", 'String'>
    readonly supplierId: FieldRef<"Payable", 'String'>
    readonly salonId: FieldRef<"Payable", 'String'>
    readonly description: FieldRef<"Payable", 'String'>
    readonly totalCents: FieldRef<"Payable", 'Int'>
    readonly createdAt: FieldRef<"Payable", 'DateTime'>
    readonly updatedAt: FieldRef<"Payable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payable findUnique
   */
  export type PayableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * Filter, which Payable to fetch.
     */
    where: PayableWhereUniqueInput
  }

  /**
   * Payable findUniqueOrThrow
   */
  export type PayableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * Filter, which Payable to fetch.
     */
    where: PayableWhereUniqueInput
  }

  /**
   * Payable findFirst
   */
  export type PayableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * Filter, which Payable to fetch.
     */
    where?: PayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payables to fetch.
     */
    orderBy?: PayableOrderByWithRelationInput | PayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payables.
     */
    cursor?: PayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payables.
     */
    distinct?: PayableScalarFieldEnum | PayableScalarFieldEnum[]
  }

  /**
   * Payable findFirstOrThrow
   */
  export type PayableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * Filter, which Payable to fetch.
     */
    where?: PayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payables to fetch.
     */
    orderBy?: PayableOrderByWithRelationInput | PayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payables.
     */
    cursor?: PayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payables.
     */
    distinct?: PayableScalarFieldEnum | PayableScalarFieldEnum[]
  }

  /**
   * Payable findMany
   */
  export type PayableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * Filter, which Payables to fetch.
     */
    where?: PayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payables to fetch.
     */
    orderBy?: PayableOrderByWithRelationInput | PayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payables.
     */
    cursor?: PayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payables.
     */
    skip?: number
    distinct?: PayableScalarFieldEnum | PayableScalarFieldEnum[]
  }

  /**
   * Payable create
   */
  export type PayableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * The data needed to create a Payable.
     */
    data: XOR<PayableCreateInput, PayableUncheckedCreateInput>
  }

  /**
   * Payable createMany
   */
  export type PayableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payables.
     */
    data: PayableCreateManyInput | PayableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payable createManyAndReturn
   */
  export type PayableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * The data used to create many Payables.
     */
    data: PayableCreateManyInput | PayableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payable update
   */
  export type PayableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * The data needed to update a Payable.
     */
    data: XOR<PayableUpdateInput, PayableUncheckedUpdateInput>
    /**
     * Choose, which Payable to update.
     */
    where: PayableWhereUniqueInput
  }

  /**
   * Payable updateMany
   */
  export type PayableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payables.
     */
    data: XOR<PayableUpdateManyMutationInput, PayableUncheckedUpdateManyInput>
    /**
     * Filter which Payables to update
     */
    where?: PayableWhereInput
    /**
     * Limit how many Payables to update.
     */
    limit?: number
  }

  /**
   * Payable updateManyAndReturn
   */
  export type PayableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * The data used to update Payables.
     */
    data: XOR<PayableUpdateManyMutationInput, PayableUncheckedUpdateManyInput>
    /**
     * Filter which Payables to update
     */
    where?: PayableWhereInput
    /**
     * Limit how many Payables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payable upsert
   */
  export type PayableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * The filter to search for the Payable to update in case it exists.
     */
    where: PayableWhereUniqueInput
    /**
     * In case the Payable found by the `where` argument doesn't exist, create a new Payable with this data.
     */
    create: XOR<PayableCreateInput, PayableUncheckedCreateInput>
    /**
     * In case the Payable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayableUpdateInput, PayableUncheckedUpdateInput>
  }

  /**
   * Payable delete
   */
  export type PayableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
    /**
     * Filter which Payable to delete.
     */
    where: PayableWhereUniqueInput
  }

  /**
   * Payable deleteMany
   */
  export type PayableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payables to delete
     */
    where?: PayableWhereInput
    /**
     * Limit how many Payables to delete.
     */
    limit?: number
  }

  /**
   * Payable.supplier
   */
  export type Payable$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Payable.installments
   */
  export type Payable$installmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    where?: PayableInstallmentWhereInput
    orderBy?: PayableInstallmentOrderByWithRelationInput | PayableInstallmentOrderByWithRelationInput[]
    cursor?: PayableInstallmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayableInstallmentScalarFieldEnum | PayableInstallmentScalarFieldEnum[]
  }

  /**
   * Payable without action
   */
  export type PayableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payable
     */
    select?: PayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payable
     */
    omit?: PayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInclude<ExtArgs> | null
  }


  /**
   * Model PayableInstallment
   */

  export type AggregatePayableInstallment = {
    _count: PayableInstallmentCountAggregateOutputType | null
    _avg: PayableInstallmentAvgAggregateOutputType | null
    _sum: PayableInstallmentSumAggregateOutputType | null
    _min: PayableInstallmentMinAggregateOutputType | null
    _max: PayableInstallmentMaxAggregateOutputType | null
  }

  export type PayableInstallmentAvgAggregateOutputType = {
    number: number | null
    amountCents: number | null
  }

  export type PayableInstallmentSumAggregateOutputType = {
    number: number | null
    amountCents: number | null
  }

  export type PayableInstallmentMinAggregateOutputType = {
    id: string | null
    payableId: string | null
    number: number | null
    dueDate: Date | null
    amountCents: number | null
    status: $Enums.InstallmentStatus | null
    paidAt: Date | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
  }

  export type PayableInstallmentMaxAggregateOutputType = {
    id: string | null
    payableId: string | null
    number: number | null
    dueDate: Date | null
    amountCents: number | null
    status: $Enums.InstallmentStatus | null
    paidAt: Date | null
    method: $Enums.PaymentMethod | null
    createdAt: Date | null
  }

  export type PayableInstallmentCountAggregateOutputType = {
    id: number
    payableId: number
    number: number
    dueDate: number
    amountCents: number
    status: number
    paidAt: number
    method: number
    createdAt: number
    _all: number
  }


  export type PayableInstallmentAvgAggregateInputType = {
    number?: true
    amountCents?: true
  }

  export type PayableInstallmentSumAggregateInputType = {
    number?: true
    amountCents?: true
  }

  export type PayableInstallmentMinAggregateInputType = {
    id?: true
    payableId?: true
    number?: true
    dueDate?: true
    amountCents?: true
    status?: true
    paidAt?: true
    method?: true
    createdAt?: true
  }

  export type PayableInstallmentMaxAggregateInputType = {
    id?: true
    payableId?: true
    number?: true
    dueDate?: true
    amountCents?: true
    status?: true
    paidAt?: true
    method?: true
    createdAt?: true
  }

  export type PayableInstallmentCountAggregateInputType = {
    id?: true
    payableId?: true
    number?: true
    dueDate?: true
    amountCents?: true
    status?: true
    paidAt?: true
    method?: true
    createdAt?: true
    _all?: true
  }

  export type PayableInstallmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayableInstallment to aggregate.
     */
    where?: PayableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayableInstallments to fetch.
     */
    orderBy?: PayableInstallmentOrderByWithRelationInput | PayableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayableInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayableInstallments
    **/
    _count?: true | PayableInstallmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayableInstallmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayableInstallmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayableInstallmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayableInstallmentMaxAggregateInputType
  }

  export type GetPayableInstallmentAggregateType<T extends PayableInstallmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayableInstallment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayableInstallment[P]>
      : GetScalarType<T[P], AggregatePayableInstallment[P]>
  }




  export type PayableInstallmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayableInstallmentWhereInput
    orderBy?: PayableInstallmentOrderByWithAggregationInput | PayableInstallmentOrderByWithAggregationInput[]
    by: PayableInstallmentScalarFieldEnum[] | PayableInstallmentScalarFieldEnum
    having?: PayableInstallmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayableInstallmentCountAggregateInputType | true
    _avg?: PayableInstallmentAvgAggregateInputType
    _sum?: PayableInstallmentSumAggregateInputType
    _min?: PayableInstallmentMinAggregateInputType
    _max?: PayableInstallmentMaxAggregateInputType
  }

  export type PayableInstallmentGroupByOutputType = {
    id: string
    payableId: string
    number: number
    dueDate: Date
    amountCents: number
    status: $Enums.InstallmentStatus
    paidAt: Date | null
    method: $Enums.PaymentMethod | null
    createdAt: Date
    _count: PayableInstallmentCountAggregateOutputType | null
    _avg: PayableInstallmentAvgAggregateOutputType | null
    _sum: PayableInstallmentSumAggregateOutputType | null
    _min: PayableInstallmentMinAggregateOutputType | null
    _max: PayableInstallmentMaxAggregateOutputType | null
  }

  type GetPayableInstallmentGroupByPayload<T extends PayableInstallmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayableInstallmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayableInstallmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayableInstallmentGroupByOutputType[P]>
            : GetScalarType<T[P], PayableInstallmentGroupByOutputType[P]>
        }
      >
    >


  export type PayableInstallmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
    payable?: boolean | PayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payableInstallment"]>

  export type PayableInstallmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
    payable?: boolean | PayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payableInstallment"]>

  export type PayableInstallmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
    payable?: boolean | PayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payableInstallment"]>

  export type PayableInstallmentSelectScalar = {
    id?: boolean
    payableId?: boolean
    number?: boolean
    dueDate?: boolean
    amountCents?: boolean
    status?: boolean
    paidAt?: boolean
    method?: boolean
    createdAt?: boolean
  }

  export type PayableInstallmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "payableId" | "number" | "dueDate" | "amountCents" | "status" | "paidAt" | "method" | "createdAt", ExtArgs["result"]["payableInstallment"]>
  export type PayableInstallmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | PayableDefaultArgs<ExtArgs>
  }
  export type PayableInstallmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | PayableDefaultArgs<ExtArgs>
  }
  export type PayableInstallmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | PayableDefaultArgs<ExtArgs>
  }

  export type $PayableInstallmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayableInstallment"
    objects: {
      payable: Prisma.$PayablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      payableId: string
      number: number
      dueDate: Date
      amountCents: number
      status: $Enums.InstallmentStatus
      paidAt: Date | null
      method: $Enums.PaymentMethod | null
      createdAt: Date
    }, ExtArgs["result"]["payableInstallment"]>
    composites: {}
  }

  type PayableInstallmentGetPayload<S extends boolean | null | undefined | PayableInstallmentDefaultArgs> = $Result.GetResult<Prisma.$PayableInstallmentPayload, S>

  type PayableInstallmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayableInstallmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayableInstallmentCountAggregateInputType | true
    }

  export interface PayableInstallmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayableInstallment'], meta: { name: 'PayableInstallment' } }
    /**
     * Find zero or one PayableInstallment that matches the filter.
     * @param {PayableInstallmentFindUniqueArgs} args - Arguments to find a PayableInstallment
     * @example
     * // Get one PayableInstallment
     * const payableInstallment = await prisma.payableInstallment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayableInstallmentFindUniqueArgs>(args: SelectSubset<T, PayableInstallmentFindUniqueArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayableInstallment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayableInstallmentFindUniqueOrThrowArgs} args - Arguments to find a PayableInstallment
     * @example
     * // Get one PayableInstallment
     * const payableInstallment = await prisma.payableInstallment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayableInstallmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PayableInstallmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayableInstallment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentFindFirstArgs} args - Arguments to find a PayableInstallment
     * @example
     * // Get one PayableInstallment
     * const payableInstallment = await prisma.payableInstallment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayableInstallmentFindFirstArgs>(args?: SelectSubset<T, PayableInstallmentFindFirstArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayableInstallment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentFindFirstOrThrowArgs} args - Arguments to find a PayableInstallment
     * @example
     * // Get one PayableInstallment
     * const payableInstallment = await prisma.payableInstallment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayableInstallmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PayableInstallmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayableInstallments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayableInstallments
     * const payableInstallments = await prisma.payableInstallment.findMany()
     * 
     * // Get first 10 PayableInstallments
     * const payableInstallments = await prisma.payableInstallment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payableInstallmentWithIdOnly = await prisma.payableInstallment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayableInstallmentFindManyArgs>(args?: SelectSubset<T, PayableInstallmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayableInstallment.
     * @param {PayableInstallmentCreateArgs} args - Arguments to create a PayableInstallment.
     * @example
     * // Create one PayableInstallment
     * const PayableInstallment = await prisma.payableInstallment.create({
     *   data: {
     *     // ... data to create a PayableInstallment
     *   }
     * })
     * 
     */
    create<T extends PayableInstallmentCreateArgs>(args: SelectSubset<T, PayableInstallmentCreateArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayableInstallments.
     * @param {PayableInstallmentCreateManyArgs} args - Arguments to create many PayableInstallments.
     * @example
     * // Create many PayableInstallments
     * const payableInstallment = await prisma.payableInstallment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayableInstallmentCreateManyArgs>(args?: SelectSubset<T, PayableInstallmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayableInstallments and returns the data saved in the database.
     * @param {PayableInstallmentCreateManyAndReturnArgs} args - Arguments to create many PayableInstallments.
     * @example
     * // Create many PayableInstallments
     * const payableInstallment = await prisma.payableInstallment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayableInstallments and only return the `id`
     * const payableInstallmentWithIdOnly = await prisma.payableInstallment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayableInstallmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PayableInstallmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayableInstallment.
     * @param {PayableInstallmentDeleteArgs} args - Arguments to delete one PayableInstallment.
     * @example
     * // Delete one PayableInstallment
     * const PayableInstallment = await prisma.payableInstallment.delete({
     *   where: {
     *     // ... filter to delete one PayableInstallment
     *   }
     * })
     * 
     */
    delete<T extends PayableInstallmentDeleteArgs>(args: SelectSubset<T, PayableInstallmentDeleteArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayableInstallment.
     * @param {PayableInstallmentUpdateArgs} args - Arguments to update one PayableInstallment.
     * @example
     * // Update one PayableInstallment
     * const payableInstallment = await prisma.payableInstallment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayableInstallmentUpdateArgs>(args: SelectSubset<T, PayableInstallmentUpdateArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayableInstallments.
     * @param {PayableInstallmentDeleteManyArgs} args - Arguments to filter PayableInstallments to delete.
     * @example
     * // Delete a few PayableInstallments
     * const { count } = await prisma.payableInstallment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayableInstallmentDeleteManyArgs>(args?: SelectSubset<T, PayableInstallmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayableInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayableInstallments
     * const payableInstallment = await prisma.payableInstallment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayableInstallmentUpdateManyArgs>(args: SelectSubset<T, PayableInstallmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayableInstallments and returns the data updated in the database.
     * @param {PayableInstallmentUpdateManyAndReturnArgs} args - Arguments to update many PayableInstallments.
     * @example
     * // Update many PayableInstallments
     * const payableInstallment = await prisma.payableInstallment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayableInstallments and only return the `id`
     * const payableInstallmentWithIdOnly = await prisma.payableInstallment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayableInstallmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PayableInstallmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayableInstallment.
     * @param {PayableInstallmentUpsertArgs} args - Arguments to update or create a PayableInstallment.
     * @example
     * // Update or create a PayableInstallment
     * const payableInstallment = await prisma.payableInstallment.upsert({
     *   create: {
     *     // ... data to create a PayableInstallment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayableInstallment we want to update
     *   }
     * })
     */
    upsert<T extends PayableInstallmentUpsertArgs>(args: SelectSubset<T, PayableInstallmentUpsertArgs<ExtArgs>>): Prisma__PayableInstallmentClient<$Result.GetResult<Prisma.$PayableInstallmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayableInstallments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentCountArgs} args - Arguments to filter PayableInstallments to count.
     * @example
     * // Count the number of PayableInstallments
     * const count = await prisma.payableInstallment.count({
     *   where: {
     *     // ... the filter for the PayableInstallments we want to count
     *   }
     * })
    **/
    count<T extends PayableInstallmentCountArgs>(
      args?: Subset<T, PayableInstallmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayableInstallmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayableInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayableInstallmentAggregateArgs>(args: Subset<T, PayableInstallmentAggregateArgs>): Prisma.PrismaPromise<GetPayableInstallmentAggregateType<T>>

    /**
     * Group by PayableInstallment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayableInstallmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayableInstallmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayableInstallmentGroupByArgs['orderBy'] }
        : { orderBy?: PayableInstallmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayableInstallmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayableInstallmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayableInstallment model
   */
  readonly fields: PayableInstallmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayableInstallment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayableInstallmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payable<T extends PayableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayableDefaultArgs<ExtArgs>>): Prisma__PayableClient<$Result.GetResult<Prisma.$PayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayableInstallment model
   */
  interface PayableInstallmentFieldRefs {
    readonly id: FieldRef<"PayableInstallment", 'String'>
    readonly payableId: FieldRef<"PayableInstallment", 'String'>
    readonly number: FieldRef<"PayableInstallment", 'Int'>
    readonly dueDate: FieldRef<"PayableInstallment", 'DateTime'>
    readonly amountCents: FieldRef<"PayableInstallment", 'Int'>
    readonly status: FieldRef<"PayableInstallment", 'InstallmentStatus'>
    readonly paidAt: FieldRef<"PayableInstallment", 'DateTime'>
    readonly method: FieldRef<"PayableInstallment", 'PaymentMethod'>
    readonly createdAt: FieldRef<"PayableInstallment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayableInstallment findUnique
   */
  export type PayableInstallmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which PayableInstallment to fetch.
     */
    where: PayableInstallmentWhereUniqueInput
  }

  /**
   * PayableInstallment findUniqueOrThrow
   */
  export type PayableInstallmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which PayableInstallment to fetch.
     */
    where: PayableInstallmentWhereUniqueInput
  }

  /**
   * PayableInstallment findFirst
   */
  export type PayableInstallmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which PayableInstallment to fetch.
     */
    where?: PayableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayableInstallments to fetch.
     */
    orderBy?: PayableInstallmentOrderByWithRelationInput | PayableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayableInstallments.
     */
    cursor?: PayableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayableInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayableInstallments.
     */
    distinct?: PayableInstallmentScalarFieldEnum | PayableInstallmentScalarFieldEnum[]
  }

  /**
   * PayableInstallment findFirstOrThrow
   */
  export type PayableInstallmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which PayableInstallment to fetch.
     */
    where?: PayableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayableInstallments to fetch.
     */
    orderBy?: PayableInstallmentOrderByWithRelationInput | PayableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayableInstallments.
     */
    cursor?: PayableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayableInstallments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayableInstallments.
     */
    distinct?: PayableInstallmentScalarFieldEnum | PayableInstallmentScalarFieldEnum[]
  }

  /**
   * PayableInstallment findMany
   */
  export type PayableInstallmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * Filter, which PayableInstallments to fetch.
     */
    where?: PayableInstallmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayableInstallments to fetch.
     */
    orderBy?: PayableInstallmentOrderByWithRelationInput | PayableInstallmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayableInstallments.
     */
    cursor?: PayableInstallmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayableInstallments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayableInstallments.
     */
    skip?: number
    distinct?: PayableInstallmentScalarFieldEnum | PayableInstallmentScalarFieldEnum[]
  }

  /**
   * PayableInstallment create
   */
  export type PayableInstallmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PayableInstallment.
     */
    data: XOR<PayableInstallmentCreateInput, PayableInstallmentUncheckedCreateInput>
  }

  /**
   * PayableInstallment createMany
   */
  export type PayableInstallmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayableInstallments.
     */
    data: PayableInstallmentCreateManyInput | PayableInstallmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayableInstallment createManyAndReturn
   */
  export type PayableInstallmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * The data used to create many PayableInstallments.
     */
    data: PayableInstallmentCreateManyInput | PayableInstallmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayableInstallment update
   */
  export type PayableInstallmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PayableInstallment.
     */
    data: XOR<PayableInstallmentUpdateInput, PayableInstallmentUncheckedUpdateInput>
    /**
     * Choose, which PayableInstallment to update.
     */
    where: PayableInstallmentWhereUniqueInput
  }

  /**
   * PayableInstallment updateMany
   */
  export type PayableInstallmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayableInstallments.
     */
    data: XOR<PayableInstallmentUpdateManyMutationInput, PayableInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which PayableInstallments to update
     */
    where?: PayableInstallmentWhereInput
    /**
     * Limit how many PayableInstallments to update.
     */
    limit?: number
  }

  /**
   * PayableInstallment updateManyAndReturn
   */
  export type PayableInstallmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * The data used to update PayableInstallments.
     */
    data: XOR<PayableInstallmentUpdateManyMutationInput, PayableInstallmentUncheckedUpdateManyInput>
    /**
     * Filter which PayableInstallments to update
     */
    where?: PayableInstallmentWhereInput
    /**
     * Limit how many PayableInstallments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayableInstallment upsert
   */
  export type PayableInstallmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PayableInstallment to update in case it exists.
     */
    where: PayableInstallmentWhereUniqueInput
    /**
     * In case the PayableInstallment found by the `where` argument doesn't exist, create a new PayableInstallment with this data.
     */
    create: XOR<PayableInstallmentCreateInput, PayableInstallmentUncheckedCreateInput>
    /**
     * In case the PayableInstallment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayableInstallmentUpdateInput, PayableInstallmentUncheckedUpdateInput>
  }

  /**
   * PayableInstallment delete
   */
  export type PayableInstallmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
    /**
     * Filter which PayableInstallment to delete.
     */
    where: PayableInstallmentWhereUniqueInput
  }

  /**
   * PayableInstallment deleteMany
   */
  export type PayableInstallmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayableInstallments to delete
     */
    where?: PayableInstallmentWhereInput
    /**
     * Limit how many PayableInstallments to delete.
     */
    limit?: number
  }

  /**
   * PayableInstallment without action
   */
  export type PayableInstallmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayableInstallment
     */
    select?: PayableInstallmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayableInstallment
     */
    omit?: PayableInstallmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayableInstallmentInclude<ExtArgs> | null
  }


  /**
   * Model Cost
   */

  export type AggregateCost = {
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  export type CostAvgAggregateOutputType = {
    amountCents: number | null
  }

  export type CostSumAggregateOutputType = {
    amountCents: number | null
  }

  export type CostMinAggregateOutputType = {
    id: string | null
    salonId: string | null
    type: $Enums.CostType | null
    name: string | null
    description: string | null
    amountCents: number | null
    occurredAt: Date | null
    supplierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostMaxAggregateOutputType = {
    id: string | null
    salonId: string | null
    type: $Enums.CostType | null
    name: string | null
    description: string | null
    amountCents: number | null
    occurredAt: Date | null
    supplierId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostCountAggregateOutputType = {
    id: number
    salonId: number
    type: number
    name: number
    description: number
    amountCents: number
    occurredAt: number
    supplierId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostAvgAggregateInputType = {
    amountCents?: true
  }

  export type CostSumAggregateInputType = {
    amountCents?: true
  }

  export type CostMinAggregateInputType = {
    id?: true
    salonId?: true
    type?: true
    name?: true
    description?: true
    amountCents?: true
    occurredAt?: true
    supplierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostMaxAggregateInputType = {
    id?: true
    salonId?: true
    type?: true
    name?: true
    description?: true
    amountCents?: true
    occurredAt?: true
    supplierId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostCountAggregateInputType = {
    id?: true
    salonId?: true
    type?: true
    name?: true
    description?: true
    amountCents?: true
    occurredAt?: true
    supplierId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cost to aggregate.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Costs
    **/
    _count?: true | CostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostMaxAggregateInputType
  }

  export type GetCostAggregateType<T extends CostAggregateArgs> = {
        [P in keyof T & keyof AggregateCost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCost[P]>
      : GetScalarType<T[P], AggregateCost[P]>
  }




  export type CostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostWhereInput
    orderBy?: CostOrderByWithAggregationInput | CostOrderByWithAggregationInput[]
    by: CostScalarFieldEnum[] | CostScalarFieldEnum
    having?: CostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostCountAggregateInputType | true
    _avg?: CostAvgAggregateInputType
    _sum?: CostSumAggregateInputType
    _min?: CostMinAggregateInputType
    _max?: CostMaxAggregateInputType
  }

  export type CostGroupByOutputType = {
    id: string
    salonId: string
    type: $Enums.CostType
    name: string
    description: string | null
    amountCents: number
    occurredAt: Date
    supplierId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CostCountAggregateOutputType | null
    _avg: CostAvgAggregateOutputType | null
    _sum: CostSumAggregateOutputType | null
    _min: CostMinAggregateOutputType | null
    _max: CostMaxAggregateOutputType | null
  }

  type GetCostGroupByPayload<T extends CostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostGroupByOutputType[P]>
            : GetScalarType<T[P], CostGroupByOutputType[P]>
        }
      >
    >


  export type CostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salonId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    occurredAt?: boolean
    supplierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    supplier?: boolean | Cost$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salonId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    occurredAt?: boolean
    supplierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    supplier?: boolean | Cost$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salonId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    occurredAt?: boolean
    supplierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    supplier?: boolean | Cost$supplierArgs<ExtArgs>
  }, ExtArgs["result"]["cost"]>

  export type CostSelectScalar = {
    id?: boolean
    salonId?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    amountCents?: boolean
    occurredAt?: boolean
    supplierId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salonId" | "type" | "name" | "description" | "amountCents" | "occurredAt" | "supplierId" | "createdAt" | "updatedAt", ExtArgs["result"]["cost"]>
  export type CostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    supplier?: boolean | Cost$supplierArgs<ExtArgs>
  }
  export type CostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    supplier?: boolean | Cost$supplierArgs<ExtArgs>
  }
  export type CostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salon?: boolean | SalonDefaultArgs<ExtArgs>
    supplier?: boolean | Cost$supplierArgs<ExtArgs>
  }

  export type $CostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cost"
    objects: {
      salon: Prisma.$SalonPayload<ExtArgs>
      supplier: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      salonId: string
      type: $Enums.CostType
      name: string
      description: string | null
      amountCents: number
      occurredAt: Date
      supplierId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cost"]>
    composites: {}
  }

  type CostGetPayload<S extends boolean | null | undefined | CostDefaultArgs> = $Result.GetResult<Prisma.$CostPayload, S>

  type CostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostCountAggregateInputType | true
    }

  export interface CostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cost'], meta: { name: 'Cost' } }
    /**
     * Find zero or one Cost that matches the filter.
     * @param {CostFindUniqueArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostFindUniqueArgs>(args: SelectSubset<T, CostFindUniqueArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostFindUniqueOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostFindUniqueOrThrowArgs>(args: SelectSubset<T, CostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostFindFirstArgs>(args?: SelectSubset<T, CostFindFirstArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindFirstOrThrowArgs} args - Arguments to find a Cost
     * @example
     * // Get one Cost
     * const cost = await prisma.cost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostFindFirstOrThrowArgs>(args?: SelectSubset<T, CostFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Costs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Costs
     * const costs = await prisma.cost.findMany()
     * 
     * // Get first 10 Costs
     * const costs = await prisma.cost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costWithIdOnly = await prisma.cost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostFindManyArgs>(args?: SelectSubset<T, CostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cost.
     * @param {CostCreateArgs} args - Arguments to create a Cost.
     * @example
     * // Create one Cost
     * const Cost = await prisma.cost.create({
     *   data: {
     *     // ... data to create a Cost
     *   }
     * })
     * 
     */
    create<T extends CostCreateArgs>(args: SelectSubset<T, CostCreateArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Costs.
     * @param {CostCreateManyArgs} args - Arguments to create many Costs.
     * @example
     * // Create many Costs
     * const cost = await prisma.cost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostCreateManyArgs>(args?: SelectSubset<T, CostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Costs and returns the data saved in the database.
     * @param {CostCreateManyAndReturnArgs} args - Arguments to create many Costs.
     * @example
     * // Create many Costs
     * const cost = await prisma.cost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Costs and only return the `id`
     * const costWithIdOnly = await prisma.cost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostCreateManyAndReturnArgs>(args?: SelectSubset<T, CostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cost.
     * @param {CostDeleteArgs} args - Arguments to delete one Cost.
     * @example
     * // Delete one Cost
     * const Cost = await prisma.cost.delete({
     *   where: {
     *     // ... filter to delete one Cost
     *   }
     * })
     * 
     */
    delete<T extends CostDeleteArgs>(args: SelectSubset<T, CostDeleteArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cost.
     * @param {CostUpdateArgs} args - Arguments to update one Cost.
     * @example
     * // Update one Cost
     * const cost = await prisma.cost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostUpdateArgs>(args: SelectSubset<T, CostUpdateArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Costs.
     * @param {CostDeleteManyArgs} args - Arguments to filter Costs to delete.
     * @example
     * // Delete a few Costs
     * const { count } = await prisma.cost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostDeleteManyArgs>(args?: SelectSubset<T, CostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostUpdateManyArgs>(args: SelectSubset<T, CostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Costs and returns the data updated in the database.
     * @param {CostUpdateManyAndReturnArgs} args - Arguments to update many Costs.
     * @example
     * // Update many Costs
     * const cost = await prisma.cost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Costs and only return the `id`
     * const costWithIdOnly = await prisma.cost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostUpdateManyAndReturnArgs>(args: SelectSubset<T, CostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cost.
     * @param {CostUpsertArgs} args - Arguments to update or create a Cost.
     * @example
     * // Update or create a Cost
     * const cost = await prisma.cost.upsert({
     *   create: {
     *     // ... data to create a Cost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cost we want to update
     *   }
     * })
     */
    upsert<T extends CostUpsertArgs>(args: SelectSubset<T, CostUpsertArgs<ExtArgs>>): Prisma__CostClient<$Result.GetResult<Prisma.$CostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Costs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostCountArgs} args - Arguments to filter Costs to count.
     * @example
     * // Count the number of Costs
     * const count = await prisma.cost.count({
     *   where: {
     *     // ... the filter for the Costs we want to count
     *   }
     * })
    **/
    count<T extends CostCountArgs>(
      args?: Subset<T, CostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostAggregateArgs>(args: Subset<T, CostAggregateArgs>): Prisma.PrismaPromise<GetCostAggregateType<T>>

    /**
     * Group by Cost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostGroupByArgs['orderBy'] }
        : { orderBy?: CostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cost model
   */
  readonly fields: CostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salon<T extends SalonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalonDefaultArgs<ExtArgs>>): Prisma__SalonClient<$Result.GetResult<Prisma.$SalonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    supplier<T extends Cost$supplierArgs<ExtArgs> = {}>(args?: Subset<T, Cost$supplierArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cost model
   */
  interface CostFieldRefs {
    readonly id: FieldRef<"Cost", 'String'>
    readonly salonId: FieldRef<"Cost", 'String'>
    readonly type: FieldRef<"Cost", 'CostType'>
    readonly name: FieldRef<"Cost", 'String'>
    readonly description: FieldRef<"Cost", 'String'>
    readonly amountCents: FieldRef<"Cost", 'Int'>
    readonly occurredAt: FieldRef<"Cost", 'DateTime'>
    readonly supplierId: FieldRef<"Cost", 'String'>
    readonly createdAt: FieldRef<"Cost", 'DateTime'>
    readonly updatedAt: FieldRef<"Cost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cost findUnique
   */
  export type CostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findUniqueOrThrow
   */
  export type CostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost findFirst
   */
  export type CostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost findFirstOrThrow
   */
  export type CostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Cost to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Costs.
     */
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost findMany
   */
  export type CostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter, which Costs to fetch.
     */
    where?: CostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Costs to fetch.
     */
    orderBy?: CostOrderByWithRelationInput | CostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Costs.
     */
    cursor?: CostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Costs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Costs.
     */
    skip?: number
    distinct?: CostScalarFieldEnum | CostScalarFieldEnum[]
  }

  /**
   * Cost create
   */
  export type CostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The data needed to create a Cost.
     */
    data: XOR<CostCreateInput, CostUncheckedCreateInput>
  }

  /**
   * Cost createMany
   */
  export type CostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Costs.
     */
    data: CostCreateManyInput | CostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cost createManyAndReturn
   */
  export type CostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * The data used to create many Costs.
     */
    data: CostCreateManyInput | CostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cost update
   */
  export type CostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The data needed to update a Cost.
     */
    data: XOR<CostUpdateInput, CostUncheckedUpdateInput>
    /**
     * Choose, which Cost to update.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost updateMany
   */
  export type CostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
    /**
     * Limit how many Costs to update.
     */
    limit?: number
  }

  /**
   * Cost updateManyAndReturn
   */
  export type CostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * The data used to update Costs.
     */
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyInput>
    /**
     * Filter which Costs to update
     */
    where?: CostWhereInput
    /**
     * Limit how many Costs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cost upsert
   */
  export type CostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * The filter to search for the Cost to update in case it exists.
     */
    where: CostWhereUniqueInput
    /**
     * In case the Cost found by the `where` argument doesn't exist, create a new Cost with this data.
     */
    create: XOR<CostCreateInput, CostUncheckedCreateInput>
    /**
     * In case the Cost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostUpdateInput, CostUncheckedUpdateInput>
  }

  /**
   * Cost delete
   */
  export type CostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
    /**
     * Filter which Cost to delete.
     */
    where: CostWhereUniqueInput
  }

  /**
   * Cost deleteMany
   */
  export type CostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Costs to delete
     */
    where?: CostWhereInput
    /**
     * Limit how many Costs to delete.
     */
    limit?: number
  }

  /**
   * Cost.supplier
   */
  export type Cost$supplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Cost without action
   */
  export type CostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cost
     */
    select?: CostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cost
     */
    omit?: CostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SalonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    userId: 'userId',
    plan: 'plan',
    planStatus: 'planStatus',
    planEndsAt: 'planEndsAt'
  };

  export type SalonScalarFieldEnum = (typeof SalonScalarFieldEnum)[keyof typeof SalonScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    price: 'price',
    duration: 'duration',
    isActive: 'isActive',
    createdAt: 'createdAt',
    salonId: 'salonId'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    instagram: 'instagram',
    notes: 'notes',
    createdAt: 'createdAt',
    type: 'type',
    salonId: 'salonId'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    salonId: 'salonId',
    clientId: 'clientId',
    serviceId: 'serviceId'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const CashCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    createdAt: 'createdAt',
    salonId: 'salonId'
  };

  export type CashCategoryScalarFieldEnum = (typeof CashCategoryScalarFieldEnum)[keyof typeof CashCategoryScalarFieldEnum]


  export const CashTransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    source: 'source',
    amount: 'amount',
    occurredAt: 'occurredAt',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    salonId: 'salonId',
    categoryId: 'categoryId',
    appointmentId: 'appointmentId'
  };

  export type CashTransactionScalarFieldEnum = (typeof CashTransactionScalarFieldEnum)[keyof typeof CashTransactionScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    salonId: 'salonId',
    subtotalCents: 'subtotalCents',
    discountCents: 'discountCents',
    totalCents: 'totalCents',
    paymentMode: 'paymentMode',
    paymentMethod: 'paymentMethod',
    installmentsCount: 'installmentsCount',
    firstDueDate: 'firstDueDate',
    expectedDeliveryAt: 'expectedDeliveryAt',
    deliveredAt: 'deliveredAt',
    notes: 'notes'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    name: 'name',
    description: 'description',
    quantity: 'quantity',
    unitPriceCents: 'unitPriceCents',
    totalCents: 'totalCents',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const DeliveryScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    status: 'status',
    expectedAt: 'expectedAt',
    deliveredAt: 'deliveredAt',
    address: 'address',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeliveryScalarFieldEnum = (typeof DeliveryScalarFieldEnum)[keyof typeof DeliveryScalarFieldEnum]


  export const ReceivableScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    salonId: 'salonId',
    totalCents: 'totalCents',
    method: 'method',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReceivableScalarFieldEnum = (typeof ReceivableScalarFieldEnum)[keyof typeof ReceivableScalarFieldEnum]


  export const ReceivableInstallmentScalarFieldEnum: {
    id: 'id',
    receivableId: 'receivableId',
    number: 'number',
    dueDate: 'dueDate',
    amountCents: 'amountCents',
    status: 'status',
    paidAt: 'paidAt',
    method: 'method',
    createdAt: 'createdAt'
  };

  export type ReceivableInstallmentScalarFieldEnum = (typeof ReceivableInstallmentScalarFieldEnum)[keyof typeof ReceivableInstallmentScalarFieldEnum]


  export const PayableScalarFieldEnum: {
    id: 'id',
    supplierId: 'supplierId',
    salonId: 'salonId',
    description: 'description',
    totalCents: 'totalCents',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayableScalarFieldEnum = (typeof PayableScalarFieldEnum)[keyof typeof PayableScalarFieldEnum]


  export const PayableInstallmentScalarFieldEnum: {
    id: 'id',
    payableId: 'payableId',
    number: 'number',
    dueDate: 'dueDate',
    amountCents: 'amountCents',
    status: 'status',
    paidAt: 'paidAt',
    method: 'method',
    createdAt: 'createdAt'
  };

  export type PayableInstallmentScalarFieldEnum = (typeof PayableInstallmentScalarFieldEnum)[keyof typeof PayableInstallmentScalarFieldEnum]


  export const CostScalarFieldEnum: {
    id: 'id',
    salonId: 'salonId',
    type: 'type',
    name: 'name',
    description: 'description',
    amountCents: 'amountCents',
    occurredAt: 'occurredAt',
    supplierId: 'supplierId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostScalarFieldEnum = (typeof CostScalarFieldEnum)[keyof typeof CostScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'ClientType[]'
   */
  export type ListEnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType[]'>
    


  /**
   * Reference to a field of type 'CashType'
   */
  export type EnumCashTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashType'>
    


  /**
   * Reference to a field of type 'CashType[]'
   */
  export type ListEnumCashTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashType[]'>
    


  /**
   * Reference to a field of type 'CashSource'
   */
  export type EnumCashSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashSource'>
    


  /**
   * Reference to a field of type 'CashSource[]'
   */
  export type ListEnumCashSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CashSource[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMode'
   */
  export type EnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode'>
    


  /**
   * Reference to a field of type 'PaymentMode[]'
   */
  export type ListEnumPaymentModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMode[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'DeliveryStatus'
   */
  export type EnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus'>
    


  /**
   * Reference to a field of type 'DeliveryStatus[]'
   */
  export type ListEnumDeliveryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeliveryStatus[]'>
    


  /**
   * Reference to a field of type 'InstallmentStatus'
   */
  export type EnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus'>
    


  /**
   * Reference to a field of type 'InstallmentStatus[]'
   */
  export type ListEnumInstallmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallmentStatus[]'>
    


  /**
   * Reference to a field of type 'CostType'
   */
  export type EnumCostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostType'>
    


  /**
   * Reference to a field of type 'CostType[]'
   */
  export type ListEnumCostTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CostType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    salon?: XOR<SalonNullableScalarRelationFilter, SalonWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    salon?: SalonOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    salon?: XOR<SalonNullableScalarRelationFilter, SalonWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SalonWhereInput = {
    AND?: SalonWhereInput | SalonWhereInput[]
    OR?: SalonWhereInput[]
    NOT?: SalonWhereInput | SalonWhereInput[]
    id?: StringFilter<"Salon"> | string
    name?: StringFilter<"Salon"> | string
    createdAt?: DateTimeFilter<"Salon"> | Date | string
    userId?: StringFilter<"Salon"> | string
    plan?: StringFilter<"Salon"> | string
    planStatus?: StringFilter<"Salon"> | string
    planEndsAt?: DateTimeNullableFilter<"Salon"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    services?: ServiceListRelationFilter
    clients?: ClientListRelationFilter
    appointments?: AppointmentListRelationFilter
    cashCategories?: CashCategoryListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    orders?: OrderListRelationFilter
    receivables?: ReceivableListRelationFilter
    payables?: PayableListRelationFilter
    costs?: CostListRelationFilter
  }

  export type SalonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    planStatus?: SortOrder
    planEndsAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    services?: ServiceOrderByRelationAggregateInput
    clients?: ClientOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    cashCategories?: CashCategoryOrderByRelationAggregateInput
    cashTransactions?: CashTransactionOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    receivables?: ReceivableOrderByRelationAggregateInput
    payables?: PayableOrderByRelationAggregateInput
    costs?: CostOrderByRelationAggregateInput
  }

  export type SalonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: SalonWhereInput | SalonWhereInput[]
    OR?: SalonWhereInput[]
    NOT?: SalonWhereInput | SalonWhereInput[]
    name?: StringFilter<"Salon"> | string
    createdAt?: DateTimeFilter<"Salon"> | Date | string
    plan?: StringFilter<"Salon"> | string
    planStatus?: StringFilter<"Salon"> | string
    planEndsAt?: DateTimeNullableFilter<"Salon"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    services?: ServiceListRelationFilter
    clients?: ClientListRelationFilter
    appointments?: AppointmentListRelationFilter
    cashCategories?: CashCategoryListRelationFilter
    cashTransactions?: CashTransactionListRelationFilter
    orders?: OrderListRelationFilter
    receivables?: ReceivableListRelationFilter
    payables?: PayableListRelationFilter
    costs?: CostListRelationFilter
  }, "id" | "userId">

  export type SalonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    planStatus?: SortOrder
    planEndsAt?: SortOrderInput | SortOrder
    _count?: SalonCountOrderByAggregateInput
    _max?: SalonMaxOrderByAggregateInput
    _min?: SalonMinOrderByAggregateInput
  }

  export type SalonScalarWhereWithAggregatesInput = {
    AND?: SalonScalarWhereWithAggregatesInput | SalonScalarWhereWithAggregatesInput[]
    OR?: SalonScalarWhereWithAggregatesInput[]
    NOT?: SalonScalarWhereWithAggregatesInput | SalonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Salon"> | string
    name?: StringWithAggregatesFilter<"Salon"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Salon"> | Date | string
    userId?: StringWithAggregatesFilter<"Salon"> | string
    plan?: StringWithAggregatesFilter<"Salon"> | string
    planStatus?: StringWithAggregatesFilter<"Salon"> | string
    planEndsAt?: DateTimeNullableWithAggregatesFilter<"Salon"> | Date | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    category?: StringNullableFilter<"Service"> | string | null
    price?: IntFilter<"Service"> | number
    duration?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    salonId?: StringFilter<"Service"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    appointments?: AppointmentListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    salon?: SalonOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    category?: StringNullableFilter<"Service"> | string | null
    price?: IntFilter<"Service"> | number
    duration?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    salonId?: StringFilter<"Service"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    appointments?: AppointmentListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    category?: StringNullableWithAggregatesFilter<"Service"> | string | null
    price?: IntWithAggregatesFilter<"Service"> | number
    duration?: IntWithAggregatesFilter<"Service"> | number
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    salonId?: StringWithAggregatesFilter<"Service"> | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    instagram?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    salonId?: StringFilter<"Client"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    appointments?: AppointmentListRelationFilter
    orders?: OrderListRelationFilter
    payables?: PayableListRelationFilter
    costs?: CostListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    instagram?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    salonId?: SortOrder
    salon?: SalonOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    payables?: PayableOrderByRelationAggregateInput
    costs?: CostOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    instagram?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    salonId?: StringFilter<"Client"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    appointments?: AppointmentListRelationFilter
    orders?: OrderListRelationFilter
    payables?: PayableListRelationFilter
    costs?: CostListRelationFilter
  }, "id">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    instagram?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    salonId?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    phone?: StringWithAggregatesFilter<"Client"> | string
    instagram?: StringNullableWithAggregatesFilter<"Client"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Client"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    type?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    salonId?: StringWithAggregatesFilter<"Client"> | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    startAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeFilter<"Appointment"> | Date | string
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    salonId?: StringFilter<"Appointment"> | string
    clientId?: StringFilter<"Appointment"> | string
    serviceId?: StringFilter<"Appointment"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    cashTransaction?: XOR<CashTransactionNullableScalarRelationFilter, CashTransactionWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    salon?: SalonOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    cashTransaction?: CashTransactionOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    startAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeFilter<"Appointment"> | Date | string
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    salonId?: StringFilter<"Appointment"> | string
    clientId?: StringFilter<"Appointment"> | string
    serviceId?: StringFilter<"Appointment"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    cashTransaction?: XOR<CashTransactionNullableScalarRelationFilter, CashTransactionWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    startAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    status?: StringWithAggregatesFilter<"Appointment"> | string
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    salonId?: StringWithAggregatesFilter<"Appointment"> | string
    clientId?: StringWithAggregatesFilter<"Appointment"> | string
    serviceId?: StringWithAggregatesFilter<"Appointment"> | string
  }

  export type CashCategoryWhereInput = {
    AND?: CashCategoryWhereInput | CashCategoryWhereInput[]
    OR?: CashCategoryWhereInput[]
    NOT?: CashCategoryWhereInput | CashCategoryWhereInput[]
    id?: StringFilter<"CashCategory"> | string
    name?: StringFilter<"CashCategory"> | string
    type?: EnumCashTypeFilter<"CashCategory"> | $Enums.CashType
    createdAt?: DateTimeFilter<"CashCategory"> | Date | string
    salonId?: StringFilter<"CashCategory"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    transactions?: CashTransactionListRelationFilter
  }

  export type CashCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    salon?: SalonOrderByWithRelationInput
    transactions?: CashTransactionOrderByRelationAggregateInput
  }

  export type CashCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    salonId_name_type?: CashCategorySalonIdNameTypeCompoundUniqueInput
    AND?: CashCategoryWhereInput | CashCategoryWhereInput[]
    OR?: CashCategoryWhereInput[]
    NOT?: CashCategoryWhereInput | CashCategoryWhereInput[]
    name?: StringFilter<"CashCategory"> | string
    type?: EnumCashTypeFilter<"CashCategory"> | $Enums.CashType
    createdAt?: DateTimeFilter<"CashCategory"> | Date | string
    salonId?: StringFilter<"CashCategory"> | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    transactions?: CashTransactionListRelationFilter
  }, "id" | "salonId_name_type">

  export type CashCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    _count?: CashCategoryCountOrderByAggregateInput
    _max?: CashCategoryMaxOrderByAggregateInput
    _min?: CashCategoryMinOrderByAggregateInput
  }

  export type CashCategoryScalarWhereWithAggregatesInput = {
    AND?: CashCategoryScalarWhereWithAggregatesInput | CashCategoryScalarWhereWithAggregatesInput[]
    OR?: CashCategoryScalarWhereWithAggregatesInput[]
    NOT?: CashCategoryScalarWhereWithAggregatesInput | CashCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashCategory"> | string
    name?: StringWithAggregatesFilter<"CashCategory"> | string
    type?: EnumCashTypeWithAggregatesFilter<"CashCategory"> | $Enums.CashType
    createdAt?: DateTimeWithAggregatesFilter<"CashCategory"> | Date | string
    salonId?: StringWithAggregatesFilter<"CashCategory"> | string
  }

  export type CashTransactionWhereInput = {
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    id?: StringFilter<"CashTransaction"> | string
    type?: EnumCashTypeFilter<"CashTransaction"> | $Enums.CashType
    source?: EnumCashSourceFilter<"CashTransaction"> | $Enums.CashSource
    amount?: IntFilter<"CashTransaction"> | number
    occurredAt?: DateTimeFilter<"CashTransaction"> | Date | string
    description?: StringNullableFilter<"CashTransaction"> | string | null
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CashTransaction"> | Date | string
    salonId?: StringFilter<"CashTransaction"> | string
    categoryId?: StringNullableFilter<"CashTransaction"> | string | null
    appointmentId?: StringNullableFilter<"CashTransaction"> | string | null
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    category?: XOR<CashCategoryNullableScalarRelationFilter, CashCategoryWhereInput> | null
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }

  export type CashTransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    occurredAt?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salonId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    salon?: SalonOrderByWithRelationInput
    category?: CashCategoryOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type CashTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: CashTransactionWhereInput | CashTransactionWhereInput[]
    OR?: CashTransactionWhereInput[]
    NOT?: CashTransactionWhereInput | CashTransactionWhereInput[]
    type?: EnumCashTypeFilter<"CashTransaction"> | $Enums.CashType
    source?: EnumCashSourceFilter<"CashTransaction"> | $Enums.CashSource
    amount?: IntFilter<"CashTransaction"> | number
    occurredAt?: DateTimeFilter<"CashTransaction"> | Date | string
    description?: StringNullableFilter<"CashTransaction"> | string | null
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CashTransaction"> | Date | string
    salonId?: StringFilter<"CashTransaction"> | string
    categoryId?: StringNullableFilter<"CashTransaction"> | string | null
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    category?: XOR<CashCategoryNullableScalarRelationFilter, CashCategoryWhereInput> | null
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
  }, "id" | "appointmentId">

  export type CashTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    occurredAt?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salonId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    _count?: CashTransactionCountOrderByAggregateInput
    _avg?: CashTransactionAvgOrderByAggregateInput
    _max?: CashTransactionMaxOrderByAggregateInput
    _min?: CashTransactionMinOrderByAggregateInput
    _sum?: CashTransactionSumOrderByAggregateInput
  }

  export type CashTransactionScalarWhereWithAggregatesInput = {
    AND?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    OR?: CashTransactionScalarWhereWithAggregatesInput[]
    NOT?: CashTransactionScalarWhereWithAggregatesInput | CashTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CashTransaction"> | string
    type?: EnumCashTypeWithAggregatesFilter<"CashTransaction"> | $Enums.CashType
    source?: EnumCashSourceWithAggregatesFilter<"CashTransaction"> | $Enums.CashSource
    amount?: IntWithAggregatesFilter<"CashTransaction"> | number
    occurredAt?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CashTransaction"> | Date | string
    salonId?: StringWithAggregatesFilter<"CashTransaction"> | string
    categoryId?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
    appointmentId?: StringNullableWithAggregatesFilter<"CashTransaction"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    clientId?: StringFilter<"Order"> | string
    salonId?: StringFilter<"Order"> | string
    subtotalCents?: IntFilter<"Order"> | number
    discountCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    paymentMode?: EnumPaymentModeFilter<"Order"> | $Enums.PaymentMode
    paymentMethod?: EnumPaymentMethodNullableFilter<"Order"> | $Enums.PaymentMethod | null
    installmentsCount?: IntFilter<"Order"> | number
    firstDueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    expectedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    items?: OrderItemListRelationFilter
    deliveries?: DeliveryListRelationFilter
    receivables?: ReceivableListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    salonId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    paymentMode?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    installmentsCount?: SortOrder
    firstDueDate?: SortOrderInput | SortOrder
    expectedDeliveryAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    salon?: SalonOrderByWithRelationInput
    items?: OrderItemOrderByRelationAggregateInput
    deliveries?: DeliveryOrderByRelationAggregateInput
    receivables?: ReceivableOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    clientId?: StringFilter<"Order"> | string
    salonId?: StringFilter<"Order"> | string
    subtotalCents?: IntFilter<"Order"> | number
    discountCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    paymentMode?: EnumPaymentModeFilter<"Order"> | $Enums.PaymentMode
    paymentMethod?: EnumPaymentMethodNullableFilter<"Order"> | $Enums.PaymentMethod | null
    installmentsCount?: IntFilter<"Order"> | number
    firstDueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    expectedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    items?: OrderItemListRelationFilter
    deliveries?: DeliveryListRelationFilter
    receivables?: ReceivableListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    salonId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    paymentMode?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    installmentsCount?: SortOrder
    firstDueDate?: SortOrderInput | SortOrder
    expectedDeliveryAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    clientId?: StringWithAggregatesFilter<"Order"> | string
    salonId?: StringWithAggregatesFilter<"Order"> | string
    subtotalCents?: IntWithAggregatesFilter<"Order"> | number
    discountCents?: IntWithAggregatesFilter<"Order"> | number
    totalCents?: IntWithAggregatesFilter<"Order"> | number
    paymentMode?: EnumPaymentModeWithAggregatesFilter<"Order"> | $Enums.PaymentMode
    paymentMethod?: EnumPaymentMethodNullableWithAggregatesFilter<"Order"> | $Enums.PaymentMethod | null
    installmentsCount?: IntWithAggregatesFilter<"Order"> | number
    firstDueDate?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    expectedDeliveryAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Order"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    unitPriceCents?: IntFilter<"OrderItem"> | number
    totalCents?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    unitPriceCents?: IntFilter<"OrderItem"> | number
    totalCents?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    name?: StringWithAggregatesFilter<"OrderItem"> | string
    description?: StringNullableWithAggregatesFilter<"OrderItem"> | string | null
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPriceCents?: IntWithAggregatesFilter<"OrderItem"> | number
    totalCents?: IntWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type DeliveryWhereInput = {
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    id?: StringFilter<"Delivery"> | string
    orderId?: StringFilter<"Delivery"> | string
    status?: EnumDeliveryStatusFilter<"Delivery"> | $Enums.DeliveryStatus
    expectedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    address?: StringNullableFilter<"Delivery"> | string | null
    notes?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type DeliveryOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    expectedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type DeliveryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DeliveryWhereInput | DeliveryWhereInput[]
    OR?: DeliveryWhereInput[]
    NOT?: DeliveryWhereInput | DeliveryWhereInput[]
    orderId?: StringFilter<"Delivery"> | string
    status?: EnumDeliveryStatusFilter<"Delivery"> | $Enums.DeliveryStatus
    expectedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    address?: StringNullableFilter<"Delivery"> | string | null
    notes?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type DeliveryOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    expectedAt?: SortOrderInput | SortOrder
    deliveredAt?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeliveryCountOrderByAggregateInput
    _max?: DeliveryMaxOrderByAggregateInput
    _min?: DeliveryMinOrderByAggregateInput
  }

  export type DeliveryScalarWhereWithAggregatesInput = {
    AND?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    OR?: DeliveryScalarWhereWithAggregatesInput[]
    NOT?: DeliveryScalarWhereWithAggregatesInput | DeliveryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Delivery"> | string
    orderId?: StringWithAggregatesFilter<"Delivery"> | string
    status?: EnumDeliveryStatusWithAggregatesFilter<"Delivery"> | $Enums.DeliveryStatus
    expectedAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableWithAggregatesFilter<"Delivery"> | Date | string | null
    address?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Delivery"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Delivery"> | Date | string
  }

  export type ReceivableWhereInput = {
    AND?: ReceivableWhereInput | ReceivableWhereInput[]
    OR?: ReceivableWhereInput[]
    NOT?: ReceivableWhereInput | ReceivableWhereInput[]
    id?: StringFilter<"Receivable"> | string
    orderId?: StringFilter<"Receivable"> | string
    salonId?: StringFilter<"Receivable"> | string
    totalCents?: IntFilter<"Receivable"> | number
    method?: EnumPaymentMethodNullableFilter<"Receivable"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"Receivable"> | Date | string
    updatedAt?: DateTimeFilter<"Receivable"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    installments?: ReceivableInstallmentListRelationFilter
  }

  export type ReceivableOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    salonId?: SortOrder
    totalCents?: SortOrder
    method?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    salon?: SalonOrderByWithRelationInput
    installments?: ReceivableInstallmentOrderByRelationAggregateInput
  }

  export type ReceivableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceivableWhereInput | ReceivableWhereInput[]
    OR?: ReceivableWhereInput[]
    NOT?: ReceivableWhereInput | ReceivableWhereInput[]
    orderId?: StringFilter<"Receivable"> | string
    salonId?: StringFilter<"Receivable"> | string
    totalCents?: IntFilter<"Receivable"> | number
    method?: EnumPaymentMethodNullableFilter<"Receivable"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"Receivable"> | Date | string
    updatedAt?: DateTimeFilter<"Receivable"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    installments?: ReceivableInstallmentListRelationFilter
  }, "id">

  export type ReceivableOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    salonId?: SortOrder
    totalCents?: SortOrder
    method?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReceivableCountOrderByAggregateInput
    _avg?: ReceivableAvgOrderByAggregateInput
    _max?: ReceivableMaxOrderByAggregateInput
    _min?: ReceivableMinOrderByAggregateInput
    _sum?: ReceivableSumOrderByAggregateInput
  }

  export type ReceivableScalarWhereWithAggregatesInput = {
    AND?: ReceivableScalarWhereWithAggregatesInput | ReceivableScalarWhereWithAggregatesInput[]
    OR?: ReceivableScalarWhereWithAggregatesInput[]
    NOT?: ReceivableScalarWhereWithAggregatesInput | ReceivableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Receivable"> | string
    orderId?: StringWithAggregatesFilter<"Receivable"> | string
    salonId?: StringWithAggregatesFilter<"Receivable"> | string
    totalCents?: IntWithAggregatesFilter<"Receivable"> | number
    method?: EnumPaymentMethodNullableWithAggregatesFilter<"Receivable"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeWithAggregatesFilter<"Receivable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Receivable"> | Date | string
  }

  export type ReceivableInstallmentWhereInput = {
    AND?: ReceivableInstallmentWhereInput | ReceivableInstallmentWhereInput[]
    OR?: ReceivableInstallmentWhereInput[]
    NOT?: ReceivableInstallmentWhereInput | ReceivableInstallmentWhereInput[]
    id?: StringFilter<"ReceivableInstallment"> | string
    receivableId?: StringFilter<"ReceivableInstallment"> | string
    number?: IntFilter<"ReceivableInstallment"> | number
    dueDate?: DateTimeFilter<"ReceivableInstallment"> | Date | string
    amountCents?: IntFilter<"ReceivableInstallment"> | number
    status?: EnumInstallmentStatusFilter<"ReceivableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableFilter<"ReceivableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableFilter<"ReceivableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"ReceivableInstallment"> | Date | string
    receivable?: XOR<ReceivableScalarRelationFilter, ReceivableWhereInput>
  }

  export type ReceivableInstallmentOrderByWithRelationInput = {
    id?: SortOrder
    receivableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    receivable?: ReceivableOrderByWithRelationInput
  }

  export type ReceivableInstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReceivableInstallmentWhereInput | ReceivableInstallmentWhereInput[]
    OR?: ReceivableInstallmentWhereInput[]
    NOT?: ReceivableInstallmentWhereInput | ReceivableInstallmentWhereInput[]
    receivableId?: StringFilter<"ReceivableInstallment"> | string
    number?: IntFilter<"ReceivableInstallment"> | number
    dueDate?: DateTimeFilter<"ReceivableInstallment"> | Date | string
    amountCents?: IntFilter<"ReceivableInstallment"> | number
    status?: EnumInstallmentStatusFilter<"ReceivableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableFilter<"ReceivableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableFilter<"ReceivableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"ReceivableInstallment"> | Date | string
    receivable?: XOR<ReceivableScalarRelationFilter, ReceivableWhereInput>
  }, "id">

  export type ReceivableInstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    receivableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReceivableInstallmentCountOrderByAggregateInput
    _avg?: ReceivableInstallmentAvgOrderByAggregateInput
    _max?: ReceivableInstallmentMaxOrderByAggregateInput
    _min?: ReceivableInstallmentMinOrderByAggregateInput
    _sum?: ReceivableInstallmentSumOrderByAggregateInput
  }

  export type ReceivableInstallmentScalarWhereWithAggregatesInput = {
    AND?: ReceivableInstallmentScalarWhereWithAggregatesInput | ReceivableInstallmentScalarWhereWithAggregatesInput[]
    OR?: ReceivableInstallmentScalarWhereWithAggregatesInput[]
    NOT?: ReceivableInstallmentScalarWhereWithAggregatesInput | ReceivableInstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReceivableInstallment"> | string
    receivableId?: StringWithAggregatesFilter<"ReceivableInstallment"> | string
    number?: IntWithAggregatesFilter<"ReceivableInstallment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"ReceivableInstallment"> | Date | string
    amountCents?: IntWithAggregatesFilter<"ReceivableInstallment"> | number
    status?: EnumInstallmentStatusWithAggregatesFilter<"ReceivableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableWithAggregatesFilter<"ReceivableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableWithAggregatesFilter<"ReceivableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeWithAggregatesFilter<"ReceivableInstallment"> | Date | string
  }

  export type PayableWhereInput = {
    AND?: PayableWhereInput | PayableWhereInput[]
    OR?: PayableWhereInput[]
    NOT?: PayableWhereInput | PayableWhereInput[]
    id?: StringFilter<"Payable"> | string
    supplierId?: StringNullableFilter<"Payable"> | string | null
    salonId?: StringFilter<"Payable"> | string
    description?: StringFilter<"Payable"> | string
    totalCents?: IntFilter<"Payable"> | number
    createdAt?: DateTimeFilter<"Payable"> | Date | string
    updatedAt?: DateTimeFilter<"Payable"> | Date | string
    supplier?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    installments?: PayableInstallmentListRelationFilter
  }

  export type PayableOrderByWithRelationInput = {
    id?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    salonId?: SortOrder
    description?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    supplier?: ClientOrderByWithRelationInput
    salon?: SalonOrderByWithRelationInput
    installments?: PayableInstallmentOrderByRelationAggregateInput
  }

  export type PayableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayableWhereInput | PayableWhereInput[]
    OR?: PayableWhereInput[]
    NOT?: PayableWhereInput | PayableWhereInput[]
    supplierId?: StringNullableFilter<"Payable"> | string | null
    salonId?: StringFilter<"Payable"> | string
    description?: StringFilter<"Payable"> | string
    totalCents?: IntFilter<"Payable"> | number
    createdAt?: DateTimeFilter<"Payable"> | Date | string
    updatedAt?: DateTimeFilter<"Payable"> | Date | string
    supplier?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    installments?: PayableInstallmentListRelationFilter
  }, "id">

  export type PayableOrderByWithAggregationInput = {
    id?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    salonId?: SortOrder
    description?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayableCountOrderByAggregateInput
    _avg?: PayableAvgOrderByAggregateInput
    _max?: PayableMaxOrderByAggregateInput
    _min?: PayableMinOrderByAggregateInput
    _sum?: PayableSumOrderByAggregateInput
  }

  export type PayableScalarWhereWithAggregatesInput = {
    AND?: PayableScalarWhereWithAggregatesInput | PayableScalarWhereWithAggregatesInput[]
    OR?: PayableScalarWhereWithAggregatesInput[]
    NOT?: PayableScalarWhereWithAggregatesInput | PayableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payable"> | string
    supplierId?: StringNullableWithAggregatesFilter<"Payable"> | string | null
    salonId?: StringWithAggregatesFilter<"Payable"> | string
    description?: StringWithAggregatesFilter<"Payable"> | string
    totalCents?: IntWithAggregatesFilter<"Payable"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Payable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payable"> | Date | string
  }

  export type PayableInstallmentWhereInput = {
    AND?: PayableInstallmentWhereInput | PayableInstallmentWhereInput[]
    OR?: PayableInstallmentWhereInput[]
    NOT?: PayableInstallmentWhereInput | PayableInstallmentWhereInput[]
    id?: StringFilter<"PayableInstallment"> | string
    payableId?: StringFilter<"PayableInstallment"> | string
    number?: IntFilter<"PayableInstallment"> | number
    dueDate?: DateTimeFilter<"PayableInstallment"> | Date | string
    amountCents?: IntFilter<"PayableInstallment"> | number
    status?: EnumInstallmentStatusFilter<"PayableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableFilter<"PayableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableFilter<"PayableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"PayableInstallment"> | Date | string
    payable?: XOR<PayableScalarRelationFilter, PayableWhereInput>
  }

  export type PayableInstallmentOrderByWithRelationInput = {
    id?: SortOrder
    payableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    payable?: PayableOrderByWithRelationInput
  }

  export type PayableInstallmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayableInstallmentWhereInput | PayableInstallmentWhereInput[]
    OR?: PayableInstallmentWhereInput[]
    NOT?: PayableInstallmentWhereInput | PayableInstallmentWhereInput[]
    payableId?: StringFilter<"PayableInstallment"> | string
    number?: IntFilter<"PayableInstallment"> | number
    dueDate?: DateTimeFilter<"PayableInstallment"> | Date | string
    amountCents?: IntFilter<"PayableInstallment"> | number
    status?: EnumInstallmentStatusFilter<"PayableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableFilter<"PayableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableFilter<"PayableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"PayableInstallment"> | Date | string
    payable?: XOR<PayableScalarRelationFilter, PayableWhereInput>
  }, "id">

  export type PayableInstallmentOrderByWithAggregationInput = {
    id?: SortOrder
    payableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    method?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PayableInstallmentCountOrderByAggregateInput
    _avg?: PayableInstallmentAvgOrderByAggregateInput
    _max?: PayableInstallmentMaxOrderByAggregateInput
    _min?: PayableInstallmentMinOrderByAggregateInput
    _sum?: PayableInstallmentSumOrderByAggregateInput
  }

  export type PayableInstallmentScalarWhereWithAggregatesInput = {
    AND?: PayableInstallmentScalarWhereWithAggregatesInput | PayableInstallmentScalarWhereWithAggregatesInput[]
    OR?: PayableInstallmentScalarWhereWithAggregatesInput[]
    NOT?: PayableInstallmentScalarWhereWithAggregatesInput | PayableInstallmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayableInstallment"> | string
    payableId?: StringWithAggregatesFilter<"PayableInstallment"> | string
    number?: IntWithAggregatesFilter<"PayableInstallment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"PayableInstallment"> | Date | string
    amountCents?: IntWithAggregatesFilter<"PayableInstallment"> | number
    status?: EnumInstallmentStatusWithAggregatesFilter<"PayableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableWithAggregatesFilter<"PayableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableWithAggregatesFilter<"PayableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeWithAggregatesFilter<"PayableInstallment"> | Date | string
  }

  export type CostWhereInput = {
    AND?: CostWhereInput | CostWhereInput[]
    OR?: CostWhereInput[]
    NOT?: CostWhereInput | CostWhereInput[]
    id?: StringFilter<"Cost"> | string
    salonId?: StringFilter<"Cost"> | string
    type?: EnumCostTypeFilter<"Cost"> | $Enums.CostType
    name?: StringFilter<"Cost"> | string
    description?: StringNullableFilter<"Cost"> | string | null
    amountCents?: IntFilter<"Cost"> | number
    occurredAt?: DateTimeFilter<"Cost"> | Date | string
    supplierId?: StringNullableFilter<"Cost"> | string | null
    createdAt?: DateTimeFilter<"Cost"> | Date | string
    updatedAt?: DateTimeFilter<"Cost"> | Date | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    supplier?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type CostOrderByWithRelationInput = {
    id?: SortOrder
    salonId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    occurredAt?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salon?: SalonOrderByWithRelationInput
    supplier?: ClientOrderByWithRelationInput
  }

  export type CostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CostWhereInput | CostWhereInput[]
    OR?: CostWhereInput[]
    NOT?: CostWhereInput | CostWhereInput[]
    salonId?: StringFilter<"Cost"> | string
    type?: EnumCostTypeFilter<"Cost"> | $Enums.CostType
    name?: StringFilter<"Cost"> | string
    description?: StringNullableFilter<"Cost"> | string | null
    amountCents?: IntFilter<"Cost"> | number
    occurredAt?: DateTimeFilter<"Cost"> | Date | string
    supplierId?: StringNullableFilter<"Cost"> | string | null
    createdAt?: DateTimeFilter<"Cost"> | Date | string
    updatedAt?: DateTimeFilter<"Cost"> | Date | string
    salon?: XOR<SalonScalarRelationFilter, SalonWhereInput>
    supplier?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type CostOrderByWithAggregationInput = {
    id?: SortOrder
    salonId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    amountCents?: SortOrder
    occurredAt?: SortOrder
    supplierId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostCountOrderByAggregateInput
    _avg?: CostAvgOrderByAggregateInput
    _max?: CostMaxOrderByAggregateInput
    _min?: CostMinOrderByAggregateInput
    _sum?: CostSumOrderByAggregateInput
  }

  export type CostScalarWhereWithAggregatesInput = {
    AND?: CostScalarWhereWithAggregatesInput | CostScalarWhereWithAggregatesInput[]
    OR?: CostScalarWhereWithAggregatesInput[]
    NOT?: CostScalarWhereWithAggregatesInput | CostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cost"> | string
    salonId?: StringWithAggregatesFilter<"Cost"> | string
    type?: EnumCostTypeWithAggregatesFilter<"Cost"> | $Enums.CostType
    name?: StringWithAggregatesFilter<"Cost"> | string
    description?: StringNullableWithAggregatesFilter<"Cost"> | string | null
    amountCents?: IntWithAggregatesFilter<"Cost"> | number
    occurredAt?: DateTimeWithAggregatesFilter<"Cost"> | Date | string
    supplierId?: StringNullableWithAggregatesFilter<"Cost"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cost"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    createdAt?: Date | string
    salon?: SalonCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    createdAt?: Date | string
    salon?: SalonUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalonCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type SalonCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
  }

  export type SalonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SalonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutServicesInput
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    salonId: string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutServicesNestedInput
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    salonId: string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salon: SalonCreateNestedOneWithoutClientsInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    payables?: PayableCreateNestedManyWithoutSupplierInput
    costs?: CostCreateNestedManyWithoutSupplierInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salonId: string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    payables?: PayableUncheckedCreateNestedManyWithoutSupplierInput
    costs?: CostUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salon?: SalonUpdateOneRequiredWithoutClientsNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    payables?: PayableUpdateManyWithoutSupplierNestedInput
    costs?: CostUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salonId?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSupplierNestedInput
    costs?: CostUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salonId: string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salonId?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentCreateInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutAppointmentsInput
    client: ClientCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    cashTransaction?: CashTransactionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    clientId: string
    serviceId: string
    cashTransaction?: CashTransactionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    cashTransaction?: CashTransactionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cashTransaction?: CashTransactionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    clientId: string
    serviceId: string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type CashCategoryCreateInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutCashCategoriesInput
    transactions?: CashTransactionCreateNestedManyWithoutCategoryInput
  }

  export type CashCategoryUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    salonId: string
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CashCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCashCategoriesNestedInput
    transactions?: CashTransactionUpdateManyWithoutCategoryNestedInput
  }

  export type CashCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    transactions?: CashTransactionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CashCategoryCreateManyInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    salonId: string
  }

  export type CashCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionCreateInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutCashTransactionsInput
    category?: CashCategoryCreateNestedOneWithoutTransactionsInput
    appointment?: AppointmentCreateNestedOneWithoutCashTransactionInput
  }

  export type CashTransactionUncheckedCreateInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    categoryId?: string | null
    appointmentId?: string | null
  }

  export type CashTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCashTransactionsNestedInput
    category?: CashCategoryUpdateOneWithoutTransactionsNestedInput
    appointment?: AppointmentUpdateOneWithoutCashTransactionNestedInput
  }

  export type CashTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashTransactionCreateManyInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    categoryId?: string | null
    appointmentId?: string | null
  }

  export type CashTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    salon: SalonCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryCreateNestedManyWithoutOrderInput
    receivables?: ReceivableCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutOrderInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    salon?: SalonUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    unitPriceCents?: number
    totalCents?: number
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    name: string
    description?: string | null
    quantity?: number
    unitPriceCents?: number
    totalCents?: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    name: string
    description?: string | null
    quantity?: number
    unitPriceCents?: number
    totalCents?: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryCreateInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    expectedAt?: Date | string | null
    deliveredAt?: Date | string | null
    address?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutDeliveriesInput
  }

  export type DeliveryUncheckedCreateInput = {
    id?: string
    orderId: string
    status?: $Enums.DeliveryStatus
    expectedAt?: Date | string | null
    deliveredAt?: Date | string | null
    address?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveriesNestedInput
  }

  export type DeliveryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryCreateManyInput = {
    id?: string
    orderId: string
    status?: $Enums.DeliveryStatus
    expectedAt?: Date | string | null
    deliveredAt?: Date | string | null
    address?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableCreateInput = {
    id?: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReceivablesInput
    salon: SalonCreateNestedOneWithoutReceivablesInput
    installments?: ReceivableInstallmentCreateNestedManyWithoutReceivableInput
  }

  export type ReceivableUncheckedCreateInput = {
    id?: string
    orderId: string
    salonId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: ReceivableInstallmentUncheckedCreateNestedManyWithoutReceivableInput
  }

  export type ReceivableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReceivablesNestedInput
    salon?: SalonUpdateOneRequiredWithoutReceivablesNestedInput
    installments?: ReceivableInstallmentUpdateManyWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: ReceivableInstallmentUncheckedUpdateManyWithoutReceivableNestedInput
  }

  export type ReceivableCreateManyInput = {
    id?: string
    orderId: string
    salonId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableInstallmentCreateInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    receivable: ReceivableCreateNestedOneWithoutInstallmentsInput
  }

  export type ReceivableInstallmentUncheckedCreateInput = {
    id?: string
    receivableId: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type ReceivableInstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    receivable?: ReceivableUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type ReceivableInstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivableId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableInstallmentCreateManyInput = {
    id?: string
    receivableId: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type ReceivableInstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableInstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    receivableId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableCreateInput = {
    id?: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: ClientCreateNestedOneWithoutPayablesInput
    salon: SalonCreateNestedOneWithoutPayablesInput
    installments?: PayableInstallmentCreateNestedManyWithoutPayableInput
  }

  export type PayableUncheckedCreateInput = {
    id?: string
    supplierId?: string | null
    salonId: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: PayableInstallmentUncheckedCreateNestedManyWithoutPayableInput
  }

  export type PayableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: ClientUpdateOneWithoutPayablesNestedInput
    salon?: SalonUpdateOneRequiredWithoutPayablesNestedInput
    installments?: PayableInstallmentUpdateManyWithoutPayableNestedInput
  }

  export type PayableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    salonId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: PayableInstallmentUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type PayableCreateManyInput = {
    id?: string
    supplierId?: string | null
    salonId: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    salonId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableInstallmentCreateInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    payable: PayableCreateNestedOneWithoutInstallmentsInput
  }

  export type PayableInstallmentUncheckedCreateInput = {
    id?: string
    payableId: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type PayableInstallmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payable?: PayableUpdateOneRequiredWithoutInstallmentsNestedInput
  }

  export type PayableInstallmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payableId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableInstallmentCreateManyInput = {
    id?: string
    payableId: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type PayableInstallmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableInstallmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payableId?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCreateInput = {
    id?: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutCostsInput
    supplier?: ClientCreateNestedOneWithoutCostsInput
  }

  export type CostUncheckedCreateInput = {
    id?: string
    salonId: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    supplierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCostsNestedInput
    supplier?: ClientUpdateOneWithoutCostsNestedInput
  }

  export type CostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostCreateManyInput = {
    id?: string
    salonId: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    supplierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SalonNullableScalarRelationFilter = {
    is?: SalonWhereInput | null
    isNot?: SalonWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ClientListRelationFilter = {
    every?: ClientWhereInput
    some?: ClientWhereInput
    none?: ClientWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type CashCategoryListRelationFilter = {
    every?: CashCategoryWhereInput
    some?: CashCategoryWhereInput
    none?: CashCategoryWhereInput
  }

  export type CashTransactionListRelationFilter = {
    every?: CashTransactionWhereInput
    some?: CashTransactionWhereInput
    none?: CashTransactionWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReceivableListRelationFilter = {
    every?: ReceivableWhereInput
    some?: ReceivableWhereInput
    none?: ReceivableWhereInput
  }

  export type PayableListRelationFilter = {
    every?: PayableWhereInput
    some?: PayableWhereInput
    none?: PayableWhereInput
  }

  export type CostListRelationFilter = {
    every?: CostWhereInput
    some?: CostWhereInput
    none?: CostWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CashTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    planStatus?: SortOrder
    planEndsAt?: SortOrder
  }

  export type SalonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    planStatus?: SortOrder
    planEndsAt?: SortOrder
  }

  export type SalonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    plan?: SortOrder
    planStatus?: SortOrder
    planEndsAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SalonScalarRelationFilter = {
    is?: SalonWhereInput
    isNot?: SalonWhereInput
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    price?: SortOrder
    duration?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    instagram?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    salonId?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    instagram?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    salonId?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    instagram?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    salonId?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type CashTransactionNullableScalarRelationFilter = {
    is?: CashTransactionWhereInput | null
    isNot?: CashTransactionWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
  }

  export type EnumCashTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashType | EnumCashTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashTypeFilter<$PrismaModel> | $Enums.CashType
  }

  export type CashCategorySalonIdNameTypeCompoundUniqueInput = {
    salonId: string
    name: string
    type: $Enums.CashType
  }

  export type CashCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
  }

  export type CashCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
  }

  export type CashCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    salonId?: SortOrder
  }

  export type EnumCashTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashType | EnumCashTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashTypeFilter<$PrismaModel>
    _max?: NestedEnumCashTypeFilter<$PrismaModel>
  }

  export type EnumCashSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CashSource | EnumCashSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCashSourceFilter<$PrismaModel> | $Enums.CashSource
  }

  export type CashCategoryNullableScalarRelationFilter = {
    is?: CashCategoryWhereInput | null
    isNot?: CashCategoryWhereInput | null
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type CashTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    occurredAt?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salonId?: SortOrder
    categoryId?: SortOrder
    appointmentId?: SortOrder
  }

  export type CashTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CashTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    occurredAt?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salonId?: SortOrder
    categoryId?: SortOrder
    appointmentId?: SortOrder
  }

  export type CashTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    source?: SortOrder
    amount?: SortOrder
    occurredAt?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    salonId?: SortOrder
    categoryId?: SortOrder
    appointmentId?: SortOrder
  }

  export type CashTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumCashSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashSource | EnumCashSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCashSourceWithAggregatesFilter<$PrismaModel> | $Enums.CashSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashSourceFilter<$PrismaModel>
    _max?: NestedEnumCashSourceFilter<$PrismaModel>
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type EnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type DeliveryListRelationFilter = {
    every?: DeliveryWhereInput
    some?: DeliveryWhereInput
    none?: DeliveryWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    salonId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    paymentMode?: SortOrder
    paymentMethod?: SortOrder
    installmentsCount?: SortOrder
    firstDueDate?: SortOrder
    expectedDeliveryAt?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    installmentsCount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    salonId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    paymentMode?: SortOrder
    paymentMethod?: SortOrder
    installmentsCount?: SortOrder
    firstDueDate?: SortOrder
    expectedDeliveryAt?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    salonId?: SortOrder
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    paymentMode?: SortOrder
    paymentMethod?: SortOrder
    installmentsCount?: SortOrder
    firstDueDate?: SortOrder
    expectedDeliveryAt?: SortOrder
    deliveredAt?: SortOrder
    notes?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    subtotalCents?: SortOrder
    discountCents?: SortOrder
    totalCents?: SortOrder
    installmentsCount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type EnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type EnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPriceCents?: SortOrder
    totalCents?: SortOrder
  }

  export type EnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type DeliveryCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    expectedAt?: SortOrder
    deliveredAt?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    expectedAt?: SortOrder
    deliveredAt?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeliveryMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    expectedAt?: SortOrder
    deliveredAt?: SortOrder
    address?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type ReceivableInstallmentListRelationFilter = {
    every?: ReceivableInstallmentWhereInput
    some?: ReceivableInstallmentWhereInput
    none?: ReceivableInstallmentWhereInput
  }

  export type ReceivableInstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReceivableCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    salonId?: SortOrder
    totalCents?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivableAvgOrderByAggregateInput = {
    totalCents?: SortOrder
  }

  export type ReceivableMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    salonId?: SortOrder
    totalCents?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivableMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    salonId?: SortOrder
    totalCents?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReceivableSumOrderByAggregateInput = {
    totalCents?: SortOrder
  }

  export type EnumInstallmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusFilter<$PrismaModel> | $Enums.InstallmentStatus
  }

  export type ReceivableScalarRelationFilter = {
    is?: ReceivableWhereInput
    isNot?: ReceivableWhereInput
  }

  export type ReceivableInstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    receivableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceivableInstallmentAvgOrderByAggregateInput = {
    number?: SortOrder
    amountCents?: SortOrder
  }

  export type ReceivableInstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    receivableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceivableInstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    receivableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
  }

  export type ReceivableInstallmentSumOrderByAggregateInput = {
    number?: SortOrder
    amountCents?: SortOrder
  }

  export type EnumInstallmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallmentStatusFilter<$PrismaModel>
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type PayableInstallmentListRelationFilter = {
    every?: PayableInstallmentWhereInput
    some?: PayableInstallmentWhereInput
    none?: PayableInstallmentWhereInput
  }

  export type PayableInstallmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayableCountOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    salonId?: SortOrder
    description?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayableAvgOrderByAggregateInput = {
    totalCents?: SortOrder
  }

  export type PayableMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    salonId?: SortOrder
    description?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayableMinOrderByAggregateInput = {
    id?: SortOrder
    supplierId?: SortOrder
    salonId?: SortOrder
    description?: SortOrder
    totalCents?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayableSumOrderByAggregateInput = {
    totalCents?: SortOrder
  }

  export type PayableScalarRelationFilter = {
    is?: PayableWhereInput
    isNot?: PayableWhereInput
  }

  export type PayableInstallmentCountOrderByAggregateInput = {
    id?: SortOrder
    payableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
  }

  export type PayableInstallmentAvgOrderByAggregateInput = {
    number?: SortOrder
    amountCents?: SortOrder
  }

  export type PayableInstallmentMaxOrderByAggregateInput = {
    id?: SortOrder
    payableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
  }

  export type PayableInstallmentMinOrderByAggregateInput = {
    id?: SortOrder
    payableId?: SortOrder
    number?: SortOrder
    dueDate?: SortOrder
    amountCents?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    method?: SortOrder
    createdAt?: SortOrder
  }

  export type PayableInstallmentSumOrderByAggregateInput = {
    number?: SortOrder
    amountCents?: SortOrder
  }

  export type EnumCostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeFilter<$PrismaModel> | $Enums.CostType
  }

  export type CostCountOrderByAggregateInput = {
    id?: SortOrder
    salonId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    occurredAt?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostAvgOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type CostMaxOrderByAggregateInput = {
    id?: SortOrder
    salonId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    occurredAt?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostMinOrderByAggregateInput = {
    id?: SortOrder
    salonId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    amountCents?: SortOrder
    occurredAt?: SortOrder
    supplierId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostSumOrderByAggregateInput = {
    amountCents?: SortOrder
  }

  export type EnumCostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeWithAggregatesFilter<$PrismaModel> | $Enums.CostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostTypeFilter<$PrismaModel>
    _max?: NestedEnumCostTypeFilter<$PrismaModel>
  }

  export type SalonCreateNestedOneWithoutUserInput = {
    create?: XOR<SalonCreateWithoutUserInput, SalonUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalonCreateOrConnectWithoutUserInput
    connect?: SalonWhereUniqueInput
  }

  export type SalonUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SalonCreateWithoutUserInput, SalonUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalonCreateOrConnectWithoutUserInput
    connect?: SalonWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SalonUpdateOneWithoutUserNestedInput = {
    create?: XOR<SalonCreateWithoutUserInput, SalonUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalonCreateOrConnectWithoutUserInput
    upsert?: SalonUpsertWithoutUserInput
    disconnect?: SalonWhereInput | boolean
    delete?: SalonWhereInput | boolean
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutUserInput, SalonUpdateWithoutUserInput>, SalonUncheckedUpdateWithoutUserInput>
  }

  export type SalonUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SalonCreateWithoutUserInput, SalonUncheckedCreateWithoutUserInput>
    connectOrCreate?: SalonCreateOrConnectWithoutUserInput
    upsert?: SalonUpsertWithoutUserInput
    disconnect?: SalonWhereInput | boolean
    delete?: SalonWhereInput | boolean
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutUserInput, SalonUpdateWithoutUserInput>, SalonUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutSalonInput = {
    create?: XOR<UserCreateWithoutSalonInput, UserUncheckedCreateWithoutSalonInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalonInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceCreateNestedManyWithoutSalonInput = {
    create?: XOR<ServiceCreateWithoutSalonInput, ServiceUncheckedCreateWithoutSalonInput> | ServiceCreateWithoutSalonInput[] | ServiceUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSalonInput | ServiceCreateOrConnectWithoutSalonInput[]
    createMany?: ServiceCreateManySalonInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ClientCreateNestedManyWithoutSalonInput = {
    create?: XOR<ClientCreateWithoutSalonInput, ClientUncheckedCreateWithoutSalonInput> | ClientCreateWithoutSalonInput[] | ClientUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutSalonInput | ClientCreateOrConnectWithoutSalonInput[]
    createMany?: ClientCreateManySalonInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutSalonInput = {
    create?: XOR<AppointmentCreateWithoutSalonInput, AppointmentUncheckedCreateWithoutSalonInput> | AppointmentCreateWithoutSalonInput[] | AppointmentUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSalonInput | AppointmentCreateOrConnectWithoutSalonInput[]
    createMany?: AppointmentCreateManySalonInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CashCategoryCreateNestedManyWithoutSalonInput = {
    create?: XOR<CashCategoryCreateWithoutSalonInput, CashCategoryUncheckedCreateWithoutSalonInput> | CashCategoryCreateWithoutSalonInput[] | CashCategoryUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashCategoryCreateOrConnectWithoutSalonInput | CashCategoryCreateOrConnectWithoutSalonInput[]
    createMany?: CashCategoryCreateManySalonInputEnvelope
    connect?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
  }

  export type CashTransactionCreateNestedManyWithoutSalonInput = {
    create?: XOR<CashTransactionCreateWithoutSalonInput, CashTransactionUncheckedCreateWithoutSalonInput> | CashTransactionCreateWithoutSalonInput[] | CashTransactionUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutSalonInput | CashTransactionCreateOrConnectWithoutSalonInput[]
    createMany?: CashTransactionCreateManySalonInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutSalonInput = {
    create?: XOR<OrderCreateWithoutSalonInput, OrderUncheckedCreateWithoutSalonInput> | OrderCreateWithoutSalonInput[] | OrderUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalonInput | OrderCreateOrConnectWithoutSalonInput[]
    createMany?: OrderCreateManySalonInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReceivableCreateNestedManyWithoutSalonInput = {
    create?: XOR<ReceivableCreateWithoutSalonInput, ReceivableUncheckedCreateWithoutSalonInput> | ReceivableCreateWithoutSalonInput[] | ReceivableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutSalonInput | ReceivableCreateOrConnectWithoutSalonInput[]
    createMany?: ReceivableCreateManySalonInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type PayableCreateNestedManyWithoutSalonInput = {
    create?: XOR<PayableCreateWithoutSalonInput, PayableUncheckedCreateWithoutSalonInput> | PayableCreateWithoutSalonInput[] | PayableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSalonInput | PayableCreateOrConnectWithoutSalonInput[]
    createMany?: PayableCreateManySalonInputEnvelope
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
  }

  export type CostCreateNestedManyWithoutSalonInput = {
    create?: XOR<CostCreateWithoutSalonInput, CostUncheckedCreateWithoutSalonInput> | CostCreateWithoutSalonInput[] | CostUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSalonInput | CostCreateOrConnectWithoutSalonInput[]
    createMany?: CostCreateManySalonInputEnvelope
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<ServiceCreateWithoutSalonInput, ServiceUncheckedCreateWithoutSalonInput> | ServiceCreateWithoutSalonInput[] | ServiceUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSalonInput | ServiceCreateOrConnectWithoutSalonInput[]
    createMany?: ServiceCreateManySalonInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ClientUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<ClientCreateWithoutSalonInput, ClientUncheckedCreateWithoutSalonInput> | ClientCreateWithoutSalonInput[] | ClientUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutSalonInput | ClientCreateOrConnectWithoutSalonInput[]
    createMany?: ClientCreateManySalonInputEnvelope
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<AppointmentCreateWithoutSalonInput, AppointmentUncheckedCreateWithoutSalonInput> | AppointmentCreateWithoutSalonInput[] | AppointmentUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSalonInput | AppointmentCreateOrConnectWithoutSalonInput[]
    createMany?: AppointmentCreateManySalonInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type CashCategoryUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<CashCategoryCreateWithoutSalonInput, CashCategoryUncheckedCreateWithoutSalonInput> | CashCategoryCreateWithoutSalonInput[] | CashCategoryUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashCategoryCreateOrConnectWithoutSalonInput | CashCategoryCreateOrConnectWithoutSalonInput[]
    createMany?: CashCategoryCreateManySalonInputEnvelope
    connect?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<CashTransactionCreateWithoutSalonInput, CashTransactionUncheckedCreateWithoutSalonInput> | CashTransactionCreateWithoutSalonInput[] | CashTransactionUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutSalonInput | CashTransactionCreateOrConnectWithoutSalonInput[]
    createMany?: CashTransactionCreateManySalonInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<OrderCreateWithoutSalonInput, OrderUncheckedCreateWithoutSalonInput> | OrderCreateWithoutSalonInput[] | OrderUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalonInput | OrderCreateOrConnectWithoutSalonInput[]
    createMany?: OrderCreateManySalonInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReceivableUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<ReceivableCreateWithoutSalonInput, ReceivableUncheckedCreateWithoutSalonInput> | ReceivableCreateWithoutSalonInput[] | ReceivableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutSalonInput | ReceivableCreateOrConnectWithoutSalonInput[]
    createMany?: ReceivableCreateManySalonInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type PayableUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<PayableCreateWithoutSalonInput, PayableUncheckedCreateWithoutSalonInput> | PayableCreateWithoutSalonInput[] | PayableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSalonInput | PayableCreateOrConnectWithoutSalonInput[]
    createMany?: PayableCreateManySalonInputEnvelope
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
  }

  export type CostUncheckedCreateNestedManyWithoutSalonInput = {
    create?: XOR<CostCreateWithoutSalonInput, CostUncheckedCreateWithoutSalonInput> | CostCreateWithoutSalonInput[] | CostUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSalonInput | CostCreateOrConnectWithoutSalonInput[]
    createMany?: CostCreateManySalonInputEnvelope
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutSalonNestedInput = {
    create?: XOR<UserCreateWithoutSalonInput, UserUncheckedCreateWithoutSalonInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalonInput
    upsert?: UserUpsertWithoutSalonInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalonInput, UserUpdateWithoutSalonInput>, UserUncheckedUpdateWithoutSalonInput>
  }

  export type ServiceUpdateManyWithoutSalonNestedInput = {
    create?: XOR<ServiceCreateWithoutSalonInput, ServiceUncheckedCreateWithoutSalonInput> | ServiceCreateWithoutSalonInput[] | ServiceUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSalonInput | ServiceCreateOrConnectWithoutSalonInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutSalonInput | ServiceUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: ServiceCreateManySalonInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutSalonInput | ServiceUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutSalonInput | ServiceUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ClientUpdateManyWithoutSalonNestedInput = {
    create?: XOR<ClientCreateWithoutSalonInput, ClientUncheckedCreateWithoutSalonInput> | ClientCreateWithoutSalonInput[] | ClientUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutSalonInput | ClientCreateOrConnectWithoutSalonInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutSalonInput | ClientUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: ClientCreateManySalonInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutSalonInput | ClientUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutSalonInput | ClientUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutSalonNestedInput = {
    create?: XOR<AppointmentCreateWithoutSalonInput, AppointmentUncheckedCreateWithoutSalonInput> | AppointmentCreateWithoutSalonInput[] | AppointmentUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSalonInput | AppointmentCreateOrConnectWithoutSalonInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutSalonInput | AppointmentUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: AppointmentCreateManySalonInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutSalonInput | AppointmentUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutSalonInput | AppointmentUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CashCategoryUpdateManyWithoutSalonNestedInput = {
    create?: XOR<CashCategoryCreateWithoutSalonInput, CashCategoryUncheckedCreateWithoutSalonInput> | CashCategoryCreateWithoutSalonInput[] | CashCategoryUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashCategoryCreateOrConnectWithoutSalonInput | CashCategoryCreateOrConnectWithoutSalonInput[]
    upsert?: CashCategoryUpsertWithWhereUniqueWithoutSalonInput | CashCategoryUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: CashCategoryCreateManySalonInputEnvelope
    set?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    disconnect?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    delete?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    connect?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    update?: CashCategoryUpdateWithWhereUniqueWithoutSalonInput | CashCategoryUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: CashCategoryUpdateManyWithWhereWithoutSalonInput | CashCategoryUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: CashCategoryScalarWhereInput | CashCategoryScalarWhereInput[]
  }

  export type CashTransactionUpdateManyWithoutSalonNestedInput = {
    create?: XOR<CashTransactionCreateWithoutSalonInput, CashTransactionUncheckedCreateWithoutSalonInput> | CashTransactionCreateWithoutSalonInput[] | CashTransactionUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutSalonInput | CashTransactionCreateOrConnectWithoutSalonInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutSalonInput | CashTransactionUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: CashTransactionCreateManySalonInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutSalonInput | CashTransactionUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutSalonInput | CashTransactionUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutSalonNestedInput = {
    create?: XOR<OrderCreateWithoutSalonInput, OrderUncheckedCreateWithoutSalonInput> | OrderCreateWithoutSalonInput[] | OrderUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalonInput | OrderCreateOrConnectWithoutSalonInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSalonInput | OrderUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: OrderCreateManySalonInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSalonInput | OrderUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSalonInput | OrderUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReceivableUpdateManyWithoutSalonNestedInput = {
    create?: XOR<ReceivableCreateWithoutSalonInput, ReceivableUncheckedCreateWithoutSalonInput> | ReceivableCreateWithoutSalonInput[] | ReceivableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutSalonInput | ReceivableCreateOrConnectWithoutSalonInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutSalonInput | ReceivableUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: ReceivableCreateManySalonInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutSalonInput | ReceivableUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutSalonInput | ReceivableUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type PayableUpdateManyWithoutSalonNestedInput = {
    create?: XOR<PayableCreateWithoutSalonInput, PayableUncheckedCreateWithoutSalonInput> | PayableCreateWithoutSalonInput[] | PayableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSalonInput | PayableCreateOrConnectWithoutSalonInput[]
    upsert?: PayableUpsertWithWhereUniqueWithoutSalonInput | PayableUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: PayableCreateManySalonInputEnvelope
    set?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    disconnect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    delete?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    update?: PayableUpdateWithWhereUniqueWithoutSalonInput | PayableUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: PayableUpdateManyWithWhereWithoutSalonInput | PayableUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: PayableScalarWhereInput | PayableScalarWhereInput[]
  }

  export type CostUpdateManyWithoutSalonNestedInput = {
    create?: XOR<CostCreateWithoutSalonInput, CostUncheckedCreateWithoutSalonInput> | CostCreateWithoutSalonInput[] | CostUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSalonInput | CostCreateOrConnectWithoutSalonInput[]
    upsert?: CostUpsertWithWhereUniqueWithoutSalonInput | CostUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: CostCreateManySalonInputEnvelope
    set?: CostWhereUniqueInput | CostWhereUniqueInput[]
    disconnect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    delete?: CostWhereUniqueInput | CostWhereUniqueInput[]
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    update?: CostUpdateWithWhereUniqueWithoutSalonInput | CostUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: CostUpdateManyWithWhereWithoutSalonInput | CostUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: CostScalarWhereInput | CostScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<ServiceCreateWithoutSalonInput, ServiceUncheckedCreateWithoutSalonInput> | ServiceCreateWithoutSalonInput[] | ServiceUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSalonInput | ServiceCreateOrConnectWithoutSalonInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutSalonInput | ServiceUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: ServiceCreateManySalonInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutSalonInput | ServiceUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutSalonInput | ServiceUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ClientUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<ClientCreateWithoutSalonInput, ClientUncheckedCreateWithoutSalonInput> | ClientCreateWithoutSalonInput[] | ClientUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ClientCreateOrConnectWithoutSalonInput | ClientCreateOrConnectWithoutSalonInput[]
    upsert?: ClientUpsertWithWhereUniqueWithoutSalonInput | ClientUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: ClientCreateManySalonInputEnvelope
    set?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    disconnect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    delete?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    connect?: ClientWhereUniqueInput | ClientWhereUniqueInput[]
    update?: ClientUpdateWithWhereUniqueWithoutSalonInput | ClientUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: ClientUpdateManyWithWhereWithoutSalonInput | ClientUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: ClientScalarWhereInput | ClientScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<AppointmentCreateWithoutSalonInput, AppointmentUncheckedCreateWithoutSalonInput> | AppointmentCreateWithoutSalonInput[] | AppointmentUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutSalonInput | AppointmentCreateOrConnectWithoutSalonInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutSalonInput | AppointmentUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: AppointmentCreateManySalonInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutSalonInput | AppointmentUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutSalonInput | AppointmentUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type CashCategoryUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<CashCategoryCreateWithoutSalonInput, CashCategoryUncheckedCreateWithoutSalonInput> | CashCategoryCreateWithoutSalonInput[] | CashCategoryUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashCategoryCreateOrConnectWithoutSalonInput | CashCategoryCreateOrConnectWithoutSalonInput[]
    upsert?: CashCategoryUpsertWithWhereUniqueWithoutSalonInput | CashCategoryUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: CashCategoryCreateManySalonInputEnvelope
    set?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    disconnect?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    delete?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    connect?: CashCategoryWhereUniqueInput | CashCategoryWhereUniqueInput[]
    update?: CashCategoryUpdateWithWhereUniqueWithoutSalonInput | CashCategoryUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: CashCategoryUpdateManyWithWhereWithoutSalonInput | CashCategoryUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: CashCategoryScalarWhereInput | CashCategoryScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<CashTransactionCreateWithoutSalonInput, CashTransactionUncheckedCreateWithoutSalonInput> | CashTransactionCreateWithoutSalonInput[] | CashTransactionUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutSalonInput | CashTransactionCreateOrConnectWithoutSalonInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutSalonInput | CashTransactionUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: CashTransactionCreateManySalonInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutSalonInput | CashTransactionUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutSalonInput | CashTransactionUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<OrderCreateWithoutSalonInput, OrderUncheckedCreateWithoutSalonInput> | OrderCreateWithoutSalonInput[] | OrderUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalonInput | OrderCreateOrConnectWithoutSalonInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSalonInput | OrderUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: OrderCreateManySalonInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSalonInput | OrderUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSalonInput | OrderUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReceivableUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<ReceivableCreateWithoutSalonInput, ReceivableUncheckedCreateWithoutSalonInput> | ReceivableCreateWithoutSalonInput[] | ReceivableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutSalonInput | ReceivableCreateOrConnectWithoutSalonInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutSalonInput | ReceivableUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: ReceivableCreateManySalonInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutSalonInput | ReceivableUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutSalonInput | ReceivableUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type PayableUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<PayableCreateWithoutSalonInput, PayableUncheckedCreateWithoutSalonInput> | PayableCreateWithoutSalonInput[] | PayableUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSalonInput | PayableCreateOrConnectWithoutSalonInput[]
    upsert?: PayableUpsertWithWhereUniqueWithoutSalonInput | PayableUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: PayableCreateManySalonInputEnvelope
    set?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    disconnect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    delete?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    update?: PayableUpdateWithWhereUniqueWithoutSalonInput | PayableUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: PayableUpdateManyWithWhereWithoutSalonInput | PayableUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: PayableScalarWhereInput | PayableScalarWhereInput[]
  }

  export type CostUncheckedUpdateManyWithoutSalonNestedInput = {
    create?: XOR<CostCreateWithoutSalonInput, CostUncheckedCreateWithoutSalonInput> | CostCreateWithoutSalonInput[] | CostUncheckedCreateWithoutSalonInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSalonInput | CostCreateOrConnectWithoutSalonInput[]
    upsert?: CostUpsertWithWhereUniqueWithoutSalonInput | CostUpsertWithWhereUniqueWithoutSalonInput[]
    createMany?: CostCreateManySalonInputEnvelope
    set?: CostWhereUniqueInput | CostWhereUniqueInput[]
    disconnect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    delete?: CostWhereUniqueInput | CostWhereUniqueInput[]
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    update?: CostUpdateWithWhereUniqueWithoutSalonInput | CostUpdateWithWhereUniqueWithoutSalonInput[]
    updateMany?: CostUpdateManyWithWhereWithoutSalonInput | CostUpdateManyWithWhereWithoutSalonInput[]
    deleteMany?: CostScalarWhereInput | CostScalarWhereInput[]
  }

  export type SalonCreateNestedOneWithoutServicesInput = {
    create?: XOR<SalonCreateWithoutServicesInput, SalonUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutServicesInput
    connect?: SalonWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SalonUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<SalonCreateWithoutServicesInput, SalonUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutServicesInput
    upsert?: SalonUpsertWithoutServicesInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutServicesInput, SalonUpdateWithoutServicesInput>, SalonUncheckedUpdateWithoutServicesInput>
  }

  export type AppointmentUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceInput | AppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceInput | AppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceInput | AppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput> | AppointmentCreateWithoutServiceInput[] | AppointmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutServiceInput | AppointmentCreateOrConnectWithoutServiceInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutServiceInput | AppointmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AppointmentCreateManyServiceInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutServiceInput | AppointmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutServiceInput | AppointmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type SalonCreateNestedOneWithoutClientsInput = {
    create?: XOR<SalonCreateWithoutClientsInput, SalonUncheckedCreateWithoutClientsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutClientsInput
    connect?: SalonWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutClientInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PayableCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PayableCreateWithoutSupplierInput, PayableUncheckedCreateWithoutSupplierInput> | PayableCreateWithoutSupplierInput[] | PayableUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSupplierInput | PayableCreateOrConnectWithoutSupplierInput[]
    createMany?: PayableCreateManySupplierInputEnvelope
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
  }

  export type CostCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CostCreateWithoutSupplierInput, CostUncheckedCreateWithoutSupplierInput> | CostCreateWithoutSupplierInput[] | CostUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSupplierInput | CostCreateOrConnectWithoutSupplierInput[]
    createMany?: CostCreateManySupplierInputEnvelope
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type PayableUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PayableCreateWithoutSupplierInput, PayableUncheckedCreateWithoutSupplierInput> | PayableCreateWithoutSupplierInput[] | PayableUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSupplierInput | PayableCreateOrConnectWithoutSupplierInput[]
    createMany?: PayableCreateManySupplierInputEnvelope
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
  }

  export type CostUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<CostCreateWithoutSupplierInput, CostUncheckedCreateWithoutSupplierInput> | CostCreateWithoutSupplierInput[] | CostUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSupplierInput | CostCreateOrConnectWithoutSupplierInput[]
    createMany?: CostCreateManySupplierInputEnvelope
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type SalonUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<SalonCreateWithoutClientsInput, SalonUncheckedCreateWithoutClientsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutClientsInput
    upsert?: SalonUpsertWithoutClientsInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutClientsInput, SalonUpdateWithoutClientsInput>, SalonUncheckedUpdateWithoutClientsInput>
  }

  export type AppointmentUpdateManyWithoutClientNestedInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClientInput | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClientInput | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClientInput | AppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PayableUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PayableCreateWithoutSupplierInput, PayableUncheckedCreateWithoutSupplierInput> | PayableCreateWithoutSupplierInput[] | PayableUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSupplierInput | PayableCreateOrConnectWithoutSupplierInput[]
    upsert?: PayableUpsertWithWhereUniqueWithoutSupplierInput | PayableUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PayableCreateManySupplierInputEnvelope
    set?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    disconnect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    delete?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    update?: PayableUpdateWithWhereUniqueWithoutSupplierInput | PayableUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PayableUpdateManyWithWhereWithoutSupplierInput | PayableUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PayableScalarWhereInput | PayableScalarWhereInput[]
  }

  export type CostUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CostCreateWithoutSupplierInput, CostUncheckedCreateWithoutSupplierInput> | CostCreateWithoutSupplierInput[] | CostUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSupplierInput | CostCreateOrConnectWithoutSupplierInput[]
    upsert?: CostUpsertWithWhereUniqueWithoutSupplierInput | CostUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CostCreateManySupplierInputEnvelope
    set?: CostWhereUniqueInput | CostWhereUniqueInput[]
    disconnect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    delete?: CostWhereUniqueInput | CostWhereUniqueInput[]
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    update?: CostUpdateWithWhereUniqueWithoutSupplierInput | CostUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CostUpdateManyWithWhereWithoutSupplierInput | CostUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CostScalarWhereInput | CostScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput> | AppointmentCreateWithoutClientInput[] | AppointmentUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutClientInput | AppointmentCreateOrConnectWithoutClientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutClientInput | AppointmentUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AppointmentCreateManyClientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutClientInput | AppointmentUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutClientInput | AppointmentUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type PayableUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PayableCreateWithoutSupplierInput, PayableUncheckedCreateWithoutSupplierInput> | PayableCreateWithoutSupplierInput[] | PayableUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PayableCreateOrConnectWithoutSupplierInput | PayableCreateOrConnectWithoutSupplierInput[]
    upsert?: PayableUpsertWithWhereUniqueWithoutSupplierInput | PayableUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PayableCreateManySupplierInputEnvelope
    set?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    disconnect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    delete?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    connect?: PayableWhereUniqueInput | PayableWhereUniqueInput[]
    update?: PayableUpdateWithWhereUniqueWithoutSupplierInput | PayableUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PayableUpdateManyWithWhereWithoutSupplierInput | PayableUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PayableScalarWhereInput | PayableScalarWhereInput[]
  }

  export type CostUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<CostCreateWithoutSupplierInput, CostUncheckedCreateWithoutSupplierInput> | CostCreateWithoutSupplierInput[] | CostUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: CostCreateOrConnectWithoutSupplierInput | CostCreateOrConnectWithoutSupplierInput[]
    upsert?: CostUpsertWithWhereUniqueWithoutSupplierInput | CostUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: CostCreateManySupplierInputEnvelope
    set?: CostWhereUniqueInput | CostWhereUniqueInput[]
    disconnect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    delete?: CostWhereUniqueInput | CostWhereUniqueInput[]
    connect?: CostWhereUniqueInput | CostWhereUniqueInput[]
    update?: CostUpdateWithWhereUniqueWithoutSupplierInput | CostUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: CostUpdateManyWithWhereWithoutSupplierInput | CostUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: CostScalarWhereInput | CostScalarWhereInput[]
  }

  export type SalonCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<SalonCreateWithoutAppointmentsInput, SalonUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutAppointmentsInput
    connect?: SalonWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAppointmentsInput
    connect?: ClientWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAppointmentsInput
    connect?: ServiceWhereUniqueInput
  }

  export type CashTransactionCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<CashTransactionCreateWithoutAppointmentInput, CashTransactionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CashTransactionCreateOrConnectWithoutAppointmentInput
    connect?: CashTransactionWhereUniqueInput
  }

  export type CashTransactionUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<CashTransactionCreateWithoutAppointmentInput, CashTransactionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CashTransactionCreateOrConnectWithoutAppointmentInput
    connect?: CashTransactionWhereUniqueInput
  }

  export type SalonUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<SalonCreateWithoutAppointmentsInput, SalonUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutAppointmentsInput
    upsert?: SalonUpsertWithoutAppointmentsInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutAppointmentsInput, SalonUpdateWithoutAppointmentsInput>, SalonUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutAppointmentsInput
    upsert?: ClientUpsertWithoutAppointmentsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutAppointmentsInput, ClientUpdateWithoutAppointmentsInput>, ClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAppointmentsInput
    upsert?: ServiceUpsertWithoutAppointmentsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAppointmentsInput, ServiceUpdateWithoutAppointmentsInput>, ServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CashTransactionUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<CashTransactionCreateWithoutAppointmentInput, CashTransactionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CashTransactionCreateOrConnectWithoutAppointmentInput
    upsert?: CashTransactionUpsertWithoutAppointmentInput
    disconnect?: CashTransactionWhereInput | boolean
    delete?: CashTransactionWhereInput | boolean
    connect?: CashTransactionWhereUniqueInput
    update?: XOR<XOR<CashTransactionUpdateToOneWithWhereWithoutAppointmentInput, CashTransactionUpdateWithoutAppointmentInput>, CashTransactionUncheckedUpdateWithoutAppointmentInput>
  }

  export type CashTransactionUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<CashTransactionCreateWithoutAppointmentInput, CashTransactionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CashTransactionCreateOrConnectWithoutAppointmentInput
    upsert?: CashTransactionUpsertWithoutAppointmentInput
    disconnect?: CashTransactionWhereInput | boolean
    delete?: CashTransactionWhereInput | boolean
    connect?: CashTransactionWhereUniqueInput
    update?: XOR<XOR<CashTransactionUpdateToOneWithWhereWithoutAppointmentInput, CashTransactionUpdateWithoutAppointmentInput>, CashTransactionUncheckedUpdateWithoutAppointmentInput>
  }

  export type SalonCreateNestedOneWithoutCashCategoriesInput = {
    create?: XOR<SalonCreateWithoutCashCategoriesInput, SalonUncheckedCreateWithoutCashCategoriesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutCashCategoriesInput
    connect?: SalonWhereUniqueInput
  }

  export type CashTransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CashTransactionCreateWithoutCategoryInput, CashTransactionUncheckedCreateWithoutCategoryInput> | CashTransactionCreateWithoutCategoryInput[] | CashTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCategoryInput | CashTransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: CashTransactionCreateManyCategoryInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type CashTransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CashTransactionCreateWithoutCategoryInput, CashTransactionUncheckedCreateWithoutCategoryInput> | CashTransactionCreateWithoutCategoryInput[] | CashTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCategoryInput | CashTransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: CashTransactionCreateManyCategoryInputEnvelope
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
  }

  export type EnumCashTypeFieldUpdateOperationsInput = {
    set?: $Enums.CashType
  }

  export type SalonUpdateOneRequiredWithoutCashCategoriesNestedInput = {
    create?: XOR<SalonCreateWithoutCashCategoriesInput, SalonUncheckedCreateWithoutCashCategoriesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutCashCategoriesInput
    upsert?: SalonUpsertWithoutCashCategoriesInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutCashCategoriesInput, SalonUpdateWithoutCashCategoriesInput>, SalonUncheckedUpdateWithoutCashCategoriesInput>
  }

  export type CashTransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCategoryInput, CashTransactionUncheckedCreateWithoutCategoryInput> | CashTransactionCreateWithoutCategoryInput[] | CashTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCategoryInput | CashTransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCategoryInput | CashTransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CashTransactionCreateManyCategoryInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCategoryInput | CashTransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCategoryInput | CashTransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type CashTransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CashTransactionCreateWithoutCategoryInput, CashTransactionUncheckedCreateWithoutCategoryInput> | CashTransactionCreateWithoutCategoryInput[] | CashTransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CashTransactionCreateOrConnectWithoutCategoryInput | CashTransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: CashTransactionUpsertWithWhereUniqueWithoutCategoryInput | CashTransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CashTransactionCreateManyCategoryInputEnvelope
    set?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    disconnect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    delete?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    connect?: CashTransactionWhereUniqueInput | CashTransactionWhereUniqueInput[]
    update?: CashTransactionUpdateWithWhereUniqueWithoutCategoryInput | CashTransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CashTransactionUpdateManyWithWhereWithoutCategoryInput | CashTransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
  }

  export type SalonCreateNestedOneWithoutCashTransactionsInput = {
    create?: XOR<SalonCreateWithoutCashTransactionsInput, SalonUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutCashTransactionsInput
    connect?: SalonWhereUniqueInput
  }

  export type CashCategoryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<CashCategoryCreateWithoutTransactionsInput, CashCategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CashCategoryCreateOrConnectWithoutTransactionsInput
    connect?: CashCategoryWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutCashTransactionInput = {
    create?: XOR<AppointmentCreateWithoutCashTransactionInput, AppointmentUncheckedCreateWithoutCashTransactionInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutCashTransactionInput
    connect?: AppointmentWhereUniqueInput
  }

  export type EnumCashSourceFieldUpdateOperationsInput = {
    set?: $Enums.CashSource
  }

  export type SalonUpdateOneRequiredWithoutCashTransactionsNestedInput = {
    create?: XOR<SalonCreateWithoutCashTransactionsInput, SalonUncheckedCreateWithoutCashTransactionsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutCashTransactionsInput
    upsert?: SalonUpsertWithoutCashTransactionsInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutCashTransactionsInput, SalonUpdateWithoutCashTransactionsInput>, SalonUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type CashCategoryUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<CashCategoryCreateWithoutTransactionsInput, CashCategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: CashCategoryCreateOrConnectWithoutTransactionsInput
    upsert?: CashCategoryUpsertWithoutTransactionsInput
    disconnect?: CashCategoryWhereInput | boolean
    delete?: CashCategoryWhereInput | boolean
    connect?: CashCategoryWhereUniqueInput
    update?: XOR<XOR<CashCategoryUpdateToOneWithWhereWithoutTransactionsInput, CashCategoryUpdateWithoutTransactionsInput>, CashCategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type AppointmentUpdateOneWithoutCashTransactionNestedInput = {
    create?: XOR<AppointmentCreateWithoutCashTransactionInput, AppointmentUncheckedCreateWithoutCashTransactionInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutCashTransactionInput
    upsert?: AppointmentUpsertWithoutCashTransactionInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutCashTransactionInput, AppointmentUpdateWithoutCashTransactionInput>, AppointmentUncheckedUpdateWithoutCashTransactionInput>
  }

  export type ClientCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    connect?: ClientWhereUniqueInput
  }

  export type SalonCreateNestedOneWithoutOrdersInput = {
    create?: XOR<SalonCreateWithoutOrdersInput, SalonUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SalonCreateOrConnectWithoutOrdersInput
    connect?: SalonWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DeliveryCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput> | DeliveryCreateWithoutOrderInput[] | DeliveryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput | DeliveryCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryCreateManyOrderInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type ReceivableCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReceivableCreateWithoutOrderInput, ReceivableUncheckedCreateWithoutOrderInput> | ReceivableCreateWithoutOrderInput[] | ReceivableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutOrderInput | ReceivableCreateOrConnectWithoutOrderInput[]
    createMany?: ReceivableCreateManyOrderInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DeliveryUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput> | DeliveryCreateWithoutOrderInput[] | DeliveryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput | DeliveryCreateOrConnectWithoutOrderInput[]
    createMany?: DeliveryCreateManyOrderInputEnvelope
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
  }

  export type ReceivableUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<ReceivableCreateWithoutOrderInput, ReceivableUncheckedCreateWithoutOrderInput> | ReceivableCreateWithoutOrderInput[] | ReceivableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutOrderInput | ReceivableCreateOrConnectWithoutOrderInput[]
    createMany?: ReceivableCreateManyOrderInputEnvelope
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type EnumPaymentModeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMode
  }

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null
  }

  export type ClientUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    upsert?: ClientUpsertWithoutOrdersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOrdersInput, ClientUpdateWithoutOrdersInput>, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type SalonUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<SalonCreateWithoutOrdersInput, SalonUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: SalonCreateOrConnectWithoutOrdersInput
    upsert?: SalonUpsertWithoutOrdersInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutOrdersInput, SalonUpdateWithoutOrdersInput>, SalonUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DeliveryUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput> | DeliveryCreateWithoutOrderInput[] | DeliveryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput | DeliveryCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutOrderInput | DeliveryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryCreateManyOrderInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutOrderInput | DeliveryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutOrderInput | DeliveryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type ReceivableUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReceivableCreateWithoutOrderInput, ReceivableUncheckedCreateWithoutOrderInput> | ReceivableCreateWithoutOrderInput[] | ReceivableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutOrderInput | ReceivableCreateOrConnectWithoutOrderInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutOrderInput | ReceivableUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReceivableCreateManyOrderInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutOrderInput | ReceivableUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutOrderInput | ReceivableUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type DeliveryUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput> | DeliveryCreateWithoutOrderInput[] | DeliveryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DeliveryCreateOrConnectWithoutOrderInput | DeliveryCreateOrConnectWithoutOrderInput[]
    upsert?: DeliveryUpsertWithWhereUniqueWithoutOrderInput | DeliveryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DeliveryCreateManyOrderInputEnvelope
    set?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    disconnect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    delete?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    connect?: DeliveryWhereUniqueInput | DeliveryWhereUniqueInput[]
    update?: DeliveryUpdateWithWhereUniqueWithoutOrderInput | DeliveryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DeliveryUpdateManyWithWhereWithoutOrderInput | DeliveryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
  }

  export type ReceivableUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<ReceivableCreateWithoutOrderInput, ReceivableUncheckedCreateWithoutOrderInput> | ReceivableCreateWithoutOrderInput[] | ReceivableUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: ReceivableCreateOrConnectWithoutOrderInput | ReceivableCreateOrConnectWithoutOrderInput[]
    upsert?: ReceivableUpsertWithWhereUniqueWithoutOrderInput | ReceivableUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: ReceivableCreateManyOrderInputEnvelope
    set?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    disconnect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    delete?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    connect?: ReceivableWhereUniqueInput | ReceivableWhereUniqueInput[]
    update?: ReceivableUpdateWithWhereUniqueWithoutOrderInput | ReceivableUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: ReceivableUpdateManyWithWhereWithoutOrderInput | ReceivableUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderCreateNestedOneWithoutDeliveriesInput = {
    create?: XOR<OrderCreateWithoutDeliveriesInput, OrderUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveriesInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumDeliveryStatusFieldUpdateOperationsInput = {
    set?: $Enums.DeliveryStatus
  }

  export type OrderUpdateOneRequiredWithoutDeliveriesNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveriesInput, OrderUncheckedCreateWithoutDeliveriesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveriesInput
    upsert?: OrderUpsertWithoutDeliveriesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDeliveriesInput, OrderUpdateWithoutDeliveriesInput>, OrderUncheckedUpdateWithoutDeliveriesInput>
  }

  export type OrderCreateNestedOneWithoutReceivablesInput = {
    create?: XOR<OrderCreateWithoutReceivablesInput, OrderUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReceivablesInput
    connect?: OrderWhereUniqueInput
  }

  export type SalonCreateNestedOneWithoutReceivablesInput = {
    create?: XOR<SalonCreateWithoutReceivablesInput, SalonUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutReceivablesInput
    connect?: SalonWhereUniqueInput
  }

  export type ReceivableInstallmentCreateNestedManyWithoutReceivableInput = {
    create?: XOR<ReceivableInstallmentCreateWithoutReceivableInput, ReceivableInstallmentUncheckedCreateWithoutReceivableInput> | ReceivableInstallmentCreateWithoutReceivableInput[] | ReceivableInstallmentUncheckedCreateWithoutReceivableInput[]
    connectOrCreate?: ReceivableInstallmentCreateOrConnectWithoutReceivableInput | ReceivableInstallmentCreateOrConnectWithoutReceivableInput[]
    createMany?: ReceivableInstallmentCreateManyReceivableInputEnvelope
    connect?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
  }

  export type ReceivableInstallmentUncheckedCreateNestedManyWithoutReceivableInput = {
    create?: XOR<ReceivableInstallmentCreateWithoutReceivableInput, ReceivableInstallmentUncheckedCreateWithoutReceivableInput> | ReceivableInstallmentCreateWithoutReceivableInput[] | ReceivableInstallmentUncheckedCreateWithoutReceivableInput[]
    connectOrCreate?: ReceivableInstallmentCreateOrConnectWithoutReceivableInput | ReceivableInstallmentCreateOrConnectWithoutReceivableInput[]
    createMany?: ReceivableInstallmentCreateManyReceivableInputEnvelope
    connect?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
  }

  export type OrderUpdateOneRequiredWithoutReceivablesNestedInput = {
    create?: XOR<OrderCreateWithoutReceivablesInput, OrderUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReceivablesInput
    upsert?: OrderUpsertWithoutReceivablesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReceivablesInput, OrderUpdateWithoutReceivablesInput>, OrderUncheckedUpdateWithoutReceivablesInput>
  }

  export type SalonUpdateOneRequiredWithoutReceivablesNestedInput = {
    create?: XOR<SalonCreateWithoutReceivablesInput, SalonUncheckedCreateWithoutReceivablesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutReceivablesInput
    upsert?: SalonUpsertWithoutReceivablesInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutReceivablesInput, SalonUpdateWithoutReceivablesInput>, SalonUncheckedUpdateWithoutReceivablesInput>
  }

  export type ReceivableInstallmentUpdateManyWithoutReceivableNestedInput = {
    create?: XOR<ReceivableInstallmentCreateWithoutReceivableInput, ReceivableInstallmentUncheckedCreateWithoutReceivableInput> | ReceivableInstallmentCreateWithoutReceivableInput[] | ReceivableInstallmentUncheckedCreateWithoutReceivableInput[]
    connectOrCreate?: ReceivableInstallmentCreateOrConnectWithoutReceivableInput | ReceivableInstallmentCreateOrConnectWithoutReceivableInput[]
    upsert?: ReceivableInstallmentUpsertWithWhereUniqueWithoutReceivableInput | ReceivableInstallmentUpsertWithWhereUniqueWithoutReceivableInput[]
    createMany?: ReceivableInstallmentCreateManyReceivableInputEnvelope
    set?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    disconnect?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    delete?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    connect?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    update?: ReceivableInstallmentUpdateWithWhereUniqueWithoutReceivableInput | ReceivableInstallmentUpdateWithWhereUniqueWithoutReceivableInput[]
    updateMany?: ReceivableInstallmentUpdateManyWithWhereWithoutReceivableInput | ReceivableInstallmentUpdateManyWithWhereWithoutReceivableInput[]
    deleteMany?: ReceivableInstallmentScalarWhereInput | ReceivableInstallmentScalarWhereInput[]
  }

  export type ReceivableInstallmentUncheckedUpdateManyWithoutReceivableNestedInput = {
    create?: XOR<ReceivableInstallmentCreateWithoutReceivableInput, ReceivableInstallmentUncheckedCreateWithoutReceivableInput> | ReceivableInstallmentCreateWithoutReceivableInput[] | ReceivableInstallmentUncheckedCreateWithoutReceivableInput[]
    connectOrCreate?: ReceivableInstallmentCreateOrConnectWithoutReceivableInput | ReceivableInstallmentCreateOrConnectWithoutReceivableInput[]
    upsert?: ReceivableInstallmentUpsertWithWhereUniqueWithoutReceivableInput | ReceivableInstallmentUpsertWithWhereUniqueWithoutReceivableInput[]
    createMany?: ReceivableInstallmentCreateManyReceivableInputEnvelope
    set?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    disconnect?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    delete?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    connect?: ReceivableInstallmentWhereUniqueInput | ReceivableInstallmentWhereUniqueInput[]
    update?: ReceivableInstallmentUpdateWithWhereUniqueWithoutReceivableInput | ReceivableInstallmentUpdateWithWhereUniqueWithoutReceivableInput[]
    updateMany?: ReceivableInstallmentUpdateManyWithWhereWithoutReceivableInput | ReceivableInstallmentUpdateManyWithWhereWithoutReceivableInput[]
    deleteMany?: ReceivableInstallmentScalarWhereInput | ReceivableInstallmentScalarWhereInput[]
  }

  export type ReceivableCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<ReceivableCreateWithoutInstallmentsInput, ReceivableUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: ReceivableCreateOrConnectWithoutInstallmentsInput
    connect?: ReceivableWhereUniqueInput
  }

  export type EnumInstallmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstallmentStatus
  }

  export type ReceivableUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<ReceivableCreateWithoutInstallmentsInput, ReceivableUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: ReceivableCreateOrConnectWithoutInstallmentsInput
    upsert?: ReceivableUpsertWithoutInstallmentsInput
    connect?: ReceivableWhereUniqueInput
    update?: XOR<XOR<ReceivableUpdateToOneWithWhereWithoutInstallmentsInput, ReceivableUpdateWithoutInstallmentsInput>, ReceivableUncheckedUpdateWithoutInstallmentsInput>
  }

  export type ClientCreateNestedOneWithoutPayablesInput = {
    create?: XOR<ClientCreateWithoutPayablesInput, ClientUncheckedCreateWithoutPayablesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPayablesInput
    connect?: ClientWhereUniqueInput
  }

  export type SalonCreateNestedOneWithoutPayablesInput = {
    create?: XOR<SalonCreateWithoutPayablesInput, SalonUncheckedCreateWithoutPayablesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutPayablesInput
    connect?: SalonWhereUniqueInput
  }

  export type PayableInstallmentCreateNestedManyWithoutPayableInput = {
    create?: XOR<PayableInstallmentCreateWithoutPayableInput, PayableInstallmentUncheckedCreateWithoutPayableInput> | PayableInstallmentCreateWithoutPayableInput[] | PayableInstallmentUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: PayableInstallmentCreateOrConnectWithoutPayableInput | PayableInstallmentCreateOrConnectWithoutPayableInput[]
    createMany?: PayableInstallmentCreateManyPayableInputEnvelope
    connect?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
  }

  export type PayableInstallmentUncheckedCreateNestedManyWithoutPayableInput = {
    create?: XOR<PayableInstallmentCreateWithoutPayableInput, PayableInstallmentUncheckedCreateWithoutPayableInput> | PayableInstallmentCreateWithoutPayableInput[] | PayableInstallmentUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: PayableInstallmentCreateOrConnectWithoutPayableInput | PayableInstallmentCreateOrConnectWithoutPayableInput[]
    createMany?: PayableInstallmentCreateManyPayableInputEnvelope
    connect?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
  }

  export type ClientUpdateOneWithoutPayablesNestedInput = {
    create?: XOR<ClientCreateWithoutPayablesInput, ClientUncheckedCreateWithoutPayablesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutPayablesInput
    upsert?: ClientUpsertWithoutPayablesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutPayablesInput, ClientUpdateWithoutPayablesInput>, ClientUncheckedUpdateWithoutPayablesInput>
  }

  export type SalonUpdateOneRequiredWithoutPayablesNestedInput = {
    create?: XOR<SalonCreateWithoutPayablesInput, SalonUncheckedCreateWithoutPayablesInput>
    connectOrCreate?: SalonCreateOrConnectWithoutPayablesInput
    upsert?: SalonUpsertWithoutPayablesInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutPayablesInput, SalonUpdateWithoutPayablesInput>, SalonUncheckedUpdateWithoutPayablesInput>
  }

  export type PayableInstallmentUpdateManyWithoutPayableNestedInput = {
    create?: XOR<PayableInstallmentCreateWithoutPayableInput, PayableInstallmentUncheckedCreateWithoutPayableInput> | PayableInstallmentCreateWithoutPayableInput[] | PayableInstallmentUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: PayableInstallmentCreateOrConnectWithoutPayableInput | PayableInstallmentCreateOrConnectWithoutPayableInput[]
    upsert?: PayableInstallmentUpsertWithWhereUniqueWithoutPayableInput | PayableInstallmentUpsertWithWhereUniqueWithoutPayableInput[]
    createMany?: PayableInstallmentCreateManyPayableInputEnvelope
    set?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    disconnect?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    delete?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    connect?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    update?: PayableInstallmentUpdateWithWhereUniqueWithoutPayableInput | PayableInstallmentUpdateWithWhereUniqueWithoutPayableInput[]
    updateMany?: PayableInstallmentUpdateManyWithWhereWithoutPayableInput | PayableInstallmentUpdateManyWithWhereWithoutPayableInput[]
    deleteMany?: PayableInstallmentScalarWhereInput | PayableInstallmentScalarWhereInput[]
  }

  export type PayableInstallmentUncheckedUpdateManyWithoutPayableNestedInput = {
    create?: XOR<PayableInstallmentCreateWithoutPayableInput, PayableInstallmentUncheckedCreateWithoutPayableInput> | PayableInstallmentCreateWithoutPayableInput[] | PayableInstallmentUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: PayableInstallmentCreateOrConnectWithoutPayableInput | PayableInstallmentCreateOrConnectWithoutPayableInput[]
    upsert?: PayableInstallmentUpsertWithWhereUniqueWithoutPayableInput | PayableInstallmentUpsertWithWhereUniqueWithoutPayableInput[]
    createMany?: PayableInstallmentCreateManyPayableInputEnvelope
    set?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    disconnect?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    delete?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    connect?: PayableInstallmentWhereUniqueInput | PayableInstallmentWhereUniqueInput[]
    update?: PayableInstallmentUpdateWithWhereUniqueWithoutPayableInput | PayableInstallmentUpdateWithWhereUniqueWithoutPayableInput[]
    updateMany?: PayableInstallmentUpdateManyWithWhereWithoutPayableInput | PayableInstallmentUpdateManyWithWhereWithoutPayableInput[]
    deleteMany?: PayableInstallmentScalarWhereInput | PayableInstallmentScalarWhereInput[]
  }

  export type PayableCreateNestedOneWithoutInstallmentsInput = {
    create?: XOR<PayableCreateWithoutInstallmentsInput, PayableUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: PayableCreateOrConnectWithoutInstallmentsInput
    connect?: PayableWhereUniqueInput
  }

  export type PayableUpdateOneRequiredWithoutInstallmentsNestedInput = {
    create?: XOR<PayableCreateWithoutInstallmentsInput, PayableUncheckedCreateWithoutInstallmentsInput>
    connectOrCreate?: PayableCreateOrConnectWithoutInstallmentsInput
    upsert?: PayableUpsertWithoutInstallmentsInput
    connect?: PayableWhereUniqueInput
    update?: XOR<XOR<PayableUpdateToOneWithWhereWithoutInstallmentsInput, PayableUpdateWithoutInstallmentsInput>, PayableUncheckedUpdateWithoutInstallmentsInput>
  }

  export type SalonCreateNestedOneWithoutCostsInput = {
    create?: XOR<SalonCreateWithoutCostsInput, SalonUncheckedCreateWithoutCostsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutCostsInput
    connect?: SalonWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutCostsInput = {
    create?: XOR<ClientCreateWithoutCostsInput, ClientUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCostsInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumCostTypeFieldUpdateOperationsInput = {
    set?: $Enums.CostType
  }

  export type SalonUpdateOneRequiredWithoutCostsNestedInput = {
    create?: XOR<SalonCreateWithoutCostsInput, SalonUncheckedCreateWithoutCostsInput>
    connectOrCreate?: SalonCreateOrConnectWithoutCostsInput
    upsert?: SalonUpsertWithoutCostsInput
    connect?: SalonWhereUniqueInput
    update?: XOR<XOR<SalonUpdateToOneWithWhereWithoutCostsInput, SalonUpdateWithoutCostsInput>, SalonUncheckedUpdateWithoutCostsInput>
  }

  export type ClientUpdateOneWithoutCostsNestedInput = {
    create?: XOR<ClientCreateWithoutCostsInput, ClientUncheckedCreateWithoutCostsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutCostsInput
    upsert?: ClientUpsertWithoutCostsInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutCostsInput, ClientUpdateWithoutCostsInput>, ClientUncheckedUpdateWithoutCostsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedEnumCashTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CashType | EnumCashTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashTypeFilter<$PrismaModel> | $Enums.CashType
  }

  export type NestedEnumCashTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashType | EnumCashTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashType[] | ListEnumCashTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCashTypeWithAggregatesFilter<$PrismaModel> | $Enums.CashType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashTypeFilter<$PrismaModel>
    _max?: NestedEnumCashTypeFilter<$PrismaModel>
  }

  export type NestedEnumCashSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.CashSource | EnumCashSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCashSourceFilter<$PrismaModel> | $Enums.CashSource
  }

  export type NestedEnumCashSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CashSource | EnumCashSourceFieldRefInput<$PrismaModel>
    in?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.CashSource[] | ListEnumCashSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumCashSourceWithAggregatesFilter<$PrismaModel> | $Enums.CashSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCashSourceFilter<$PrismaModel>
    _max?: NestedEnumCashSourceFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumPaymentModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeFilter<$PrismaModel> | $Enums.PaymentMode
  }

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableFilter<$PrismaModel> | $Enums.PaymentMethod | null
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMode | EnumPaymentModeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMode[] | ListEnumPaymentModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentModeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentModeFilter<$PrismaModel>
    _max?: NestedEnumPaymentModeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>
  }

  export type NestedEnumDeliveryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusFilter<$PrismaModel> | $Enums.DeliveryStatus
  }

  export type NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeliveryStatus | EnumDeliveryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeliveryStatus[] | ListEnumDeliveryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDeliveryStatusWithAggregatesFilter<$PrismaModel> | $Enums.DeliveryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeliveryStatusFilter<$PrismaModel>
    _max?: NestedEnumDeliveryStatusFilter<$PrismaModel>
  }

  export type NestedEnumInstallmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusFilter<$PrismaModel> | $Enums.InstallmentStatus
  }

  export type NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallmentStatus | EnumInstallmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallmentStatus[] | ListEnumInstallmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallmentStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumCostTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeFilter<$PrismaModel> | $Enums.CostType
  }

  export type NestedEnumCostTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CostType | EnumCostTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CostType[] | ListEnumCostTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCostTypeWithAggregatesFilter<$PrismaModel> | $Enums.CostType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCostTypeFilter<$PrismaModel>
    _max?: NestedEnumCostTypeFilter<$PrismaModel>
  }

  export type SalonCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutUserInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutUserInput, SalonUncheckedCreateWithoutUserInput>
  }

  export type SalonUpsertWithoutUserInput = {
    update: XOR<SalonUpdateWithoutUserInput, SalonUncheckedUpdateWithoutUserInput>
    create: XOR<SalonCreateWithoutUserInput, SalonUncheckedCreateWithoutUserInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutUserInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutUserInput, SalonUncheckedUpdateWithoutUserInput>
  }

  export type SalonUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type UserCreateWithoutSalonInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    createdAt?: Date | string
  }

  export type UserUncheckedCreateWithoutSalonInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    password: string
    createdAt?: Date | string
  }

  export type UserCreateOrConnectWithoutSalonInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalonInput, UserUncheckedCreateWithoutSalonInput>
  }

  export type ServiceCreateWithoutSalonInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutSalonInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutSalonInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutSalonInput, ServiceUncheckedCreateWithoutSalonInput>
  }

  export type ServiceCreateManySalonInputEnvelope = {
    data: ServiceCreateManySalonInput | ServiceCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type ClientCreateWithoutSalonInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    payables?: PayableCreateNestedManyWithoutSupplierInput
    costs?: CostCreateNestedManyWithoutSupplierInput
  }

  export type ClientUncheckedCreateWithoutSalonInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    payables?: PayableUncheckedCreateNestedManyWithoutSupplierInput
    costs?: CostUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type ClientCreateOrConnectWithoutSalonInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutSalonInput, ClientUncheckedCreateWithoutSalonInput>
  }

  export type ClientCreateManySalonInputEnvelope = {
    data: ClientCreateManySalonInput | ClientCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutSalonInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    cashTransaction?: CashTransactionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutSalonInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    clientId: string
    serviceId: string
    cashTransaction?: CashTransactionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutSalonInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutSalonInput, AppointmentUncheckedCreateWithoutSalonInput>
  }

  export type AppointmentCreateManySalonInputEnvelope = {
    data: AppointmentCreateManySalonInput | AppointmentCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type CashCategoryCreateWithoutSalonInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    transactions?: CashTransactionCreateNestedManyWithoutCategoryInput
  }

  export type CashCategoryUncheckedCreateWithoutSalonInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    transactions?: CashTransactionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CashCategoryCreateOrConnectWithoutSalonInput = {
    where: CashCategoryWhereUniqueInput
    create: XOR<CashCategoryCreateWithoutSalonInput, CashCategoryUncheckedCreateWithoutSalonInput>
  }

  export type CashCategoryCreateManySalonInputEnvelope = {
    data: CashCategoryCreateManySalonInput | CashCategoryCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type CashTransactionCreateWithoutSalonInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: CashCategoryCreateNestedOneWithoutTransactionsInput
    appointment?: AppointmentCreateNestedOneWithoutCashTransactionInput
  }

  export type CashTransactionUncheckedCreateWithoutSalonInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    appointmentId?: string | null
  }

  export type CashTransactionCreateOrConnectWithoutSalonInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutSalonInput, CashTransactionUncheckedCreateWithoutSalonInput>
  }

  export type CashTransactionCreateManySalonInputEnvelope = {
    data: CashTransactionCreateManySalonInput | CashTransactionCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutSalonInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryCreateNestedManyWithoutOrderInput
    receivables?: ReceivableCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSalonInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutOrderInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSalonInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSalonInput, OrderUncheckedCreateWithoutSalonInput>
  }

  export type OrderCreateManySalonInputEnvelope = {
    data: OrderCreateManySalonInput | OrderCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type ReceivableCreateWithoutSalonInput = {
    id?: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReceivablesInput
    installments?: ReceivableInstallmentCreateNestedManyWithoutReceivableInput
  }

  export type ReceivableUncheckedCreateWithoutSalonInput = {
    id?: string
    orderId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: ReceivableInstallmentUncheckedCreateNestedManyWithoutReceivableInput
  }

  export type ReceivableCreateOrConnectWithoutSalonInput = {
    where: ReceivableWhereUniqueInput
    create: XOR<ReceivableCreateWithoutSalonInput, ReceivableUncheckedCreateWithoutSalonInput>
  }

  export type ReceivableCreateManySalonInputEnvelope = {
    data: ReceivableCreateManySalonInput | ReceivableCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type PayableCreateWithoutSalonInput = {
    id?: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: ClientCreateNestedOneWithoutPayablesInput
    installments?: PayableInstallmentCreateNestedManyWithoutPayableInput
  }

  export type PayableUncheckedCreateWithoutSalonInput = {
    id?: string
    supplierId?: string | null
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: PayableInstallmentUncheckedCreateNestedManyWithoutPayableInput
  }

  export type PayableCreateOrConnectWithoutSalonInput = {
    where: PayableWhereUniqueInput
    create: XOR<PayableCreateWithoutSalonInput, PayableUncheckedCreateWithoutSalonInput>
  }

  export type PayableCreateManySalonInputEnvelope = {
    data: PayableCreateManySalonInput | PayableCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type CostCreateWithoutSalonInput = {
    id?: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: ClientCreateNestedOneWithoutCostsInput
  }

  export type CostUncheckedCreateWithoutSalonInput = {
    id?: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    supplierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCreateOrConnectWithoutSalonInput = {
    where: CostWhereUniqueInput
    create: XOR<CostCreateWithoutSalonInput, CostUncheckedCreateWithoutSalonInput>
  }

  export type CostCreateManySalonInputEnvelope = {
    data: CostCreateManySalonInput | CostCreateManySalonInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSalonInput = {
    update: XOR<UserUpdateWithoutSalonInput, UserUncheckedUpdateWithoutSalonInput>
    create: XOR<UserCreateWithoutSalonInput, UserUncheckedCreateWithoutSalonInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalonInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalonInput, UserUncheckedUpdateWithoutSalonInput>
  }

  export type UserUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUpsertWithWhereUniqueWithoutSalonInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutSalonInput, ServiceUncheckedUpdateWithoutSalonInput>
    create: XOR<ServiceCreateWithoutSalonInput, ServiceUncheckedCreateWithoutSalonInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutSalonInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutSalonInput, ServiceUncheckedUpdateWithoutSalonInput>
  }

  export type ServiceUpdateManyWithWhereWithoutSalonInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutSalonInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    category?: StringNullableFilter<"Service"> | string | null
    price?: IntFilter<"Service"> | number
    duration?: IntFilter<"Service"> | number
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    salonId?: StringFilter<"Service"> | string
  }

  export type ClientUpsertWithWhereUniqueWithoutSalonInput = {
    where: ClientWhereUniqueInput
    update: XOR<ClientUpdateWithoutSalonInput, ClientUncheckedUpdateWithoutSalonInput>
    create: XOR<ClientCreateWithoutSalonInput, ClientUncheckedCreateWithoutSalonInput>
  }

  export type ClientUpdateWithWhereUniqueWithoutSalonInput = {
    where: ClientWhereUniqueInput
    data: XOR<ClientUpdateWithoutSalonInput, ClientUncheckedUpdateWithoutSalonInput>
  }

  export type ClientUpdateManyWithWhereWithoutSalonInput = {
    where: ClientScalarWhereInput
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyWithoutSalonInput>
  }

  export type ClientScalarWhereInput = {
    AND?: ClientScalarWhereInput | ClientScalarWhereInput[]
    OR?: ClientScalarWhereInput[]
    NOT?: ClientScalarWhereInput | ClientScalarWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    phone?: StringFilter<"Client"> | string
    instagram?: StringNullableFilter<"Client"> | string | null
    notes?: StringNullableFilter<"Client"> | string | null
    createdAt?: DateTimeFilter<"Client"> | Date | string
    type?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    salonId?: StringFilter<"Client"> | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutSalonInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutSalonInput, AppointmentUncheckedUpdateWithoutSalonInput>
    create: XOR<AppointmentCreateWithoutSalonInput, AppointmentUncheckedCreateWithoutSalonInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutSalonInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutSalonInput, AppointmentUncheckedUpdateWithoutSalonInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutSalonInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutSalonInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    startAt?: DateTimeFilter<"Appointment"> | Date | string
    endAt?: DateTimeFilter<"Appointment"> | Date | string
    status?: StringFilter<"Appointment"> | string
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    salonId?: StringFilter<"Appointment"> | string
    clientId?: StringFilter<"Appointment"> | string
    serviceId?: StringFilter<"Appointment"> | string
  }

  export type CashCategoryUpsertWithWhereUniqueWithoutSalonInput = {
    where: CashCategoryWhereUniqueInput
    update: XOR<CashCategoryUpdateWithoutSalonInput, CashCategoryUncheckedUpdateWithoutSalonInput>
    create: XOR<CashCategoryCreateWithoutSalonInput, CashCategoryUncheckedCreateWithoutSalonInput>
  }

  export type CashCategoryUpdateWithWhereUniqueWithoutSalonInput = {
    where: CashCategoryWhereUniqueInput
    data: XOR<CashCategoryUpdateWithoutSalonInput, CashCategoryUncheckedUpdateWithoutSalonInput>
  }

  export type CashCategoryUpdateManyWithWhereWithoutSalonInput = {
    where: CashCategoryScalarWhereInput
    data: XOR<CashCategoryUpdateManyMutationInput, CashCategoryUncheckedUpdateManyWithoutSalonInput>
  }

  export type CashCategoryScalarWhereInput = {
    AND?: CashCategoryScalarWhereInput | CashCategoryScalarWhereInput[]
    OR?: CashCategoryScalarWhereInput[]
    NOT?: CashCategoryScalarWhereInput | CashCategoryScalarWhereInput[]
    id?: StringFilter<"CashCategory"> | string
    name?: StringFilter<"CashCategory"> | string
    type?: EnumCashTypeFilter<"CashCategory"> | $Enums.CashType
    createdAt?: DateTimeFilter<"CashCategory"> | Date | string
    salonId?: StringFilter<"CashCategory"> | string
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutSalonInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutSalonInput, CashTransactionUncheckedUpdateWithoutSalonInput>
    create: XOR<CashTransactionCreateWithoutSalonInput, CashTransactionUncheckedCreateWithoutSalonInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutSalonInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutSalonInput, CashTransactionUncheckedUpdateWithoutSalonInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutSalonInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutSalonInput>
  }

  export type CashTransactionScalarWhereInput = {
    AND?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    OR?: CashTransactionScalarWhereInput[]
    NOT?: CashTransactionScalarWhereInput | CashTransactionScalarWhereInput[]
    id?: StringFilter<"CashTransaction"> | string
    type?: EnumCashTypeFilter<"CashTransaction"> | $Enums.CashType
    source?: EnumCashSourceFilter<"CashTransaction"> | $Enums.CashSource
    amount?: IntFilter<"CashTransaction"> | number
    occurredAt?: DateTimeFilter<"CashTransaction"> | Date | string
    description?: StringNullableFilter<"CashTransaction"> | string | null
    createdAt?: DateTimeFilter<"CashTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CashTransaction"> | Date | string
    salonId?: StringFilter<"CashTransaction"> | string
    categoryId?: StringNullableFilter<"CashTransaction"> | string | null
    appointmentId?: StringNullableFilter<"CashTransaction"> | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutSalonInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutSalonInput, OrderUncheckedUpdateWithoutSalonInput>
    create: XOR<OrderCreateWithoutSalonInput, OrderUncheckedCreateWithoutSalonInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutSalonInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutSalonInput, OrderUncheckedUpdateWithoutSalonInput>
  }

  export type OrderUpdateManyWithWhereWithoutSalonInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutSalonInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    clientId?: StringFilter<"Order"> | string
    salonId?: StringFilter<"Order"> | string
    subtotalCents?: IntFilter<"Order"> | number
    discountCents?: IntFilter<"Order"> | number
    totalCents?: IntFilter<"Order"> | number
    paymentMode?: EnumPaymentModeFilter<"Order"> | $Enums.PaymentMode
    paymentMethod?: EnumPaymentMethodNullableFilter<"Order"> | $Enums.PaymentMethod | null
    installmentsCount?: IntFilter<"Order"> | number
    firstDueDate?: DateTimeNullableFilter<"Order"> | Date | string | null
    expectedDeliveryAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Order"> | Date | string | null
    notes?: StringNullableFilter<"Order"> | string | null
  }

  export type ReceivableUpsertWithWhereUniqueWithoutSalonInput = {
    where: ReceivableWhereUniqueInput
    update: XOR<ReceivableUpdateWithoutSalonInput, ReceivableUncheckedUpdateWithoutSalonInput>
    create: XOR<ReceivableCreateWithoutSalonInput, ReceivableUncheckedCreateWithoutSalonInput>
  }

  export type ReceivableUpdateWithWhereUniqueWithoutSalonInput = {
    where: ReceivableWhereUniqueInput
    data: XOR<ReceivableUpdateWithoutSalonInput, ReceivableUncheckedUpdateWithoutSalonInput>
  }

  export type ReceivableUpdateManyWithWhereWithoutSalonInput = {
    where: ReceivableScalarWhereInput
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyWithoutSalonInput>
  }

  export type ReceivableScalarWhereInput = {
    AND?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
    OR?: ReceivableScalarWhereInput[]
    NOT?: ReceivableScalarWhereInput | ReceivableScalarWhereInput[]
    id?: StringFilter<"Receivable"> | string
    orderId?: StringFilter<"Receivable"> | string
    salonId?: StringFilter<"Receivable"> | string
    totalCents?: IntFilter<"Receivable"> | number
    method?: EnumPaymentMethodNullableFilter<"Receivable"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"Receivable"> | Date | string
    updatedAt?: DateTimeFilter<"Receivable"> | Date | string
  }

  export type PayableUpsertWithWhereUniqueWithoutSalonInput = {
    where: PayableWhereUniqueInput
    update: XOR<PayableUpdateWithoutSalonInput, PayableUncheckedUpdateWithoutSalonInput>
    create: XOR<PayableCreateWithoutSalonInput, PayableUncheckedCreateWithoutSalonInput>
  }

  export type PayableUpdateWithWhereUniqueWithoutSalonInput = {
    where: PayableWhereUniqueInput
    data: XOR<PayableUpdateWithoutSalonInput, PayableUncheckedUpdateWithoutSalonInput>
  }

  export type PayableUpdateManyWithWhereWithoutSalonInput = {
    where: PayableScalarWhereInput
    data: XOR<PayableUpdateManyMutationInput, PayableUncheckedUpdateManyWithoutSalonInput>
  }

  export type PayableScalarWhereInput = {
    AND?: PayableScalarWhereInput | PayableScalarWhereInput[]
    OR?: PayableScalarWhereInput[]
    NOT?: PayableScalarWhereInput | PayableScalarWhereInput[]
    id?: StringFilter<"Payable"> | string
    supplierId?: StringNullableFilter<"Payable"> | string | null
    salonId?: StringFilter<"Payable"> | string
    description?: StringFilter<"Payable"> | string
    totalCents?: IntFilter<"Payable"> | number
    createdAt?: DateTimeFilter<"Payable"> | Date | string
    updatedAt?: DateTimeFilter<"Payable"> | Date | string
  }

  export type CostUpsertWithWhereUniqueWithoutSalonInput = {
    where: CostWhereUniqueInput
    update: XOR<CostUpdateWithoutSalonInput, CostUncheckedUpdateWithoutSalonInput>
    create: XOR<CostCreateWithoutSalonInput, CostUncheckedCreateWithoutSalonInput>
  }

  export type CostUpdateWithWhereUniqueWithoutSalonInput = {
    where: CostWhereUniqueInput
    data: XOR<CostUpdateWithoutSalonInput, CostUncheckedUpdateWithoutSalonInput>
  }

  export type CostUpdateManyWithWhereWithoutSalonInput = {
    where: CostScalarWhereInput
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyWithoutSalonInput>
  }

  export type CostScalarWhereInput = {
    AND?: CostScalarWhereInput | CostScalarWhereInput[]
    OR?: CostScalarWhereInput[]
    NOT?: CostScalarWhereInput | CostScalarWhereInput[]
    id?: StringFilter<"Cost"> | string
    salonId?: StringFilter<"Cost"> | string
    type?: EnumCostTypeFilter<"Cost"> | $Enums.CostType
    name?: StringFilter<"Cost"> | string
    description?: StringNullableFilter<"Cost"> | string | null
    amountCents?: IntFilter<"Cost"> | number
    occurredAt?: DateTimeFilter<"Cost"> | Date | string
    supplierId?: StringNullableFilter<"Cost"> | string | null
    createdAt?: DateTimeFilter<"Cost"> | Date | string
    updatedAt?: DateTimeFilter<"Cost"> | Date | string
  }

  export type SalonCreateWithoutServicesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutServicesInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutServicesInput, SalonUncheckedCreateWithoutServicesInput>
  }

  export type AppointmentCreateWithoutServiceInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutAppointmentsInput
    client: ClientCreateNestedOneWithoutAppointmentsInput
    cashTransaction?: CashTransactionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutServiceInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    clientId: string
    cashTransaction?: CashTransactionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentCreateManyServiceInputEnvelope = {
    data: AppointmentCreateManyServiceInput | AppointmentCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type SalonUpsertWithoutServicesInput = {
    update: XOR<SalonUpdateWithoutServicesInput, SalonUncheckedUpdateWithoutServicesInput>
    create: XOR<SalonCreateWithoutServicesInput, SalonUncheckedCreateWithoutServicesInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutServicesInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutServicesInput, SalonUncheckedUpdateWithoutServicesInput>
  }

  export type SalonUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutServiceInput, AppointmentUncheckedUpdateWithoutServiceInput>
    create: XOR<AppointmentCreateWithoutServiceInput, AppointmentUncheckedCreateWithoutServiceInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutServiceInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutServiceInput, AppointmentUncheckedUpdateWithoutServiceInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutServiceInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutServiceInput>
  }

  export type SalonCreateWithoutClientsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutClientsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutClientsInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutClientsInput, SalonUncheckedCreateWithoutClientsInput>
  }

  export type AppointmentCreateWithoutClientInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
    cashTransaction?: CashTransactionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutClientInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    serviceId: string
    cashTransaction?: CashTransactionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput>
  }

  export type AppointmentCreateManyClientInputEnvelope = {
    data: AppointmentCreateManyClientInput | AppointmentCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutClientInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    salon: SalonCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryCreateNestedManyWithoutOrderInput
    receivables?: ReceivableCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutClientInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutOrderInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutClientInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateManyClientInputEnvelope = {
    data: OrderCreateManyClientInput | OrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type PayableCreateWithoutSupplierInput = {
    id?: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutPayablesInput
    installments?: PayableInstallmentCreateNestedManyWithoutPayableInput
  }

  export type PayableUncheckedCreateWithoutSupplierInput = {
    id?: string
    salonId: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: PayableInstallmentUncheckedCreateNestedManyWithoutPayableInput
  }

  export type PayableCreateOrConnectWithoutSupplierInput = {
    where: PayableWhereUniqueInput
    create: XOR<PayableCreateWithoutSupplierInput, PayableUncheckedCreateWithoutSupplierInput>
  }

  export type PayableCreateManySupplierInputEnvelope = {
    data: PayableCreateManySupplierInput | PayableCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type CostCreateWithoutSupplierInput = {
    id?: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutCostsInput
  }

  export type CostUncheckedCreateWithoutSupplierInput = {
    id?: string
    salonId: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCreateOrConnectWithoutSupplierInput = {
    where: CostWhereUniqueInput
    create: XOR<CostCreateWithoutSupplierInput, CostUncheckedCreateWithoutSupplierInput>
  }

  export type CostCreateManySupplierInputEnvelope = {
    data: CostCreateManySupplierInput | CostCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type SalonUpsertWithoutClientsInput = {
    update: XOR<SalonUpdateWithoutClientsInput, SalonUncheckedUpdateWithoutClientsInput>
    create: XOR<SalonCreateWithoutClientsInput, SalonUncheckedCreateWithoutClientsInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutClientsInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutClientsInput, SalonUncheckedUpdateWithoutClientsInput>
  }

  export type SalonUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutClientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutClientInput, AppointmentUncheckedUpdateWithoutClientInput>
    create: XOR<AppointmentCreateWithoutClientInput, AppointmentUncheckedCreateWithoutClientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutClientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutClientInput, AppointmentUncheckedUpdateWithoutClientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutClientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutClientInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithWhereWithoutClientInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutClientInput>
  }

  export type PayableUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PayableWhereUniqueInput
    update: XOR<PayableUpdateWithoutSupplierInput, PayableUncheckedUpdateWithoutSupplierInput>
    create: XOR<PayableCreateWithoutSupplierInput, PayableUncheckedCreateWithoutSupplierInput>
  }

  export type PayableUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PayableWhereUniqueInput
    data: XOR<PayableUpdateWithoutSupplierInput, PayableUncheckedUpdateWithoutSupplierInput>
  }

  export type PayableUpdateManyWithWhereWithoutSupplierInput = {
    where: PayableScalarWhereInput
    data: XOR<PayableUpdateManyMutationInput, PayableUncheckedUpdateManyWithoutSupplierInput>
  }

  export type CostUpsertWithWhereUniqueWithoutSupplierInput = {
    where: CostWhereUniqueInput
    update: XOR<CostUpdateWithoutSupplierInput, CostUncheckedUpdateWithoutSupplierInput>
    create: XOR<CostCreateWithoutSupplierInput, CostUncheckedCreateWithoutSupplierInput>
  }

  export type CostUpdateWithWhereUniqueWithoutSupplierInput = {
    where: CostWhereUniqueInput
    data: XOR<CostUpdateWithoutSupplierInput, CostUncheckedUpdateWithoutSupplierInput>
  }

  export type CostUpdateManyWithWhereWithoutSupplierInput = {
    where: CostScalarWhereInput
    data: XOR<CostUpdateManyMutationInput, CostUncheckedUpdateManyWithoutSupplierInput>
  }

  export type SalonCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutAppointmentsInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutAppointmentsInput, SalonUncheckedCreateWithoutAppointmentsInput>
  }

  export type ClientCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salon: SalonCreateNestedOneWithoutClientsInput
    orders?: OrderCreateNestedManyWithoutClientInput
    payables?: PayableCreateNestedManyWithoutSupplierInput
    costs?: CostCreateNestedManyWithoutSupplierInput
  }

  export type ClientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salonId: string
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    payables?: PayableUncheckedCreateNestedManyWithoutSupplierInput
    costs?: CostUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type ClientCreateOrConnectWithoutAppointmentsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
  }

  export type ServiceCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutServicesInput
  }

  export type ServiceUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
    salonId: string
  }

  export type ServiceCreateOrConnectWithoutAppointmentsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
  }

  export type CashTransactionCreateWithoutAppointmentInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutCashTransactionsInput
    category?: CashCategoryCreateNestedOneWithoutTransactionsInput
  }

  export type CashTransactionUncheckedCreateWithoutAppointmentInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    categoryId?: string | null
  }

  export type CashTransactionCreateOrConnectWithoutAppointmentInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutAppointmentInput, CashTransactionUncheckedCreateWithoutAppointmentInput>
  }

  export type SalonUpsertWithoutAppointmentsInput = {
    update: XOR<SalonUpdateWithoutAppointmentsInput, SalonUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<SalonCreateWithoutAppointmentsInput, SalonUncheckedCreateWithoutAppointmentsInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutAppointmentsInput, SalonUncheckedUpdateWithoutAppointmentsInput>
  }

  export type SalonUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type ClientUpsertWithoutAppointmentsInput = {
    update: XOR<ClientUpdateWithoutAppointmentsInput, ClientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ClientCreateWithoutAppointmentsInput, ClientUncheckedCreateWithoutAppointmentsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutAppointmentsInput, ClientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ClientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salon?: SalonUpdateOneRequiredWithoutClientsNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    payables?: PayableUpdateManyWithoutSupplierNestedInput
    costs?: CostUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salonId?: StringFieldUpdateOperationsInput | string
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSupplierNestedInput
    costs?: CostUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ServiceUpsertWithoutAppointmentsInput = {
    update: XOR<ServiceUpdateWithoutAppointmentsInput, ServiceUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<ServiceCreateWithoutAppointmentsInput, ServiceUncheckedCreateWithoutAppointmentsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAppointmentsInput, ServiceUncheckedUpdateWithoutAppointmentsInput>
  }

  export type ServiceUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutServicesNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
  }

  export type CashTransactionUpsertWithoutAppointmentInput = {
    update: XOR<CashTransactionUpdateWithoutAppointmentInput, CashTransactionUncheckedUpdateWithoutAppointmentInput>
    create: XOR<CashTransactionCreateWithoutAppointmentInput, CashTransactionUncheckedCreateWithoutAppointmentInput>
    where?: CashTransactionWhereInput
  }

  export type CashTransactionUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: CashTransactionWhereInput
    data: XOR<CashTransactionUpdateWithoutAppointmentInput, CashTransactionUncheckedUpdateWithoutAppointmentInput>
  }

  export type CashTransactionUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCashTransactionsNestedInput
    category?: CashCategoryUpdateOneWithoutTransactionsNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalonCreateWithoutCashCategoriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutCashCategoriesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutCashCategoriesInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutCashCategoriesInput, SalonUncheckedCreateWithoutCashCategoriesInput>
  }

  export type CashTransactionCreateWithoutCategoryInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutCashTransactionsInput
    appointment?: AppointmentCreateNestedOneWithoutCashTransactionInput
  }

  export type CashTransactionUncheckedCreateWithoutCategoryInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    appointmentId?: string | null
  }

  export type CashTransactionCreateOrConnectWithoutCategoryInput = {
    where: CashTransactionWhereUniqueInput
    create: XOR<CashTransactionCreateWithoutCategoryInput, CashTransactionUncheckedCreateWithoutCategoryInput>
  }

  export type CashTransactionCreateManyCategoryInputEnvelope = {
    data: CashTransactionCreateManyCategoryInput | CashTransactionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type SalonUpsertWithoutCashCategoriesInput = {
    update: XOR<SalonUpdateWithoutCashCategoriesInput, SalonUncheckedUpdateWithoutCashCategoriesInput>
    create: XOR<SalonCreateWithoutCashCategoriesInput, SalonUncheckedCreateWithoutCashCategoriesInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutCashCategoriesInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutCashCategoriesInput, SalonUncheckedUpdateWithoutCashCategoriesInput>
  }

  export type SalonUpdateWithoutCashCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutCashCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type CashTransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CashTransactionWhereUniqueInput
    update: XOR<CashTransactionUpdateWithoutCategoryInput, CashTransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<CashTransactionCreateWithoutCategoryInput, CashTransactionUncheckedCreateWithoutCategoryInput>
  }

  export type CashTransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CashTransactionWhereUniqueInput
    data: XOR<CashTransactionUpdateWithoutCategoryInput, CashTransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type CashTransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: CashTransactionScalarWhereInput
    data: XOR<CashTransactionUpdateManyMutationInput, CashTransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type SalonCreateWithoutCashTransactionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutCashTransactionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutCashTransactionsInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutCashTransactionsInput, SalonUncheckedCreateWithoutCashTransactionsInput>
  }

  export type CashCategoryCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutCashCategoriesInput
  }

  export type CashCategoryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
    salonId: string
  }

  export type CashCategoryCreateOrConnectWithoutTransactionsInput = {
    where: CashCategoryWhereUniqueInput
    create: XOR<CashCategoryCreateWithoutTransactionsInput, CashCategoryUncheckedCreateWithoutTransactionsInput>
  }

  export type AppointmentCreateWithoutCashTransactionInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salon: SalonCreateNestedOneWithoutAppointmentsInput
    client: ClientCreateNestedOneWithoutAppointmentsInput
    service: ServiceCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutCashTransactionInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    clientId: string
    serviceId: string
  }

  export type AppointmentCreateOrConnectWithoutCashTransactionInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCashTransactionInput, AppointmentUncheckedCreateWithoutCashTransactionInput>
  }

  export type SalonUpsertWithoutCashTransactionsInput = {
    update: XOR<SalonUpdateWithoutCashTransactionsInput, SalonUncheckedUpdateWithoutCashTransactionsInput>
    create: XOR<SalonCreateWithoutCashTransactionsInput, SalonUncheckedCreateWithoutCashTransactionsInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutCashTransactionsInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutCashTransactionsInput, SalonUncheckedUpdateWithoutCashTransactionsInput>
  }

  export type SalonUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutCashTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type CashCategoryUpsertWithoutTransactionsInput = {
    update: XOR<CashCategoryUpdateWithoutTransactionsInput, CashCategoryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<CashCategoryCreateWithoutTransactionsInput, CashCategoryUncheckedCreateWithoutTransactionsInput>
    where?: CashCategoryWhereInput
  }

  export type CashCategoryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: CashCategoryWhereInput
    data: XOR<CashCategoryUpdateWithoutTransactionsInput, CashCategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type CashCategoryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCashCategoriesNestedInput
  }

  export type CashCategoryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentUpsertWithoutCashTransactionInput = {
    update: XOR<AppointmentUpdateWithoutCashTransactionInput, AppointmentUncheckedUpdateWithoutCashTransactionInput>
    create: XOR<AppointmentCreateWithoutCashTransactionInput, AppointmentUncheckedCreateWithoutCashTransactionInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutCashTransactionInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutCashTransactionInput, AppointmentUncheckedUpdateWithoutCashTransactionInput>
  }

  export type AppointmentUpdateWithoutCashTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCashTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type ClientCreateWithoutOrdersInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salon: SalonCreateNestedOneWithoutClientsInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    payables?: PayableCreateNestedManyWithoutSupplierInput
    costs?: CostCreateNestedManyWithoutSupplierInput
  }

  export type ClientUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salonId: string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    payables?: PayableUncheckedCreateNestedManyWithoutSupplierInput
    costs?: CostUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type ClientCreateOrConnectWithoutOrdersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
  }

  export type SalonCreateWithoutOrdersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutOrdersInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutOrdersInput, SalonUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    unitPriceCents?: number
    totalCents?: number
    createdAt?: Date | string
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    unitPriceCents?: number
    totalCents?: number
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    expectedAt?: Date | string | null
    deliveredAt?: Date | string | null
    address?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryUncheckedCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    expectedAt?: Date | string | null
    deliveredAt?: Date | string | null
    address?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeliveryCreateOrConnectWithoutOrderInput = {
    where: DeliveryWhereUniqueInput
    create: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryCreateManyOrderInputEnvelope = {
    data: DeliveryCreateManyOrderInput | DeliveryCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReceivableCreateWithoutOrderInput = {
    id?: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salon: SalonCreateNestedOneWithoutReceivablesInput
    installments?: ReceivableInstallmentCreateNestedManyWithoutReceivableInput
  }

  export type ReceivableUncheckedCreateWithoutOrderInput = {
    id?: string
    salonId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    installments?: ReceivableInstallmentUncheckedCreateNestedManyWithoutReceivableInput
  }

  export type ReceivableCreateOrConnectWithoutOrderInput = {
    where: ReceivableWhereUniqueInput
    create: XOR<ReceivableCreateWithoutOrderInput, ReceivableUncheckedCreateWithoutOrderInput>
  }

  export type ReceivableCreateManyOrderInputEnvelope = {
    data: ReceivableCreateManyOrderInput | ReceivableCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutOrdersInput = {
    update: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type ClientUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salon?: SalonUpdateOneRequiredWithoutClientsNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    payables?: PayableUpdateManyWithoutSupplierNestedInput
    costs?: CostUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salonId?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSupplierNestedInput
    costs?: CostUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SalonUpsertWithoutOrdersInput = {
    update: XOR<SalonUpdateWithoutOrdersInput, SalonUncheckedUpdateWithoutOrdersInput>
    create: XOR<SalonCreateWithoutOrdersInput, SalonUncheckedCreateWithoutOrdersInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutOrdersInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutOrdersInput, SalonUncheckedUpdateWithoutOrdersInput>
  }

  export type SalonUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    name?: StringFilter<"OrderItem"> | string
    description?: StringNullableFilter<"OrderItem"> | string | null
    quantity?: IntFilter<"OrderItem"> | number
    unitPriceCents?: IntFilter<"OrderItem"> | number
    totalCents?: IntFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type DeliveryUpsertWithWhereUniqueWithoutOrderInput = {
    where: DeliveryWhereUniqueInput
    update: XOR<DeliveryUpdateWithoutOrderInput, DeliveryUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryCreateWithoutOrderInput, DeliveryUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryUpdateWithWhereUniqueWithoutOrderInput = {
    where: DeliveryWhereUniqueInput
    data: XOR<DeliveryUpdateWithoutOrderInput, DeliveryUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryUpdateManyWithWhereWithoutOrderInput = {
    where: DeliveryScalarWhereInput
    data: XOR<DeliveryUpdateManyMutationInput, DeliveryUncheckedUpdateManyWithoutOrderInput>
  }

  export type DeliveryScalarWhereInput = {
    AND?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    OR?: DeliveryScalarWhereInput[]
    NOT?: DeliveryScalarWhereInput | DeliveryScalarWhereInput[]
    id?: StringFilter<"Delivery"> | string
    orderId?: StringFilter<"Delivery"> | string
    status?: EnumDeliveryStatusFilter<"Delivery"> | $Enums.DeliveryStatus
    expectedAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    deliveredAt?: DateTimeNullableFilter<"Delivery"> | Date | string | null
    address?: StringNullableFilter<"Delivery"> | string | null
    notes?: StringNullableFilter<"Delivery"> | string | null
    createdAt?: DateTimeFilter<"Delivery"> | Date | string
    updatedAt?: DateTimeFilter<"Delivery"> | Date | string
  }

  export type ReceivableUpsertWithWhereUniqueWithoutOrderInput = {
    where: ReceivableWhereUniqueInput
    update: XOR<ReceivableUpdateWithoutOrderInput, ReceivableUncheckedUpdateWithoutOrderInput>
    create: XOR<ReceivableCreateWithoutOrderInput, ReceivableUncheckedCreateWithoutOrderInput>
  }

  export type ReceivableUpdateWithWhereUniqueWithoutOrderInput = {
    where: ReceivableWhereUniqueInput
    data: XOR<ReceivableUpdateWithoutOrderInput, ReceivableUncheckedUpdateWithoutOrderInput>
  }

  export type ReceivableUpdateManyWithWhereWithoutOrderInput = {
    where: ReceivableScalarWhereInput
    data: XOR<ReceivableUpdateManyMutationInput, ReceivableUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderCreateWithoutItemsInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    salon: SalonCreateNestedOneWithoutOrdersInput
    deliveries?: DeliveryCreateNestedManyWithoutOrderInput
    receivables?: ReceivableCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutOrderInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    salon?: SalonUpdateOneRequiredWithoutOrdersNestedInput
    deliveries?: DeliveryUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    deliveries?: DeliveryUncheckedUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutDeliveriesInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    salon: SalonCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    receivables?: ReceivableCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveriesInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveriesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveriesInput, OrderUncheckedCreateWithoutDeliveriesInput>
  }

  export type OrderUpsertWithoutDeliveriesInput = {
    update: XOR<OrderUpdateWithoutDeliveriesInput, OrderUncheckedUpdateWithoutDeliveriesInput>
    create: XOR<OrderCreateWithoutDeliveriesInput, OrderUncheckedCreateWithoutDeliveriesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDeliveriesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDeliveriesInput, OrderUncheckedUpdateWithoutDeliveriesInput>
  }

  export type OrderUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    salon?: SalonUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateWithoutReceivablesInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    salon: SalonCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReceivablesInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveries?: DeliveryUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReceivablesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReceivablesInput, OrderUncheckedCreateWithoutReceivablesInput>
  }

  export type SalonCreateWithoutReceivablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutReceivablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutReceivablesInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutReceivablesInput, SalonUncheckedCreateWithoutReceivablesInput>
  }

  export type ReceivableInstallmentCreateWithoutReceivableInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type ReceivableInstallmentUncheckedCreateWithoutReceivableInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type ReceivableInstallmentCreateOrConnectWithoutReceivableInput = {
    where: ReceivableInstallmentWhereUniqueInput
    create: XOR<ReceivableInstallmentCreateWithoutReceivableInput, ReceivableInstallmentUncheckedCreateWithoutReceivableInput>
  }

  export type ReceivableInstallmentCreateManyReceivableInputEnvelope = {
    data: ReceivableInstallmentCreateManyReceivableInput | ReceivableInstallmentCreateManyReceivableInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutReceivablesInput = {
    update: XOR<OrderUpdateWithoutReceivablesInput, OrderUncheckedUpdateWithoutReceivablesInput>
    create: XOR<OrderCreateWithoutReceivablesInput, OrderUncheckedCreateWithoutReceivablesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReceivablesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReceivablesInput, OrderUncheckedUpdateWithoutReceivablesInput>
  }

  export type OrderUpdateWithoutReceivablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    salon?: SalonUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReceivablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type SalonUpsertWithoutReceivablesInput = {
    update: XOR<SalonUpdateWithoutReceivablesInput, SalonUncheckedUpdateWithoutReceivablesInput>
    create: XOR<SalonCreateWithoutReceivablesInput, SalonUncheckedCreateWithoutReceivablesInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutReceivablesInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutReceivablesInput, SalonUncheckedUpdateWithoutReceivablesInput>
  }

  export type SalonUpdateWithoutReceivablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutReceivablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type ReceivableInstallmentUpsertWithWhereUniqueWithoutReceivableInput = {
    where: ReceivableInstallmentWhereUniqueInput
    update: XOR<ReceivableInstallmentUpdateWithoutReceivableInput, ReceivableInstallmentUncheckedUpdateWithoutReceivableInput>
    create: XOR<ReceivableInstallmentCreateWithoutReceivableInput, ReceivableInstallmentUncheckedCreateWithoutReceivableInput>
  }

  export type ReceivableInstallmentUpdateWithWhereUniqueWithoutReceivableInput = {
    where: ReceivableInstallmentWhereUniqueInput
    data: XOR<ReceivableInstallmentUpdateWithoutReceivableInput, ReceivableInstallmentUncheckedUpdateWithoutReceivableInput>
  }

  export type ReceivableInstallmentUpdateManyWithWhereWithoutReceivableInput = {
    where: ReceivableInstallmentScalarWhereInput
    data: XOR<ReceivableInstallmentUpdateManyMutationInput, ReceivableInstallmentUncheckedUpdateManyWithoutReceivableInput>
  }

  export type ReceivableInstallmentScalarWhereInput = {
    AND?: ReceivableInstallmentScalarWhereInput | ReceivableInstallmentScalarWhereInput[]
    OR?: ReceivableInstallmentScalarWhereInput[]
    NOT?: ReceivableInstallmentScalarWhereInput | ReceivableInstallmentScalarWhereInput[]
    id?: StringFilter<"ReceivableInstallment"> | string
    receivableId?: StringFilter<"ReceivableInstallment"> | string
    number?: IntFilter<"ReceivableInstallment"> | number
    dueDate?: DateTimeFilter<"ReceivableInstallment"> | Date | string
    amountCents?: IntFilter<"ReceivableInstallment"> | number
    status?: EnumInstallmentStatusFilter<"ReceivableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableFilter<"ReceivableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableFilter<"ReceivableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"ReceivableInstallment"> | Date | string
  }

  export type ReceivableCreateWithoutInstallmentsInput = {
    id?: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReceivablesInput
    salon: SalonCreateNestedOneWithoutReceivablesInput
  }

  export type ReceivableUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    orderId: string
    salonId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivableCreateOrConnectWithoutInstallmentsInput = {
    where: ReceivableWhereUniqueInput
    create: XOR<ReceivableCreateWithoutInstallmentsInput, ReceivableUncheckedCreateWithoutInstallmentsInput>
  }

  export type ReceivableUpsertWithoutInstallmentsInput = {
    update: XOR<ReceivableUpdateWithoutInstallmentsInput, ReceivableUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<ReceivableCreateWithoutInstallmentsInput, ReceivableUncheckedCreateWithoutInstallmentsInput>
    where?: ReceivableWhereInput
  }

  export type ReceivableUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: ReceivableWhereInput
    data: XOR<ReceivableUpdateWithoutInstallmentsInput, ReceivableUncheckedUpdateWithoutInstallmentsInput>
  }

  export type ReceivableUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReceivablesNestedInput
    salon?: SalonUpdateOneRequiredWithoutReceivablesNestedInput
  }

  export type ReceivableUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateWithoutPayablesInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salon: SalonCreateNestedOneWithoutClientsInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    costs?: CostCreateNestedManyWithoutSupplierInput
  }

  export type ClientUncheckedCreateWithoutPayablesInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salonId: string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    costs?: CostUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type ClientCreateOrConnectWithoutPayablesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutPayablesInput, ClientUncheckedCreateWithoutPayablesInput>
  }

  export type SalonCreateWithoutPayablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    costs?: CostCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutPayablesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    costs?: CostUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutPayablesInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutPayablesInput, SalonUncheckedCreateWithoutPayablesInput>
  }

  export type PayableInstallmentCreateWithoutPayableInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type PayableInstallmentUncheckedCreateWithoutPayableInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type PayableInstallmentCreateOrConnectWithoutPayableInput = {
    where: PayableInstallmentWhereUniqueInput
    create: XOR<PayableInstallmentCreateWithoutPayableInput, PayableInstallmentUncheckedCreateWithoutPayableInput>
  }

  export type PayableInstallmentCreateManyPayableInputEnvelope = {
    data: PayableInstallmentCreateManyPayableInput | PayableInstallmentCreateManyPayableInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutPayablesInput = {
    update: XOR<ClientUpdateWithoutPayablesInput, ClientUncheckedUpdateWithoutPayablesInput>
    create: XOR<ClientCreateWithoutPayablesInput, ClientUncheckedCreateWithoutPayablesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutPayablesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutPayablesInput, ClientUncheckedUpdateWithoutPayablesInput>
  }

  export type ClientUpdateWithoutPayablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salon?: SalonUpdateOneRequiredWithoutClientsNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    costs?: CostUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateWithoutPayablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salonId?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    costs?: CostUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SalonUpsertWithoutPayablesInput = {
    update: XOR<SalonUpdateWithoutPayablesInput, SalonUncheckedUpdateWithoutPayablesInput>
    create: XOR<SalonCreateWithoutPayablesInput, SalonUncheckedCreateWithoutPayablesInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutPayablesInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutPayablesInput, SalonUncheckedUpdateWithoutPayablesInput>
  }

  export type SalonUpdateWithoutPayablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    costs?: CostUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutPayablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    costs?: CostUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type PayableInstallmentUpsertWithWhereUniqueWithoutPayableInput = {
    where: PayableInstallmentWhereUniqueInput
    update: XOR<PayableInstallmentUpdateWithoutPayableInput, PayableInstallmentUncheckedUpdateWithoutPayableInput>
    create: XOR<PayableInstallmentCreateWithoutPayableInput, PayableInstallmentUncheckedCreateWithoutPayableInput>
  }

  export type PayableInstallmentUpdateWithWhereUniqueWithoutPayableInput = {
    where: PayableInstallmentWhereUniqueInput
    data: XOR<PayableInstallmentUpdateWithoutPayableInput, PayableInstallmentUncheckedUpdateWithoutPayableInput>
  }

  export type PayableInstallmentUpdateManyWithWhereWithoutPayableInput = {
    where: PayableInstallmentScalarWhereInput
    data: XOR<PayableInstallmentUpdateManyMutationInput, PayableInstallmentUncheckedUpdateManyWithoutPayableInput>
  }

  export type PayableInstallmentScalarWhereInput = {
    AND?: PayableInstallmentScalarWhereInput | PayableInstallmentScalarWhereInput[]
    OR?: PayableInstallmentScalarWhereInput[]
    NOT?: PayableInstallmentScalarWhereInput | PayableInstallmentScalarWhereInput[]
    id?: StringFilter<"PayableInstallment"> | string
    payableId?: StringFilter<"PayableInstallment"> | string
    number?: IntFilter<"PayableInstallment"> | number
    dueDate?: DateTimeFilter<"PayableInstallment"> | Date | string
    amountCents?: IntFilter<"PayableInstallment"> | number
    status?: EnumInstallmentStatusFilter<"PayableInstallment"> | $Enums.InstallmentStatus
    paidAt?: DateTimeNullableFilter<"PayableInstallment"> | Date | string | null
    method?: EnumPaymentMethodNullableFilter<"PayableInstallment"> | $Enums.PaymentMethod | null
    createdAt?: DateTimeFilter<"PayableInstallment"> | Date | string
  }

  export type PayableCreateWithoutInstallmentsInput = {
    id?: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier?: ClientCreateNestedOneWithoutPayablesInput
    salon: SalonCreateNestedOneWithoutPayablesInput
  }

  export type PayableUncheckedCreateWithoutInstallmentsInput = {
    id?: string
    supplierId?: string | null
    salonId: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayableCreateOrConnectWithoutInstallmentsInput = {
    where: PayableWhereUniqueInput
    create: XOR<PayableCreateWithoutInstallmentsInput, PayableUncheckedCreateWithoutInstallmentsInput>
  }

  export type PayableUpsertWithoutInstallmentsInput = {
    update: XOR<PayableUpdateWithoutInstallmentsInput, PayableUncheckedUpdateWithoutInstallmentsInput>
    create: XOR<PayableCreateWithoutInstallmentsInput, PayableUncheckedCreateWithoutInstallmentsInput>
    where?: PayableWhereInput
  }

  export type PayableUpdateToOneWithWhereWithoutInstallmentsInput = {
    where?: PayableWhereInput
    data: XOR<PayableUpdateWithoutInstallmentsInput, PayableUncheckedUpdateWithoutInstallmentsInput>
  }

  export type PayableUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: ClientUpdateOneWithoutPayablesNestedInput
    salon?: SalonUpdateOneRequiredWithoutPayablesNestedInput
  }

  export type PayableUncheckedUpdateWithoutInstallmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    salonId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalonCreateWithoutCostsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    user: UserCreateNestedOneWithoutSalonInput
    services?: ServiceCreateNestedManyWithoutSalonInput
    clients?: ClientCreateNestedManyWithoutSalonInput
    appointments?: AppointmentCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionCreateNestedManyWithoutSalonInput
    orders?: OrderCreateNestedManyWithoutSalonInput
    receivables?: ReceivableCreateNestedManyWithoutSalonInput
    payables?: PayableCreateNestedManyWithoutSalonInput
  }

  export type SalonUncheckedCreateWithoutCostsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    userId: string
    plan?: string
    planStatus?: string
    planEndsAt?: Date | string | null
    services?: ServiceUncheckedCreateNestedManyWithoutSalonInput
    clients?: ClientUncheckedCreateNestedManyWithoutSalonInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutSalonInput
    cashCategories?: CashCategoryUncheckedCreateNestedManyWithoutSalonInput
    cashTransactions?: CashTransactionUncheckedCreateNestedManyWithoutSalonInput
    orders?: OrderUncheckedCreateNestedManyWithoutSalonInput
    receivables?: ReceivableUncheckedCreateNestedManyWithoutSalonInput
    payables?: PayableUncheckedCreateNestedManyWithoutSalonInput
  }

  export type SalonCreateOrConnectWithoutCostsInput = {
    where: SalonWhereUniqueInput
    create: XOR<SalonCreateWithoutCostsInput, SalonUncheckedCreateWithoutCostsInput>
  }

  export type ClientCreateWithoutCostsInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salon: SalonCreateNestedOneWithoutClientsInput
    appointments?: AppointmentCreateNestedManyWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    payables?: PayableCreateNestedManyWithoutSupplierInput
  }

  export type ClientUncheckedCreateWithoutCostsInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
    salonId: string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    payables?: PayableUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type ClientCreateOrConnectWithoutCostsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutCostsInput, ClientUncheckedCreateWithoutCostsInput>
  }

  export type SalonUpsertWithoutCostsInput = {
    update: XOR<SalonUpdateWithoutCostsInput, SalonUncheckedUpdateWithoutCostsInput>
    create: XOR<SalonCreateWithoutCostsInput, SalonUncheckedCreateWithoutCostsInput>
    where?: SalonWhereInput
  }

  export type SalonUpdateToOneWithWhereWithoutCostsInput = {
    where?: SalonWhereInput
    data: XOR<SalonUpdateWithoutCostsInput, SalonUncheckedUpdateWithoutCostsInput>
  }

  export type SalonUpdateWithoutCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSalonNestedInput
    services?: ServiceUpdateManyWithoutSalonNestedInput
    clients?: ClientUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUpdateManyWithoutSalonNestedInput
    orders?: OrderUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUpdateManyWithoutSalonNestedInput
    payables?: PayableUpdateManyWithoutSalonNestedInput
  }

  export type SalonUncheckedUpdateWithoutCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    planStatus?: StringFieldUpdateOperationsInput | string
    planEndsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    services?: ServiceUncheckedUpdateManyWithoutSalonNestedInput
    clients?: ClientUncheckedUpdateManyWithoutSalonNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutSalonNestedInput
    cashCategories?: CashCategoryUncheckedUpdateManyWithoutSalonNestedInput
    cashTransactions?: CashTransactionUncheckedUpdateManyWithoutSalonNestedInput
    orders?: OrderUncheckedUpdateManyWithoutSalonNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutSalonNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSalonNestedInput
  }

  export type ClientUpsertWithoutCostsInput = {
    update: XOR<ClientUpdateWithoutCostsInput, ClientUncheckedUpdateWithoutCostsInput>
    create: XOR<ClientCreateWithoutCostsInput, ClientUncheckedCreateWithoutCostsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutCostsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutCostsInput, ClientUncheckedUpdateWithoutCostsInput>
  }

  export type ClientUpdateWithoutCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salon?: SalonUpdateOneRequiredWithoutClientsNestedInput
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    payables?: PayableUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateWithoutCostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    salonId?: StringFieldUpdateOperationsInput | string
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ServiceCreateManySalonInput = {
    id?: string
    name: string
    category?: string | null
    price: number
    duration: number
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ClientCreateManySalonInput = {
    id?: string
    name: string
    phone: string
    instagram?: string | null
    notes?: string | null
    createdAt?: Date | string
    type?: $Enums.ClientType
  }

  export type AppointmentCreateManySalonInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    clientId: string
    serviceId: string
  }

  export type CashCategoryCreateManySalonInput = {
    id?: string
    name: string
    type: $Enums.CashType
    createdAt?: Date | string
  }

  export type CashTransactionCreateManySalonInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    categoryId?: string | null
    appointmentId?: string | null
  }

  export type OrderCreateManySalonInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
  }

  export type ReceivableCreateManySalonInput = {
    id?: string
    orderId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayableCreateManySalonInput = {
    id?: string
    supplierId?: string | null
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCreateManySalonInput = {
    id?: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    supplierId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    duration?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    appointments?: AppointmentUpdateManyWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    payables?: PayableUpdateManyWithoutSupplierNestedInput
    costs?: CostUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    appointments?: AppointmentUncheckedUpdateManyWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    payables?: PayableUncheckedUpdateManyWithoutSupplierNestedInput
    costs?: CostUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type ClientUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    instagram?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
  }

  export type AppointmentUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    cashTransaction?: CashTransactionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cashTransaction?: CashTransactionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type CashCategoryUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CashTransactionUpdateManyWithoutCategoryNestedInput
  }

  export type CashCategoryUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: CashTransactionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CashCategoryUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CashCategoryUpdateOneWithoutTransactionsNestedInput
    appointment?: AppointmentUpdateOneWithoutCashTransactionNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashTransactionUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReceivableUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReceivablesNestedInput
    installments?: ReceivableInstallmentUpdateManyWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: ReceivableInstallmentUncheckedUpdateManyWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: ClientUpdateOneWithoutPayablesNestedInput
    installments?: PayableInstallmentUpdateManyWithoutPayableNestedInput
  }

  export type PayableUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: PayableInstallmentUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type PayableUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: ClientUpdateOneWithoutCostsNestedInput
  }

  export type CostUncheckedUpdateWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostUncheckedUpdateManyWithoutSalonInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplierId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyServiceInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    clientId: string
  }

  export type AppointmentUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutAppointmentsNestedInput
    client?: ClientUpdateOneRequiredWithoutAppointmentsNestedInput
    cashTransaction?: CashTransactionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    cashTransaction?: CashTransactionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
  }

  export type AppointmentCreateManyClientInput = {
    id?: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    salonId: string
    serviceId: string
  }

  export type OrderCreateManyClientInput = {
    id?: string
    status?: $Enums.OrderStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    subtotalCents?: number
    discountCents?: number
    totalCents?: number
    paymentMode?: $Enums.PaymentMode
    paymentMethod?: $Enums.PaymentMethod | null
    installmentsCount?: number
    firstDueDate?: Date | string | null
    expectedDeliveryAt?: Date | string | null
    deliveredAt?: Date | string | null
    notes?: string | null
  }

  export type PayableCreateManySupplierInput = {
    id?: string
    salonId: string
    description: string
    totalCents?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostCreateManySupplierInput = {
    id?: string
    salonId: string
    type: $Enums.CostType
    name: string
    description?: string | null
    amountCents: number
    occurredAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutAppointmentsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAppointmentsNestedInput
    cashTransaction?: CashTransactionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    cashTransaction?: CashTransactionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    salon?: SalonUpdateOneRequiredWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveries?: DeliveryUncheckedUpdateManyWithoutOrderNestedInput
    receivables?: ReceivableUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    subtotalCents?: IntFieldUpdateOperationsInput | number
    discountCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    paymentMode?: EnumPaymentModeFieldUpdateOperationsInput | $Enums.PaymentMode
    paymentMethod?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    installmentsCount?: IntFieldUpdateOperationsInput | number
    firstDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PayableUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutPayablesNestedInput
    installments?: PayableInstallmentUpdateManyWithoutPayableNestedInput
  }

  export type PayableUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: PayableInstallmentUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type PayableUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCostsNestedInput
  }

  export type CostUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    type?: EnumCostTypeFieldUpdateOperationsInput | $Enums.CostType
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    amountCents?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CashTransactionCreateManyCategoryInput = {
    id?: string
    type: $Enums.CashType
    source?: $Enums.CashSource
    amount: number
    occurredAt: Date | string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    salonId: string
    appointmentId?: string | null
  }

  export type CashTransactionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutCashTransactionsNestedInput
    appointment?: AppointmentUpdateOneWithoutCashTransactionNestedInput
  }

  export type CashTransactionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CashTransactionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumCashTypeFieldUpdateOperationsInput | $Enums.CashType
    source?: EnumCashSourceFieldUpdateOperationsInput | $Enums.CashSource
    amount?: IntFieldUpdateOperationsInput | number
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salonId?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    name: string
    description?: string | null
    quantity?: number
    unitPriceCents?: number
    totalCents?: number
    createdAt?: Date | string
  }

  export type DeliveryCreateManyOrderInput = {
    id?: string
    status?: $Enums.DeliveryStatus
    expectedAt?: Date | string | null
    deliveredAt?: Date | string | null
    address?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReceivableCreateManyOrderInput = {
    id?: string
    salonId: string
    totalCents?: number
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: IntFieldUpdateOperationsInput | number
    unitPriceCents?: IntFieldUpdateOperationsInput | number
    totalCents?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumDeliveryStatusFieldUpdateOperationsInput | $Enums.DeliveryStatus
    expectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deliveredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    salon?: SalonUpdateOneRequiredWithoutReceivablesNestedInput
    installments?: ReceivableInstallmentUpdateManyWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installments?: ReceivableInstallmentUncheckedUpdateManyWithoutReceivableNestedInput
  }

  export type ReceivableUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    salonId?: StringFieldUpdateOperationsInput | string
    totalCents?: IntFieldUpdateOperationsInput | number
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableInstallmentCreateManyReceivableInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type ReceivableInstallmentUpdateWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableInstallmentUncheckedUpdateWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReceivableInstallmentUncheckedUpdateManyWithoutReceivableInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableInstallmentCreateManyPayableInput = {
    id?: string
    number: number
    dueDate: Date | string
    amountCents: number
    status?: $Enums.InstallmentStatus
    paidAt?: Date | string | null
    method?: $Enums.PaymentMethod | null
    createdAt?: Date | string
  }

  export type PayableInstallmentUpdateWithoutPayableInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableInstallmentUncheckedUpdateWithoutPayableInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayableInstallmentUncheckedUpdateManyWithoutPayableInput = {
    id?: StringFieldUpdateOperationsInput | string
    number?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amountCents?: IntFieldUpdateOperationsInput | number
    status?: EnumInstallmentStatusFieldUpdateOperationsInput | $Enums.InstallmentStatus
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    method?: NullableEnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}